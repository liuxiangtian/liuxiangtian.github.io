<!DOCTYPE html>





<html lang="zh-CN,ja,en,default">
<head>
  <!-- hexo-inject:begin --><!-- hexo-inject:end --><meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=2">
<meta name="theme-color" content="#222">
<meta name="generator" content="Hexo 3.9.0">
  <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon-next.png?v=7.4.0">
  <link rel="icon" type="image/png" sizes="32x32" href="/images/favicon-32x32-next.png?v=7.4.0">
  <link rel="icon" type="image/png" sizes="16x16" href="/images/favicon-16x16-next.png?v=7.4.0">
  <link rel="mask-icon" href="/images/logo.svg?v=7.4.0" color="#222">

<link rel="stylesheet" href="/css/main.css?v=7.4.0">


<link rel="stylesheet" href="/lib/font-awesome/css/font-awesome.min.css?v=4.7.0">


<script id="hexo-configurations">
  var NexT = window.NexT || {};
  var CONFIG = {
    root: '/',
    scheme: 'Gemini',
    version: '7.4.0',
    exturl: false,
    sidebar: {"position":"left","display":"hide","offset":12,"onmobile":false},
    copycode: {"enable":false,"show_result":false,"style":null},
    back2top: {"enable":true,"sidebar":false,"scrollpercent":false},
    bookmark: {"enable":true,"color":"#222","save":"auto"},
    fancybox: false,
    mediumzoom: false,
    lazyload: false,
    pangu: false,
    algolia: {
      appID: '',
      apiKey: '',
      indexName: '',
      hits: {"per_page":10},
      labels: {"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}
    },
    localsearch: {"enable":false,"trigger":"auto","top_n_per_article":1,"unescape":false,"preload":false},
    path: '',
    motion: {"enable":true,"async":false,"transition":{"post_block":"fadeIn","post_header":"slideDownIn","post_body":"slideDownIn","coll_header":"slideLeftIn","sidebar":"slideUpIn"}},
    translation: {
      copy_button: '复制',
      copy_success: '复制成功',
      copy_failure: '复制失败'
    },
    sidebarPadding: 40
  };
</script>

  <meta name="description" content="谨守而勿失，是谓反其真">
<meta property="og:type" content="website">
<meta property="og:title" content="lxt">
<meta property="og:url" content="http://yoursite.com/page/2/index.html">
<meta property="og:site_name" content="lxt">
<meta property="og:description" content="谨守而勿失，是谓反其真">
<meta property="og:locale" content="zh-CN">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="lxt">
<meta name="twitter:description" content="谨守而勿失，是谓反其真">
  <link rel="canonical" href="http://yoursite.com/page/2/">


<script id="page-configurations">
  // https://hexo.io/docs/variables.html
  CONFIG.page = {
    sidebar: "",
    isHome: true,
    isPost: false,
    isPage: false,
    isArchive: false
  };
</script>

  <title>lxt</title>
  








  <noscript>
  <style>
  .use-motion .brand,
  .use-motion .menu-item,
  .sidebar-inner,
  .use-motion .post-block,
  .use-motion .pagination,
  .use-motion .comments,
  .use-motion .post-header,
  .use-motion .post-body,
  .use-motion .collection-header { opacity: initial; }

  .use-motion .logo,
  .use-motion .site-title,
  .use-motion .site-subtitle {
    opacity: initial;
    top: initial;
  }

  .use-motion .logo-line-before i { left: initial; }
  .use-motion .logo-line-after i { right: initial; }
  </style>
</noscript><!-- hexo-inject:begin --><!-- hexo-inject:end -->

<link rel="stylesheet" href="\assets\css\APlayer.min.css" class="aplayer-style-marker">
<script src="\assets\js\APlayer.min.js" class="aplayer-script-marker"></script>
</head>

<body itemscope itemtype="http://schema.org/WebPage" lang="zh-CN">
  <!-- hexo-inject:begin --><!-- hexo-inject:end --><div class="container use-motion">
    <div class="headband"></div>

    <header id="header" class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-container">
  <div class="site-meta">

    <div>
      <a href="/" class="brand" rel="start">
        <span class="logo-line-before"><i></i></span>
        <span class="site-title">lxt</span>
        <span class="logo-line-after"><i></i></span>
      </a>
    </div>
  </div>

  <div class="site-nav-toggle">
    <button aria-label="切换导航栏">
      <span class="btn-bar"></span>
      <span class="btn-bar"></span>
      <span class="btn-bar"></span>
    </button>
  </div>
</div>


<nav class="site-nav">
  
  <ul id="menu" class="menu">
      
      
      
        
        <li class="menu-item menu-item-home">
      
    

    <a href="/" rel="section"><i class="menu-item-icon fa fa-fw fa-home"></i> <br>首页</a>

  </li>
      
      
      
        
        <li class="menu-item menu-item-tags">
      
    

    <a href="/tags/" rel="section"><i class="menu-item-icon fa fa-fw fa-tags"></i> <br>标签</a>

  </li>
      
      
      
        
        <li class="menu-item menu-item-categories">
      
    

    <a href="/categories/" rel="section"><i class="menu-item-icon fa fa-fw fa-th"></i> <br>分类</a>

  </li>
      
      
      
        
        <li class="menu-item menu-item-archives">
      
    

    <a href="/archives/" rel="section"><i class="menu-item-icon fa fa-fw fa-archive"></i> <br>归档</a>

  </li>
  </ul>

</nav>
</div>
    </header>

    
  <div class="back-to-top">
    <i class="fa fa-arrow-up"></i>
    <span>0%</span>
  </div>
  <div class="reading-progress-bar"></div>
  <a class="book-mark-link book-mark-link-fixed" href="#"></a>


    <main id="main" class="main">
      <div class="main-inner">
        <div class="content-wrap">
            

          <div id="content" class="content">
            
  <div id="posts" class="posts-expand">
        <article itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block home">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2018/12/13/日本語/标准日本语笔记/9~12.四川料理は辛いです/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="xiang">
      <meta itemprop="description" content="谨守而勿失，是谓反其真">
      <meta itemprop="image" content="/images/1.jpg">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="lxt">
    </span>
      <header class="post-header">
        <h1 class="post-title" itemprop="name headline">
            
            <a href="/2018/12/13/日本語/标准日本语笔记/9~12.四川料理は辛いです/" class="post-title-link" itemprop="url">新标日9-12课</a>
          
        </h1>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              
                
              

              <time title="创建时间：2018-12-13 11:26:26" itemprop="dateCreated datePublished" datetime="2018-12-13T11:26:26+08:00">2018-12-13</time>
            </span>
          
            

            
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="fa fa-calendar-check-o"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2019-09-19 20:20:56" itemprop="dateModified" datetime="2019-09-19T20:20:56+08:00">2019-09-19</time>
              </span>
            
          
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing"><a href="/categories/日本語/" itemprop="url" rel="index"><span itemprop="name">日本語</span></a></span>

                
                
                  ，
                
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing"><a href="/categories/日本語/标准日本语笔记/" itemprop="url" rel="index"><span itemprop="name">标准日本语笔记</span></a></span>

                
                
              
            </span>
          

          
          <br>
            <span class="post-meta-item" title="本文字数">
              <span class="post-meta-item-icon">
                <i class="fa fa-file-word-o"></i>
              </span>
              
                <span class="post-meta-item-text">本文字数：</span>
              
              <span>1.4k</span>
            </span>
          
            <span class="post-meta-item" title="阅读时长">
              <span class="post-meta-item-icon">
                <i class="fa fa-clock-o"></i>
              </span>
              
                <span class="post-meta-item-text">阅读时长 &asymp;</span>
              
              <span>1 分钟</span>
            </span>
          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h2 id="四川料理は-辛いです"><a href="#四川料理は-辛いです" class="headerlink" title="四川料理は　辛いです"></a>四川料理は　辛いです</h2><p>一类形容词四种形态</p>
<p>四川料理は　辛いです。</p>
<p>四川料理は　甘く　ないです。</p>
<p>四川料理は　苦かったです。</p>
<p>四川料理は　苦くなかったです。</p>
<h3 id="温泉"><a href="#温泉" class="headerlink" title="温泉"></a>温泉</h3><h2 id="京都の紅葉は-有名です"><a href="#京都の紅葉は-有名です" class="headerlink" title="京都の紅葉は　有名です"></a>京都の紅葉は　有名です</h2><p>二类形容词+名词四种形态</p>
<p>京都は　にぎやかです。</p>
<p>京都は　静か<strong>では　ありません</strong>。</p>
<p>京都は　にぎやか<strong>でした</strong>。</p>
<p>京都は　静か<strong>では　ありませんでした</strong>。</p>
<p>奈良は　静か<strong>な</strong>　町です。　－　<strong>きれいな</strong>　人形を　買いました。</p>
<p>この料理は　どう　ですか？　‐　この料理は　いかがですか？</p>
<p>横浜は　とんな町　ですか？</p>
<h3 id="美術館"><a href="#美術館" class="headerlink" title="美術館"></a>美術館</h3><p>休みの日は　観光客が　多いです。</p>
<h2 id="小野さんは-歌が-好きです"><a href="#小野さんは-歌が-好きです" class="headerlink" title="小野さんは　歌が　好きです"></a>小野さんは　歌が　好きです</h2><p><strong>形容词作动词用，一类是情感形容词，一类是能力形容词。</strong></p>
<p>小野さんは　犬<strong>が</strong>　怖いです。・こわい</p>
<p>王さんは　肉<strong>が</strong>　嫌いです。　・きらい　</p>
<p>小野さんは　日本語が　上手です。・じょうず</p>
<p>小野さんは　日本語が　下手です。・へた</p>
<p>小野さんは　日本語が　苦手です。・にがて</p>
<p>小野さんは　日本語が　できます。・わかりません</p>
<h3 id="お土産"><a href="#お土産" class="headerlink" title="お土産"></a>お土産</h3><p>この近くのホテルで　友達の写真展が　ありますから。</p>
<h2 id="李さんは-森さんより-若いです"><a href="#李さんは-森さんより-若いです" class="headerlink" title="李さんは　森さんより　若いです"></a>李さんは　森さんより　若いです</h2><p>森さん<strong>より</strong>　李さん<strong>の　ほんが</strong>　若いです。</p>
<p>李さんは　森さん<strong>ほど</strong>　若<strong>く　ない</strong>です。　静かでは　ありません。</p>
<p>　<strong>の　中で</strong>　李さん<strong>が　いちばん</strong>　若いです。</p>
<p>​    <strong>の　中で</strong>　誰<strong>が　いちばん</strong>　若いです？</p>
<p>​            李さん<strong>が　いちばん</strong>　若いです。</p>
<p>李さん<strong>と</strong>　森さん<strong>と　どちらが</strong>　若いですか？</p>
<p>​            李さん<strong>の　ほんが</strong>　若いです。</p>
<p>森さんは　テニスが　上手ですね？</p>
<p>​            いいえ、長島さん<strong>ほど　上手では　ありません</strong>。</p>
<h3 id="お茶とお酒・さけ"><a href="#お茶とお酒・さけ" class="headerlink" title="お茶とお酒・さけ"></a>お茶とお酒・さけ</h3><h2 id="单词"><a href="#单词" class="headerlink" title="单词"></a>单词</h2><h3 id="天气"><a href="#天气" class="headerlink" title="天气"></a>天气</h3><ul>
<li>天気予報・よほう　</li>
<li>晴・はれ　曇・くもり　</li>
<li>雨・あめ　雪・ゆき　霧・きり　雷・かみなり　風・かぜ　</li>
<li>虹・にじ　</li>
<li>蒸し暑い・む　</li>
<li>暖かい・あたた　涼しい・すず　</li>
<li>冬・ふゆ　春・はる　秋・あき</li>
</ul>
<h3 id="地名"><a href="#地名" class="headerlink" title="地名"></a>地名</h3><p>札幌・さっぽろ　名古屋・なごや　　仙台・せんだい　新潟・にいがた　</p>
<p>神戸・こうべ　　高知・こうち　　　長崎・ながさき　福岡・ふくおか</p>
<p>渋谷・しぶや　　新宿・しんじゅく　<strong>秋葉原・あきはばら</strong>　<strong>上野・うえの</strong></p>
<p>広州・こうしゅう　昆明・こんめい　<strong>桂林・けいりん</strong>　紹興・しょうこう</p>
<p>大連・だいれん　天津・てんしん　　北京・ぺきん　　西安・せいあん</p>
<p>武漢・ぶかん　　杭州・こうしゅう　成都・せいと　　重慶・じゅうけい</p>
<h3 id="片假名"><a href="#片假名" class="headerlink" title="片假名"></a>片假名</h3><ul>
<li>スープ　</li>
<li>ニュース　</li>
<li>グラス</li>
<li>シーズン　</li>
<li>ハンサム　</li>
<li>カラオケ　</li>
<li>ロック　</li>
<li>ポップス　</li>
<li>クラシック</li>
<li>スポーツ　</li>
<li>ゴルフ</li>
<li>バラ</li>
<li>ナシ　🍐　</li>
<li>バナナ　🍌　</li>
<li>ジュース　</li>
<li></li>
</ul>
<h2 id="生词"><a href="#生词" class="headerlink" title="生词"></a>生词</h2><ul>
<li><p>すき焼き　</p>
</li>
<li><p>眺め・ながめ　</p>
</li>
<li><p>気持ち・きもち　</p>
</li>
<li><p>たくさん　</p>
</li>
<li><p>通り・とおり　</p>
</li>
<li><p>所・ところ　</p>
</li>
<li><p>お菓子・おかし　</p>
</li>
<li><p>平日・へいじつ　</p>
</li>
<li><p>生活・せいかつ　</p>
</li>
<li><p>もう少し・すこ　</p>
</li>
<li><p>いかが・如何　</p>
</li>
<li><p>どうして</p>
</li>
<li><p>だから・ですから</p>
</li>
<li><p>別荘・べっそう　</p>
</li>
<li><p>また・たまに・よく</p>
</li>
<li><p>等々・など　</p>
</li>
<li><p>季節・きせつ　</p>
</li>
<li><p>緑茶・りょく</p>
</li>
<li><p>大好き・だいすき　</p>
</li>
</ul>
<h3 id="形容词"><a href="#形容词" class="headerlink" title="形容词"></a>形容词</h3><ul>
<li>新しい・あたら　古い・ふるい　</li>
<li>高い　低い・ひく</li>
<li>難しい・むずか　易しい・やさ　</li>
<li>いい　悪い・わる　</li>
<li>熱い　冷たい・つめたい　</li>
<li>多い　少ない・すく　</li>
<li>広い　狭い・せま　</li>
<li>遠い・とお　近い・ちか　</li>
<li>楽しい・たの　つまらない　おもしろい</li>
<li>美味しい　不味い・まずい</li>
<li>辛い・からい　苦い・にがい　甘い・あまい　塩辛い・しお　酸っぱい・すっ</li>
</ul>
<ul>
<li>好き・すき　嫌い・きらい　</li>
<li>便利・べん　不便・ふべん　</li>
<li>元気・げんき</li>
<li>にぎやか　静か　</li>
<li>きれい　汚い・きたない</li>
<li>親切・しんせつ　暇・ひま　</li>
</ul>

        
      
    </div>

    
    
    
      <footer class="post-footer">
          <div class="post-eof"></div>
        
      </footer>
  </div>
  
  
  
  </article>

    
        <article itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block home">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2018/12/12/日本語/标准日本语笔记/5‐8.森さんは七時に起きますmd/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="xiang">
      <meta itemprop="description" content="谨守而勿失，是谓反其真">
      <meta itemprop="image" content="/images/1.jpg">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="lxt">
    </span>
      <header class="post-header">
        <h1 class="post-title" itemprop="name headline">
            
            <a href="/2018/12/12/日本語/标准日本语笔记/5‐8.森さんは七時に起きますmd/" class="post-title-link" itemprop="url">新标日5-8课</a>
          
        </h1>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              
                
              

              <time title="创建时间：2018-12-12 11:26:26" itemprop="dateCreated datePublished" datetime="2018-12-12T11:26:26+08:00">2018-12-12</time>
            </span>
          
            

            
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="fa fa-calendar-check-o"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2019-09-19 20:20:41" itemprop="dateModified" datetime="2019-09-19T20:20:41+08:00">2019-09-19</time>
              </span>
            
          
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing"><a href="/categories/日本語/" itemprop="url" rel="index"><span itemprop="name">日本語</span></a></span>

                
                
                  ，
                
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing"><a href="/categories/日本語/标准日本语笔记/" itemprop="url" rel="index"><span itemprop="name">标准日本语笔记</span></a></span>

                
                
              
            </span>
          

          
          <br>
            <span class="post-meta-item" title="本文字数">
              <span class="post-meta-item-icon">
                <i class="fa fa-file-word-o"></i>
              </span>
              
                <span class="post-meta-item-text">本文字数：</span>
              
              <span>1.3k</span>
            </span>
          
            <span class="post-meta-item" title="阅读时长">
              <span class="post-meta-item-icon">
                <i class="fa fa-clock-o"></i>
              </span>
              
                <span class="post-meta-item-text">阅读时长 &asymp;</span>
              
              <span>1 分钟</span>
            </span>
          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h2 id="森さんは-七時に-おきます"><a href="#森さんは-七時に-おきます" class="headerlink" title="森さんは　七時に　おきます"></a>森さんは　七時に　おきます</h2><p><strong>动词+时间　に・から・まで</strong></p>
<p>毎日、何時寝ますか。</p>
<p>昨日、何時から　何時まで　働きますか。</p>
<p>試験は　いつ　始まりますか。</p>
<p>試験は　何時　はじまりますか。</p>
<h3 id="遅刻・こく"><a href="#遅刻・こく" class="headerlink" title="遅刻・こく"></a>遅刻・こく</h3><h2 id="吉田さんは-来月中国へ-行きます"><a href="#吉田さんは-来月中国へ-行きます" class="headerlink" title="吉田さんは　来月中国へ　行きます　"></a>吉田さんは　来月中国へ　行きます　</h2><p>李さんは　友達と　来月　北京から　新幹線で　来ました。</p>
<p>いつ　アメリカへ　行きますか。</p>
<p>​    ‐　十月に　行きます。</p>
<h3 id="交通機関-つう・通"><a href="#交通機関-つう・通" class="headerlink" title="交通機関　つう・通"></a>交通機関　つう・通</h3><ul>
<li>何で　帰りましたか？</li>
<li>電車です。　渋谷まで　電車で　行きました。駅から　アパートまで　歩いて　帰りました。</li>
<li>小野さん？</li>
<li>私は　電車です。駅からは　タクシーで　家へ帰りました。</li>
</ul>
<h2 id="李さんは-毎日-コーヒーを-飲みます"><a href="#李さんは-毎日-コーヒーを-飲みます" class="headerlink" title="李さんは　毎日　コーヒーを　飲みます"></a>李さんは　毎日　コーヒーを　飲みます</h2><p>李さん、今朝　うちで　新聞を　読みましたか？　</p>
<ul>
<li>いいえ、読みませんでした。</li>
</ul>
<p>今朝、何を　食べましたか？</p>
<ul>
<li>何も　食べませんでした。</li>
</ul>
<h3 id="昼ご飯"><a href="#昼ご飯" class="headerlink" title="昼ご飯"></a>昼ご飯</h3><ul>
<li><p>いつも　コンビニですか。</p>
<ul>
<li>いいえ。いつもは　蕎麦屋で　そばかうどんを　食べます。</li>
</ul>
</li>
<li><p>じゃあ、課長、失礼します。－しつれい　</p>
<ul>
<li>いってらっしゃい</li>
</ul>
</li>
<li><p>いらっしゃいませ</p>
<ul>
<li>かしこまりました。</li>
</ul>
</li>
</ul>
<h2 id="李さんは-日本語で-手紙を-書きます"><a href="#李さんは-日本語で-手紙を-書きます" class="headerlink" title="李さんは　日本語で　手紙を　書きます"></a>李さんは　日本語で　手紙を　書きます</h2><p><strong>动词+补语和第三方</strong></p>
<p>私は　小野さんに　お土産を　あげます。</p>
<p>私は　小野さんに　辞書を　もらいました。</p>
<p>その映画を　誰に　あげますか？</p>
<p>その映画を　誰に　もらいますか？</p>
<p>何で　送りましたか？　送り・おく</p>
<ul>
<li>航空便で　送りました。　航空便・こうくうびん</li>
</ul>
<h3 id="スケジュール表・ひょう"><a href="#スケジュール表・ひょう" class="headerlink" title="スケジュール表・ひょう"></a>スケジュール表・ひょう</h3><p>さっき、長島さんに　電話を　もらいました。</p>
<p>ファックスを　届きましたか？</p>
<h2 id="单词"><a href="#单词" class="headerlink" title="单词"></a>单词</h2><h3 id="時間"><a href="#時間" class="headerlink" title="時間"></a>時間</h3><div class="table-container">
<table>
<thead>
<tr>
<th style="text-align:center">あととい</th>
<th style="text-align:center">昨日</th>
<th style="text-align:center">今日</th>
<th style="text-align:center">明日</th>
<th style="text-align:center">明後日・あさって</th>
<th style="text-align:center">毎日</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:center"></td>
<td style="text-align:center"></td>
<td style="text-align:center">今朝</td>
<td style="text-align:center"></td>
<td style="text-align:center"></td>
<td style="text-align:center">毎朝</td>
</tr>
<tr>
<td style="text-align:center"></td>
<td style="text-align:center">昨夜・ゆうべ</td>
<td style="text-align:center">今晩・こんばん</td>
<td style="text-align:center"></td>
<td style="text-align:center"></td>
<td style="text-align:center">毎晩</td>
</tr>
<tr>
<td style="text-align:center">先々週・せん</td>
<td style="text-align:center"></td>
<td style="text-align:center">今週・こん</td>
<td style="text-align:center"></td>
<td style="text-align:center">再来週・さらい</td>
<td style="text-align:center">毎週</td>
</tr>
<tr>
<td style="text-align:center">先々月</td>
<td style="text-align:center"></td>
<td style="text-align:center">今月・こんげつ</td>
<td style="text-align:center"></td>
<td style="text-align:center">再来月</td>
<td style="text-align:center">毎月・つき</td>
</tr>
<tr>
<td style="text-align:center">あととし</td>
<td style="text-align:center">近年・きん</td>
<td style="text-align:center">今年・ことし</td>
<td style="text-align:center"></td>
<td style="text-align:center">再来年・ねん</td>
<td style="text-align:center">毎年・とし</td>
</tr>
</tbody>
</table>
</div>
<div class="table-container">
<table>
<thead>
<tr>
<th>1日・ついたち</th>
<th>2日・ふつか</th>
<th>3日・みっか</th>
<th>4日・よっか</th>
<th>5日・いつか</th>
<th>6日・むいか</th>
</tr>
</thead>
<tbody>
<tr>
<td>7日・なのか</td>
<td>8日・ようか</td>
<td>9日・ここのか</td>
<td>10日・とおか</td>
<td>じゅういちにち</td>
<td>㏫</td>
</tr>
<tr>
<td>㏬</td>
<td>14・じゅうよっか</td>
<td></td>
<td></td>
<td></td>
<td></td>
</tr>
<tr>
<td></td>
<td>20日・はつか</td>
<td></td>
<td></td>
<td></td>
<td>24日・にじゅうよっか</td>
</tr>
<tr>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
</tr>
</tbody>
</table>
</div>
<div class="table-container">
<table>
<thead>
<tr>
<th>一月・がつ</th>
<th>二月</th>
<th>三月</th>
<th>四月</th>
</tr>
</thead>
<tbody>
<tr>
<td>五月</td>
<td>六月</td>
<td>七月・しち</td>
<td>八月</td>
</tr>
<tr>
<td>九月</td>
<td>十月</td>
<td>十一月</td>
<td>十二月</td>
</tr>
</tbody>
</table>
</div>
<h3 id="片假名"><a href="#片假名" class="headerlink" title="片假名"></a>片假名</h3><ul>
<li>パーティー　</li>
<li>コンサート</li>
<li>クリスマス　</li>
<li>バス　</li>
<li>フェリー　</li>
<li>アパート　</li>
<li>プール　</li>
<li>北京・ぺきん　</li>
<li>コーヒー・コーラ</li>
<li>パン・ケーキ</li>
<li>カリー　</li>
<li>チーズ　</li>
<li>リンゴ　</li>
<li>イチゴ　</li>
<li>デニス</li>
<li>ジョギング</li>
<li>サッカー</li>
<li>パンダ</li>
<li>プレゼント　</li>
<li>チケット　</li>
<li>パンフレット</li>
<li>ファックス</li>
<li>バールペン</li>
<li>チョコレート　</li>
<li>アイスクリーム　</li>
<li>スプーン</li>
</ul>
<h3 id="生词"><a href="#生词" class="headerlink" title="生词"></a>生词</h3><ul>
<li>学校・がっこう　</li>
<li>仕事・しごと　</li>
<li><strong>出張　しゅっちょう</strong>　</li>
<li>子供の日　ひ</li>
<li>まっすぐ　</li>
<li>北海道・ほっかいどう　</li>
<li>渋谷・しぶや　</li>
<li>箱根・はこね　</li>
<li>新宿・しんじゅく</li>
<li>申込書・もうしこみ　</li>
<li>お金・がね　</li>
<li>住所・じゅうしょ　</li>
<li>小麦粉・こむぎこ　</li>
<li><strong>速達・そくたつ</strong></li>
</ul>
<ul>
<li>お疲れ様でした・つか・さま</li>
<li>大変ですね　</li>
</ul>
<h3 id="动词"><a href="#动词" class="headerlink" title="动词"></a>动词</h3><ul>
<li>送り・おく　出し・だ　メールを　出します・だし</li>
<li>届き・とど</li>
<li>作り・つく　資料を　作ります</li>
<li><strong>太り・ふと</strong>　</li>
<li>貸します・か　</li>
<li>習い・ならい　　</li>
<li>あげ　窓を　開けます・あけ　ー　閉めます・しめ　　</li>
<li><strong>教え・おし</strong></li>
<li>始まり・はじまり　－　終わり・おわり　</li>
<li>顔を　洗います・かお　あらい　</li>
<li>服を　着ます・き　　</li>
<li>煙草を　吸います・すい　</li>
<li>切手を　<strong>貼ります・はり</strong>　</li>
<li>降り</li>
</ul>
<ul>
<li><strong>歯を　磨きます・は　みがき</strong>　</li>
<li>お茶を　<strong>入れます・いれ</strong>　</li>
<li>靴を　はきます　－　脱ぎます・ぬぎ　</li>
<li><strong>お金を　払います・はらい</strong>　</li>
<li>電気を　つけます　ー　消します・け</li>
</ul>

        
      
    </div>

    
    
    
      <footer class="post-footer">
          <div class="post-eof"></div>
        
      </footer>
  </div>
  
  
  
  </article>

    
        <article itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block home">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2018/12/11/日本語/标准日本语笔记/1~4李さんは中国人です/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="xiang">
      <meta itemprop="description" content="谨守而勿失，是谓反其真">
      <meta itemprop="image" content="/images/1.jpg">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="lxt">
    </span>
      <header class="post-header">
        <h1 class="post-title" itemprop="name headline">
            
            <a href="/2018/12/11/日本語/标准日本语笔记/1~4李さんは中国人です/" class="post-title-link" itemprop="url">新标日1-4课</a>
          
        </h1>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              
                
              

              <time title="创建时间：2018-12-11 11:26:26" itemprop="dateCreated datePublished" datetime="2018-12-11T11:26:26+08:00">2018-12-11</time>
            </span>
          
            

            
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="fa fa-calendar-check-o"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2019-09-19 20:39:43" itemprop="dateModified" datetime="2019-09-19T20:39:43+08:00">2019-09-19</time>
              </span>
            
          
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing"><a href="/categories/日本語/" itemprop="url" rel="index"><span itemprop="name">日本語</span></a></span>

                
                
                  ，
                
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing"><a href="/categories/日本語/标准日本语笔记/" itemprop="url" rel="index"><span itemprop="name">标准日本语笔记</span></a></span>

                
                
              
            </span>
          

          
          <br>
            <span class="post-meta-item" title="本文字数">
              <span class="post-meta-item-icon">
                <i class="fa fa-file-word-o"></i>
              </span>
              
                <span class="post-meta-item-text">本文字数：</span>
              
              <span>5.5k</span>
            </span>
          
            <span class="post-meta-item" title="阅读时长">
              <span class="post-meta-item-icon">
                <i class="fa fa-clock-o"></i>
              </span>
              
                <span class="post-meta-item-text">阅读时长 &asymp;</span>
              
              <span>5 分钟</span>
            </span>
          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h2 id="李さんは-中国人です"><a href="#李さんは-中国人です" class="headerlink" title="李さんは　中国人です"></a>李さんは　中国人です</h2><h3 id="出迎え"><a href="#出迎え" class="headerlink" title="出迎え"></a>出迎え</h3>
        <div id="aplayer-LpMsyofW" class="aplayer aplayer-tag-marker" style="margin-bottom: 20px;">
            <pre class="aplayer-lrc-content"></pre>
        </div>
        <script>
          var ap = new APlayer({
            element: document.getElementById("aplayer-LpMsyofW"),
            narrow: false,
            autoplay: false,
            showlrc: false,
            music: {
              title: "新标日",
              author: "第1课 课文",
              url: "第一课 课文.mp3",
              pic: "/2018/12/11/日本語/标准日本语笔记/1~4李さんは中国人です/あゆみ.jpg",
              lrc: ""
            }
          });
          window.aplayers || (window.aplayers = []);
          window.aplayers.push(ap);
        </script>
<h2 id="これは-本です"><a href="#これは-本です" class="headerlink" title="これは　本です"></a>これは　本です</h2><p><strong>疑问指示代词</strong></p>
<ul>
<li>誰（だれ）ー　そのノートは　だれの　ですか。</li>
<li>何（なに）ー　それは　何ですか。</li>
<li>どれ（which）ー 森さんのかばんは　どれ　ですか。</li>
<li>どの（which）ー 小野さんの机は　どの机　ですか。</li>
<li>どなた（人）－　この方は　どなた　ですか。　　</li>
</ul>
<h3 id="家族の写真"><a href="#家族の写真" class="headerlink" title="家族の写真"></a>家族の写真</h3>
        <div id="aplayer-exyMmFio" class="aplayer aplayer-tag-marker" style="margin-bottom: 20px;">
            <pre class="aplayer-lrc-content"></pre>
        </div>
        <script>
          var ap = new APlayer({
            element: document.getElementById("aplayer-exyMmFio"),
            narrow: false,
            autoplay: false,
            showlrc: false,
            music: {
              title: "新标日",
              author: "第2课 课文",
              url: "第二课 课文.mp3",
              pic: "/2018/12/11/日本語/标准日本语笔记/1~4李さんは中国人です/あゆみ.jpg",
              lrc: ""
            }
          });
          window.aplayers || (window.aplayers = []);
          window.aplayers.push(ap);
        </script>
<h2 id="ここは-デパートです"><a href="#ここは-デパートです" class="headerlink" title="ここは　デパートです"></a>ここは　デパートです</h2><p><strong>疑问指示代词</strong>   </p>
<ul>
<li>どちら　－　お国は　どちらですか。</li>
<li>どこ　　－　会社は　どこですか。</li>
</ul>
<h3 id="ホテルの周辺"><a href="#ホテルの周辺" class="headerlink" title="ホテルの周辺"></a>ホテルの周辺</h3>
        <div id="aplayer-CjgLYPqF" class="aplayer aplayer-tag-marker" style="margin-bottom: 20px;">
            <pre class="aplayer-lrc-content"></pre>
        </div>
        <script>
          var ap = new APlayer({
            element: document.getElementById("aplayer-CjgLYPqF"),
            narrow: false,
            autoplay: false,
            showlrc: false,
            music: {
              title: "新标日",
              author: "第3课 课文",
              url: "第三课 课文.mp3",
              pic: "/2018/12/11/日本語/标准日本语笔记/1~4李さんは中国人です/あゆみ.jpg",
              lrc: ""
            }
          });
          window.aplayers || (window.aplayers = []);
          window.aplayers.push(ap);
        </script>
<h2 id="部屋に-机といすが-あります"><a href="#部屋に-机といすが-あります" class="headerlink" title="部屋に　机といすが　あります"></a>部屋に　机といすが　あります</h2><p>方位代词 </p>
<ul>
<li>上　うえ　－　下　した</li>
<li>前　まえ　－　後　うしろ　</li>
<li>中　なか　－　外　そと　</li>
<li>隣　となり　‐　近　ちかく</li>
</ul>
<p>机の上に　猫が　あります。</p>
<p>売店は　駅の外に　あります。</p>
<p>その箱の中に　何が　ありますか。</p>
<p>部屋に　誰が　いますか。</p>
<p>小野さんの家は　どこに　ありますか。</p>
<h3 id="会社の場所"><a href="#会社の場所" class="headerlink" title="会社の場所"></a>会社の場所</h3>
        <div id="aplayer-ydFflUxU" class="aplayer aplayer-tag-marker" style="margin-bottom: 20px;">
            <pre class="aplayer-lrc-content"></pre>
        </div>
        <script>
          var ap = new APlayer({
            element: document.getElementById("aplayer-ydFflUxU"),
            narrow: false,
            autoplay: false,
            showlrc: false,
            music: {
              title: "新标日",
              author: "第4课 课文",
              url: "第四课 课文.mp3",
              pic: "/2018/12/11/日本語/标准日本语笔记/1~4李さんは中国人です/あゆみ.jpg",
              lrc: ""
            }
          });
          window.aplayers || (window.aplayers = []);
          window.aplayers.push(ap);
        </script>
<ul>
<li><p>小野さん、会社は　どこに　ありますか。</p>
<ul>
<li>ここです。</li>
</ul>
</li>
<li><p>近くに　駅が　ありますか。</p>
<ul>
<li>Jℝと地下鉄の駅が　あります。Jℝの駅は　ここです。</li>
</ul>
</li>
<li><p>地下鉄の　駅が　ここですか。</p>
<ul>
<li>ええ、そうです。Jℝの駅の隣に　地下鉄の駅が　あります。</li>
</ul>
</li>
</ul>
<h2 id="单词"><a href="#单词" class="headerlink" title="单词"></a>单词</h2>
        <div id="aplayer-liLQNYGw" class="aplayer aplayer-tag-marker" style="margin-bottom: 20px;">
            <pre class="aplayer-lrc-content"></pre>
        </div>
        <script>
          var ap = new APlayer({
            element: document.getElementById("aplayer-liLQNYGw"),
            narrow: false,
            autoplay: false,
            showlrc: false,
            music: {
              title: "新标日",
              author: "第1课 单词",
              url: "第一课 单词.mp3",
              pic: "/2018/12/11/日本語/标准日本语笔记/1~4李さんは中国人です/毛利.jpg",
              lrc: ""
            }
          });
          window.aplayers || (window.aplayers = []);
          window.aplayers.push(ap);
        </script>

        <div id="aplayer-mjcTmRRd" class="aplayer aplayer-tag-marker" style="margin-bottom: 20px;">
            <pre class="aplayer-lrc-content"></pre>
        </div>
        <script>
          var ap = new APlayer({
            element: document.getElementById("aplayer-mjcTmRRd"),
            narrow: false,
            autoplay: false,
            showlrc: false,
            music: {
              title: "新标日",
              author: "第2课 单词",
              url: "第二课 单词.mp3",
              pic: "/2018/12/11/日本語/标准日本语笔记/1~4李さんは中国人です/毛利.jpg",
              lrc: ""
            }
          });
          window.aplayers || (window.aplayers = []);
          window.aplayers.push(ap);
        </script>

        <div id="aplayer-FKNSvKcY" class="aplayer aplayer-tag-marker" style="margin-bottom: 20px;">
            <pre class="aplayer-lrc-content"></pre>
        </div>
        <script>
          var ap = new APlayer({
            element: document.getElementById("aplayer-FKNSvKcY"),
            narrow: false,
            autoplay: false,
            showlrc: false,
            music: {
              title: "新标日",
              author: "第3课 单词",
              url: "第三课 单词.mp3",
              pic: "/2018/12/11/日本語/标准日本语笔记/1~4李さんは中国人です/毛利.jpg",
              lrc: ""
            }
          });
          window.aplayers || (window.aplayers = []);
          window.aplayers.push(ap);
        </script>

        <div id="aplayer-TuNUJAwZ" class="aplayer aplayer-tag-marker" style="margin-bottom: 20px;">
            <pre class="aplayer-lrc-content"></pre>
        </div>
        <script>
          var ap = new APlayer({
            element: document.getElementById("aplayer-TuNUJAwZ"),
            narrow: false,
            autoplay: false,
            showlrc: false,
            music: {
              title: "新标日",
              author: "第4课 单词",
              url: "第四课 单词.mp3",
              pic: "/2018/12/11/日本語/标准日本语笔记/1~4李さんは中国人です/毛利.jpg",
              lrc: ""
            }
          });
          window.aplayers || (window.aplayers = []);
          window.aplayers.push(ap);
        </script>
<h3 id="地理"><a href="#地理" class="headerlink" title="地理"></a>地理</h3><ul>
<li>アメリカ・AME <strong>RI</strong>KA</li>
<li>フランス・FU RAN <strong>SU</strong></li>
<li>イギリス・IGI RI<strong>SU</strong>　英国</li>
<li>イタリア・<strong>ITA RIA</strong>　大利　</li>
<li>インド・IN DO　　</li>
<li>オーストラリア・OSUTO RARIA</li>
<li>スパイン・SU PA IN</li>
<li>ドイツ・DO I TSU　</li>
<li>ロシア・ROSIA</li>
<li>アジア・AJIA　ヨーロッパ・YUROPA　アフリカ</li>
<li>北アメリカ大陸・<strong>きた</strong>・だいりく</li>
<li>南アメリカ大陸・<strong>みなみ</strong>　</li>
</ul>
<h3 id="建筑物"><a href="#建筑物" class="headerlink" title="建筑物"></a><strong>建筑物</strong></h3><ul>
<li>美<strong>術</strong>館(び　じゅつ)　</li>
<li>体育館(たい　いく)　</li>
</ul>
<ul>
<li><p><strong>博</strong>物館(はく　ぶつ)　</p>
</li>
<li><p>動<strong>物</strong>園(どう　ぶつ)　</p>
</li>
<li>遊園地(ゆう　えん　ち)　</li>
</ul>
<ul>
<li>市<strong>役</strong>所(し　やく)　</li>
<li>警<strong>察</strong>署(けい　さつ　しょ)　</li>
<li>消防<strong>署</strong>(しょう　ぼう　しょ)</li>
</ul>
<ul>
<li>薬局(やっ　きょく)　</li>
<li><strong>工場</strong>(こう　じょう)　</li>
<li><strong>劇</strong>場(げき)　</li>
<li>駐車場(ちゅう)</li>
</ul>
<ul>
<li>床屋(とこ)</li>
<li>肉屋(にく)</li>
<li>魚屋(さかな)</li>
<li>八百屋(や　お　や)　</li>
<li>お店(みせ)</li>
</ul>
<ul>
<li>空港(くう　こう)　</li>
<li>学校(がっ　こう)</li>
</ul>
<h3 id="数字"><a href="#数字" class="headerlink" title="数字"></a>数字</h3><ul>
<li>零　れい　－　令和　れいわ　</li>
<li>四　よん・し　</li>
<li>七　しち・なな　</li>
<li>九　く・きゅう　</li>
<li>0.3　れいてんさん　</li>
<li>1/３　さんぶんいち　</li>
<li>100　ひゃく</li>
<li>300　さんびゃく　</li>
<li>600　ろっぴゃく　</li>
<li>700　ななひゃく　</li>
<li>800　はっぴゃく　</li>
</ul>
<h3 id="ご両親"><a href="#ご両親" class="headerlink" title="ご両親"></a>ご両親</h3><ul>
<li>そふ　お爺さん・じい　そば　おばあさん</li>
<li>ちち　お父さん　はは　お母さん　</li>
<li>息子・むすこ　娘・むすめ　お嬢さん・じょう</li>
<li>ご兄弟・きょうだい　</li>
<li>あに　お兄さん・にい　あね　お姉さん・ねえ</li>
<li>おじさん・叔父　おばさん・叔母</li>
</ul>
<h3 id="字母"><a href="#字母" class="headerlink" title="字母"></a>字母</h3><div class="table-container">
<table>
<thead>
<tr>
<th>エー</th>
<th>ビー</th>
<th>シー</th>
<th>ディー</th>
<th>イー</th>
<th>エフ</th>
<th>ジー</th>
</tr>
</thead>
<tbody>
<tr>
<td>エイチ</td>
<td>アイ</td>
<td>ジェー</td>
<td>ケー</td>
<td>エル</td>
<td>エム</td>
<td></td>
</tr>
<tr>
<td>オー</td>
<td>ピー</td>
<td>キュー</td>
<td></td>
<td>アール</td>
<td>エス</td>
<td>ティー</td>
</tr>
<tr>
<td>ユー</td>
<td>ブイ</td>
<td>ダブリュー</td>
<td></td>
<td>エックス</td>
<td>ウイ</td>
<td>ゼット</td>
</tr>
</tbody>
</table>
</div>
<h3 id="片假名"><a href="#片假名" class="headerlink" title="片假名"></a>片假名</h3><ul>
<li>カメラ　　デジカメ写真　ビデオ</li>
<li>テレビ　</li>
<li>パソコン　</li>
<li>ラジオ　</li>
<li>シルク　</li>
<li>ハンカチ　</li>
<li>デパート</li>
<li>マンション・ホテル　</li>
<li>コンビニ</li>
<li>レストラン　</li>
<li>トイレ</li>
<li>バーゲン会場　じょう</li>
<li>エスカレーター　</li>
<li>コート</li>
<li>スイッチ　</li>
<li>ベッド　</li>
<li>サッカーボール</li>
<li>ビール　</li>
<li>ウイスキー　</li>
</ul>
<h3 id="生词"><a href="#生词" class="headerlink" title="生词"></a>生词</h3><ul>
<li>お土産・おみやげ　</li>
<li>本棚・だな　</li>
<li>壁・かべ　</li>
<li>眼鏡・めがね　</li>
<li>子供・ども　</li>
<li>妹・いもうと　</li>
<li>女・おんな　男・おとこ</li>
</ul>

        
      
    </div>

    
    
    
      <footer class="post-footer">
          <div class="post-eof"></div>
        
      </footer>
  </div>
  
  
  
  </article>

    
        <article itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block home">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2017/09/06/android/View/字体增强/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="xiang">
      <meta itemprop="description" content="谨守而勿失，是谓反其真">
      <meta itemprop="image" content="/images/1.jpg">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="lxt">
    </span>
      <header class="post-header">
        <h1 class="post-title" itemprop="name headline">
            
            <a href="/2017/09/06/android/View/字体增强/" class="post-title-link" itemprop="url">字体增强</a>
          
        </h1>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              
                
              

              <time title="创建时间：2017-09-06 21:26:26" itemprop="dateCreated datePublished" datetime="2017-09-06T21:26:26+08:00">2017-09-06</time>
            </span>
          
            

            
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="fa fa-calendar-check-o"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2019-09-18 15:41:27" itemprop="dateModified" datetime="2019-09-18T15:41:27+08:00">2019-09-18</time>
              </span>
            
          
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing"><a href="/categories/android/" itemprop="url" rel="index"><span itemprop="name">android</span></a></span>

                
                
                  ，
                
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing"><a href="/categories/android/View/" itemprop="url" rel="index"><span itemprop="name">View</span></a></span>

                
                
              
            </span>
          

          
          <br>
            <span class="post-meta-item" title="本文字数">
              <span class="post-meta-item-icon">
                <i class="fa fa-file-word-o"></i>
              </span>
              
                <span class="post-meta-item-text">本文字数：</span>
              
              <span>10k</span>
            </span>
          
            <span class="post-meta-item" title="阅读时长">
              <span class="post-meta-item-icon">
                <i class="fa fa-clock-o"></i>
              </span>
              
                <span class="post-meta-item-text">阅读时长 &asymp;</span>
              
              <span>9 分钟</span>
            </span>
          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <p>android 中使用字体是非常不方便的，因为不支持 xml 定义，必须使用代码来动态修改字体，也无法用样式或主题来批量修改字体。</p>
<p>现在我们来探索下面两个字体使用增强库的原理。</p>
<h2 id="android-typeface-helper"><a href="#android-typeface-helper" class="headerlink" title="android-typeface-helper"></a><a href="https://github.com/norbsoft/android-typeface-helper" target="_blank" rel="noopener">android-typeface-helper</a></h2><p>android-typeface-helper 是较为简单，使用方法如下</p>
<p>1.首先在 Application 中初始化，主要是创建和缓存字体</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Override</span> <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onCreate</span><span class="params">()</span> </span>&#123;</span><br><span class="line">	<span class="keyword">super</span>.onCreate();</span><br><span class="line">	<span class="comment">// Initialize typeface helper</span></span><br><span class="line">	TypefaceCollection typeface = <span class="keyword">new</span> TypefaceCollection.Builder()</span><br><span class="line">	        .set(Typeface.NORMAL, Typeface.createFromAsset(getAssets(), <span class="string">"fonts/ubuntu/Ubuntu-R.ttf"</span>))</span><br><span class="line">	        .create();</span><br><span class="line">	TypefaceHelper.init(typeface);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>2.对 Activity , ViewGroup 或 View 应用字体。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Override</span> <span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">onCreate</span><span class="params">(Bundle savedInstanceState)</span> </span>&#123;</span><br><span class="line">	<span class="keyword">super</span>.onCreate(savedInstanceState);</span><br><span class="line">	setContentView(R.layout.activity_layout);</span><br><span class="line">	TypefaceHelper.typeface(<span class="keyword">this</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>也可以动态的改变字体。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">typeface</span><span class="params">(View view)</span></span>;</span><br></pre></td></tr></table></figure>
<p>这个库是实际没有做太多事，仅仅对常规字体使用方法的包装而已。typeface 方法如下</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">applyForView</span><span class="params">(View view, TypefaceCollection typefaceCollection)</span> </span>&#123;</span><br><span class="line">   <span class="keyword">if</span> (view <span class="keyword">instanceof</span> TextView) &#123;</span><br><span class="line">      TextView textView = (TextView) view;</span><br><span class="line">      Typeface oldTypeface = textView.getTypeface();</span><br><span class="line">      <span class="keyword">final</span> <span class="keyword">int</span> style = oldTypeface == <span class="keyword">null</span> ? Typeface.NORMAL : oldTypeface.getStyle();</span><br><span class="line">      textView.setTypeface(typefaceCollection.getTypeface(style));</span><br><span class="line">      textView.setPaintFlags(textView.getPaintFlags() | Paint.SUBPIXEL_TEXT_FLAG);</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>可见字体的更改只应用在 TextView 控件上，对于 ViewGroup 要执行递归更改，对于 Acitivity 实际是对 content 布局执行递归更改。</p>
<p>值得一提的是你还可以创造某种字体的 SpannableString</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> SpannableString <span class="title">typeface</span><span class="params">(CharSequence sequence, TypefaceCollection typefaceCollection)</span></span>;</span><br></pre></td></tr></table></figure>
<p>这是通过定义字体 span 获得的效果，不过首先通过集合提供字体对象</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">TypefaceSpan</span> <span class="keyword">extends</span> <span class="title">MetricAffectingSpan</span> </span>&#123;</span><br><span class="line">   Typeface typeface;</span><br><span class="line">  </span><br><span class="line">   <span class="meta">@Override</span> <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">updateDrawState</span><span class="params">(TextPaint tp)</span> </span>&#123;</span><br><span class="line">      tp.setTypeface(typeface);</span><br><span class="line">      tp.setFlags(tp.getFlags() | Paint.SUBPIXEL_TEXT_FLAG);</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="Calligraphy"><a href="#Calligraphy" class="headerlink" title="Calligraphy"></a><a href="https://github.com/chrisjenx/Calligraphy" target="_blank" rel="noopener">Calligraphy</a></h2><p>使用 Calligraphy 这个库，你可以直接在 XML 文件中定义字体</p>
<figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">TextView</span> <span class="attr">fontPath</span>=<span class="string">"fonts/MyFont.ttf"</span>/&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">style</span> <span class="attr">name</span>=<span class="string">"TextAppearance.FontPath"</span> <span class="attr">parent</span>=<span class="string">"android:TextAppearance"</span>&gt;</span></span><br><span class="line"><span class="xml">    <span class="tag">&lt;<span class="name">item</span> <span class="attr">name</span>=<span class="string">"fontPath"</span>&gt;</span>fonts/RobotoCondensed-Regular.ttf<span class="tag">&lt;/<span class="name">item</span>&gt;</span></span></span><br><span class="line"><span class="tag">&lt;/<span class="name">style</span>&gt;</span></span><br></pre></td></tr></table></figure>
<p><strong>自定义控件时添加一个属性并不稀奇，稀奇的是给系统控件 TextView 添加了一个属性 fontPath，而且生效了。</strong></p>
<p>要做到这点，首先要在 Application 中进行设置。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onCreate</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">super</span>.onCreate();</span><br><span class="line">    CalligraphyConfig.initDefault(<span class="keyword">new</span> CalligraphyConfig.Builder()</span><br><span class="line">                            .setDefaultFontPath(<span class="string">"fonts/Roboto-RobotoRegular.ttf"</span>)</span><br><span class="line">                            .setFontAttrId(R.attr.fontPath)</span><br><span class="line">                            .build()</span><br><span class="line">            );</span><br></pre></td></tr></table></figure>
<p>此外还需要在 Activity 中替换 Context</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">attachBaseContext</span><span class="params">(Context newBase)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">super</span>.attachBaseContext(CalligraphyContextWrapper.wrap(newBase));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>当然该库也提供了 CalligraphyTypefaceSpan 供使用，不再叙述。</p>
<h3 id="LayoutInflater的原理解析"><a href="#LayoutInflater的原理解析" class="headerlink" title="LayoutInflater的原理解析"></a>LayoutInflater的原理解析</h3><p>android 是怎样解析属性的呢？核心是更改 LayoutInflater，该类的加载过程如下</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> View <span class="title">inflate</span><span class="params">(@LayoutRes <span class="keyword">int</span> resource, ViewGroup root, <span class="keyword">boolean</span> attachToRoot)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">final</span> Resources res = getContext().getResources();</span><br><span class="line">    <span class="keyword">final</span> XmlResourceParser parser = res.getLayout(resource); </span><br><span class="line">    AttributeSet attrs = Xml.asAttributeSet(parser);</span><br><span class="line">  </span><br><span class="line">    View result = root;</span><br><span class="line">    View temp = createViewFromTag(root, name, inflaterContext, attrs);</span><br><span class="line">    ViewGroup.LayoutParams params = root.generateLayoutParams(attrs);</span><br><span class="line">    <span class="keyword">if</span> (!attachToRoot) &#123;</span><br><span class="line">      temp.setLayoutParams(params);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">if</span> (root != <span class="keyword">null</span> &amp;&amp; attachToRoot) &#123;</span><br><span class="line">        root.addView(temp, params);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (root == <span class="keyword">null</span> || !attachToRoot) &#123;</span><br><span class="line">        result = temp;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> result;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这个过程实际是从布局文件中解析出 View 对象，再讲其添加到容器上去的过程。过程中有以下几点值得注意</p>
<p>1.attachToRoot 参数决定了是要要将View添加到容器上，以及返回值是容器自身还是View对象。</p>
<p>2.根据XML解析器生成View对象即 createViewFromTag 方法是一个移花接玉的过程。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">View <span class="title">createViewFromTag</span><span class="params">(View parent, String name, Context context, AttributeSet attrs)</span></span>&#123;</span><br><span class="line">  TypedArray ta = context.obtainStyledAttributes(attrs, ATTRS_THEME);</span><br><span class="line">  <span class="keyword">int</span> themeResId = ta.getResourceId(<span class="number">0</span>, <span class="number">0</span>);</span><br><span class="line">  context = <span class="keyword">new</span> ContextThemeWrapper(context, themeResId);</span><br><span class="line">  </span><br><span class="line">  View view;</span><br><span class="line">  <span class="keyword">if</span> (mFactory2 != <span class="keyword">null</span>) &#123;</span><br><span class="line">      view = mFactory2.onCreateView(parent, name, context, attrs);</span><br><span class="line">  &#125; <span class="keyword">else</span> <span class="keyword">if</span> (mFactory != <span class="keyword">null</span>) &#123;</span><br><span class="line">      view = mFactory.onCreateView(name, context, attrs);</span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      view = <span class="keyword">null</span>;</span><br><span class="line">  &#125;  </span><br><span class="line">  <span class="keyword">if</span> (view == <span class="keyword">null</span> &amp;&amp; mPrivateFactory != <span class="keyword">null</span>) &#123;</span><br><span class="line">      view = mPrivateFactory.onCreateView(parent, name, context, attrs);</span><br><span class="line">  &#125;  </span><br><span class="line">  </span><br><span class="line">  <span class="keyword">if</span> (view == <span class="keyword">null</span>) &#123;</span><br><span class="line">      <span class="keyword">final</span> Object lastContext = mConstructorArgs[<span class="number">0</span>];</span><br><span class="line">      mConstructorArgs[<span class="number">0</span>] = context;</span><br><span class="line">      <span class="keyword">if</span> (-<span class="number">1</span> == name.indexOf(<span class="string">'.'</span>)) &#123;</span><br><span class="line">          view = onCreateView(parent, name, attrs); <span class="comment">//使用反射创建</span></span><br><span class="line">      &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">          view = createView(name, <span class="keyword">null</span>, attrs);     <span class="comment">//使用反射创建</span></span><br><span class="line">      &#125;</span><br><span class="line">   &#125;</span><br><span class="line">   <span class="keyword">return</span> view;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这里创建View的处理顺序是 Factory2，Factory1，PrivateFactory，最后才是使用反射来创建。</p>
<p>我们知道通过 Factory2 可以改变View的创建过程，实际上 Activity 就是这样做的，在执行 <code>super.onCreate(savedInstanceState);</code>这一句时就设置了 PrivateFactory。</p>
<h3 id="简单实现"><a href="#简单实现" class="headerlink" title="简单实现"></a>简单实现</h3><p>我们通过自定义一个 LayoutInflater 来实现简单的效果，首先定义一个属性</p>
<figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">attr</span> <span class="attr">name</span>=<span class="string">"customFont"</span> <span class="attr">format</span>=<span class="string">"string"</span>/&gt;</span></span><br></pre></td></tr></table></figure>
<p>在xml中使用</p>
<figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">TextView</span> <span class="attr">customFont</span>=<span class="string">"fonts/Rotobo-Bold.ttf"</span>/&gt;</span></span><br></pre></td></tr></table></figure>
<p>这时该属性已经能够被 LayoutInflater 解析到 AttributeSet 参数中去。我们可以使用 Factory2 接口来观察这一现象</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//Factory2 只能设置一次，所以先用反射修改 mFactorySet 的值，以解除此限制</span></span><br><span class="line">LayoutInflater inflater = LayoutInflater.from(<span class="keyword">this</span>);</span><br><span class="line">Class cls = LayoutInflater.class;</span><br><span class="line">Field bool = cls.getDeclaredField(<span class="string">"mFactorySet"</span>);</span><br><span class="line">bool.setAccessible(<span class="keyword">true</span>);</span><br><span class="line">bool.setBoolean(inflater, <span class="keyword">false</span>);</span><br><span class="line">inflater.setFactory2(<span class="keyword">new</span> LayoutInflater.Factory2() &#123;</span><br><span class="line">      </span><br><span class="line">   <span class="meta">@Override</span></span><br><span class="line">   <span class="function"><span class="keyword">public</span> View <span class="title">onCreateView</span><span class="params">(View parent, String name, Context context, AttributeSet attrs)</span> </span>&#123;</span><br><span class="line">       <span class="keyword">if</span>(name.equals(<span class="string">"TextView"</span>)) &#123;</span><br><span class="line">           <span class="keyword">int</span> count = attrs.getAttributeCount();</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; count; i++) &#123;</span><br><span class="line">                Log.i(TAG, attrs.getAttributeName(i)); <span class="comment">//customFont</span></span><br><span class="line">                Log.i(TAG, attrs.getAttributeValue(i));<span class="comment">//fonts/Rotobo-Bold.ttf</span></span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">      &#125;</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>
<p>从这里就可以拿到资源值(即字体文件路径)了，利用这一属性就可以设置字体了，简易实现如下</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> View <span class="title">onCreateView</span><span class="params">(View parent, String name, Context context, AttributeSet attrs)</span> </span>&#123;</span><br><span class="line">       <span class="keyword">if</span>(name.equals(<span class="string">"TextView"</span>)) &#123;</span><br><span class="line">             TextView textview = <span class="keyword">new</span> TextView(MainActivity.<span class="keyword">this</span>);</span><br><span class="line">             textview.setLayoutParams(<span class="keyword">new</span> ViewGroup.LayoutParams(<span class="number">400</span>, <span class="number">100</span>));</span><br><span class="line">             textview.setText(<span class="string">"中华大道 English hello 123456"</span>);</span><br><span class="line">             <span class="keyword">int</span> count = attrs.getAttributeCount();</span><br><span class="line">             <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; count; i++) &#123;</span><br><span class="line">                 <span class="keyword">if</span>(attrs.getAttributeName(i).equals(<span class="string">"customfont"</span>))&#123;</span><br><span class="line">                      String path = attrs.getAttributeValue(i);</span><br><span class="line">                      Typeface typeface = Typeface.createFromAsset(getAssets(), path);</span><br><span class="line">                      textview.setTypeface(typeface);</span><br><span class="line">                  &#125;</span><br><span class="line">              &#125;</span><br><span class="line">              <span class="keyword">return</span> textview;</span><br><span class="line">         &#125;</span><br><span class="line">     <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这个简单的实现已经能通过自定义属性来修改字体文件了，但离具体应用还差的比较远，比如它无法使用 style 和主题，也会屏蔽掉其它View的生成，此外还默认设置成默认应用在 Activity 上。</p>
<h3 id="在Activity中应用字体属性"><a href="#在Activity中应用字体属性" class="headerlink" title="在Activity中应用字体属性"></a>在Activity中应用字体属性</h3><p>在Activity中应用字体属性就是要修改其中的LayoutInflater类，通过调查我们可以发现该类已经实现了 Factory2 接口，只要通过代理的方式来改造该接口的实现使其能够处理字体属性就行了。</p>
<p>实际过程分为两步</p>
<p>1.替换 Factory2 接口</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> LayoutInflater <span class="title">getLayoutInflater</span><span class="params">()</span> </span>&#123;</span><br><span class="line">   LayoutInflater inflater = <span class="keyword">super</span>.getLayoutInflater();</span><br><span class="line">   <span class="keyword">final</span> LayoutInflater.Factory2 factory2 = inflater.getFactory2();</span><br><span class="line">    Class cls = LayoutInflater.class;</span><br><span class="line">    Field bool = cls.getDeclaredField(<span class="string">"mFactorySet"</span>);</span><br><span class="line">    bool.setAccessible(<span class="keyword">true</span>);</span><br><span class="line">    bool.setBoolean(inflater, <span class="keyword">false</span>);</span><br><span class="line">    inflater.setFactory2(<span class="keyword">new</span> WrapFacory2(factory2));</span><br><span class="line">    <span class="keyword">return</span> inflater;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><strong>注意一定要做如下设置,在活动创建时就替换 LayoutInflater 来</strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">onCreate</span><span class="params">(Bundle savedInstanceState)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">super</span>.onCreate(savedInstanceState);</span><br><span class="line">    getLayoutInflater(); <span class="comment">//改造已经存在的 LayoutInflater 对象</span></span><br><span class="line">    setContentView(R.layout.activity_main);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<blockquote>
<p>LayoutInflater 对象在 Window 中，必须要调用 getLayoutInflater 来改造它，才能在活动中生效。</p>
</blockquote>
<p>2.利用代理扩展Factory2的功能</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="class"><span class="keyword">class</span> <span class="title">WrapFactory2</span> <span class="keyword">implements</span> <span class="title">LayoutInflater</span>.<span class="title">Factory2</span> </span>&#123;</span><br><span class="line">    LayoutInflater.Factory2 factory2;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">WrapFactory2</span><span class="params">(LayoutInflater.Factory2 factory2)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.factory2 = factory2;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> View <span class="title">onCreateView</span><span class="params">(View parent, String name, Context context, AttributeSet attrs)</span> </span>&#123;</span><br><span class="line">        View view = factory2.onCreateView(parent, name, context, attrs);</span><br><span class="line">        <span class="keyword">if</span>(view <span class="keyword">instanceof</span> TextView)&#123; <span class="comment">//支持所有 TextView 的子类，如Button</span></span><br><span class="line">            <span class="keyword">int</span> count = attrs.getAttributeCount();</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; count; i++) &#123;</span><br><span class="line">                <span class="keyword">if</span>(attrs.getAttributeName(i).equals(<span class="string">"customfont"</span>))&#123;</span><br><span class="line">                    String path = attrs.getAttributeValue(i);</span><br><span class="line">                    Typeface typeface = Typeface.createFromAsset(getAssets(), path);</span><br><span class="line">                    ((TextView)view).setTypeface(typeface);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> view;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><strong>这样字体属性在这个 Activity 中就可以生效了，而且完全不干扰其它控件和其它属性。</strong></p>
<h3 id="在样式或主题中使用字体属性"><a href="#在样式或主题中使用字体属性" class="headerlink" title="在样式或主题中使用字体属性"></a>在样式或主题中使用字体属性</h3><p>首先定义一个样式</p>
<figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">style</span> <span class="attr">name</span>=<span class="string">"Text"</span> &gt;</span></span><br><span class="line"><span class="xml">    <span class="tag">&lt;<span class="name">item</span> <span class="attr">name</span>=<span class="string">"customFont"</span>&gt;</span>fonts/gtw.ttf<span class="tag">&lt;/<span class="name">item</span>&gt;</span></span></span><br><span class="line"><span class="tag">&lt;/<span class="name">style</span>&gt;</span></span><br></pre></td></tr></table></figure>
<p>此时应用样式的主要问题就是如何使用 AttributeSet 解析出其中的字体属性，方法如下</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span>(attrs.getAttributeName(i).equals(<span class="string">"style"</span>))&#123;</span><br><span class="line">    <span class="keyword">int</span> styleId = attrs.getStyleAttribute();</span><br><span class="line">   TypedArray ta = obtainStyledAttributes(styleId, <span class="keyword">new</span> <span class="keyword">int</span>[]&#123;R.attr.customFont&#125;);</span><br><span class="line">   String path = ta.getString(<span class="number">1</span>);</span><br><span class="line">   ta.recycle();</span><br><span class="line">   Typeface typeface = Typeface.createFromAsset(getAssets(), path);</span><br><span class="line">   ((TextView)view).setTypeface(typeface);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>如果在主题中定义了字体属性，因为 <strong>AttributeSet 中不会有未使用的属性出现，自然就解析不出字体属性了。</strong></p>
<figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">style</span> <span class="attr">name</span>=<span class="string">"AppTheme"</span> <span class="attr">parent</span>=<span class="string">"Theme.AppCompat.Light.DarkActionBar"</span>&gt;</span></span><br><span class="line"><span class="xml">    <span class="tag">&lt;<span class="name">item</span> <span class="attr">name</span>=<span class="string">"customfont"</span>&gt;</span>fonts/gtw.ttf<span class="tag">&lt;/<span class="name">item</span>&gt;</span></span></span><br><span class="line"><span class="tag">&lt;/<span class="name">style</span>&gt;</span></span><br></pre></td></tr></table></figure>
<p>这时应该用主题对象(Theme)来解析出字体属性</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> View <span class="title">onCreateView</span><span class="params">(View parent, String name, Context context, AttributeSet attrs)</span> </span>&#123;</span><br><span class="line">    View view = factory2.onCreateView(parent, name, context, attrs);</span><br><span class="line">    <span class="keyword">if</span>(view <span class="keyword">instanceof</span> TextView &amp;&amp; attrs!=<span class="keyword">null</span>)&#123;</span><br><span class="line">        TypedArray ta = getTheme().obtainStyledAttributes(<span class="keyword">new</span> <span class="keyword">int</span>[]&#123;</span><br><span class="line">            android.R.attr.colorAccent,  <span class="comment">//这里必须要以系统属性开头，否则自定义属性将解析错误</span></span><br><span class="line">            R.attr.customFont,           <span class="comment">//原因有待探索</span></span><br><span class="line">         &#125;);</span><br><span class="line">        String path = ta.getString(<span class="number">1</span>);</span><br><span class="line">        ta.recycle();</span><br><span class="line">        Typeface typeface = Typeface.createFromAsset(getAssets(), path);</span><br><span class="line">        ((TextView)view).setTypeface(typeface);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> view;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<blockquote>
<p>最后在实现时应该处理获取属性的优先级，一般而言，直接定义的优先级最高，style其次，主题再次之。</p>
</blockquote>

        
      
    </div>

    
    
    
      <footer class="post-footer">
          <div class="post-eof"></div>
        
      </footer>
  </div>
  
  
  
  </article>

    
        <article itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block home">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2017/08/28/android/View/Menu,PopupWindow和Dialog/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="xiang">
      <meta itemprop="description" content="谨守而勿失，是谓反其真">
      <meta itemprop="image" content="/images/1.jpg">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="lxt">
    </span>
      <header class="post-header">
        <h1 class="post-title" itemprop="name headline">
            
            <a href="/2017/08/28/android/View/Menu,PopupWindow和Dialog/" class="post-title-link" itemprop="url">Menu,PopupWindow和Dialog</a>
          
        </h1>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              
                
              

              <time title="创建时间：2017-08-28 21:26:26" itemprop="dateCreated datePublished" datetime="2017-08-28T21:26:26+08:00">2017-08-28</time>
            </span>
          
            

            
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="fa fa-calendar-check-o"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2019-09-18 15:33:08" itemprop="dateModified" datetime="2019-09-18T15:33:08+08:00">2019-09-18</time>
              </span>
            
          
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing"><a href="/categories/android/" itemprop="url" rel="index"><span itemprop="name">android</span></a></span>

                
                
                  ，
                
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing"><a href="/categories/android/View/" itemprop="url" rel="index"><span itemprop="name">View</span></a></span>

                
                
              
            </span>
          

          
          <br>
            <span class="post-meta-item" title="本文字数">
              <span class="post-meta-item-icon">
                <i class="fa fa-file-word-o"></i>
              </span>
              
                <span class="post-meta-item-text">本文字数：</span>
              
              <span>12k</span>
            </span>
          
            <span class="post-meta-item" title="阅读时长">
              <span class="post-meta-item-icon">
                <i class="fa fa-clock-o"></i>
              </span>
              
                <span class="post-meta-item-text">阅读时长 &asymp;</span>
              
              <span>11 分钟</span>
            </span>
          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h2 id="PopupWindow"><a href="#PopupWindow" class="headerlink" title="PopupWindow"></a><a href="http://liangjingkanji.coding.me/2017/02/11/PopupWindow/" target="_blank" rel="noopener">PopupWindow</a></h2><p>PopupWindow 的根本构造是</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//内容控件不能有 parent</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">PopupWindow</span><span class="params">(View contentView, <span class="keyword">int</span> width, <span class="keyword">int</span> height, <span class="keyword">boolean</span> focusable)</span></span></span><br></pre></td></tr></table></figure>
<p>本质上是利用 WindowManager 将 View 添加到屏幕上去，这也是它为何有包括 内容布局，尺寸，是否聚焦，Transition动画，BackgroundDrawable，Elevation，AnimationStyle等在内众多参数的原因，这些参数为 WindowManager.LayoutParams 所必须。</p>
<p>值得一提的是动画类型 AnimationStyle 是 style定义的，如果要改变动画类型，亦需要提供 style 资源。</p>
<figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">style</span> <span class="attr">name</span>=<span class="string">"popupwindow_anim_style"</span>&gt;</span></span><br><span class="line"><span class="xml">    <span class="tag">&lt;<span class="name">item</span> <span class="attr">name</span>=<span class="string">"android:windowEnterAnimation"</span>&gt;</span>@android:anim/fade_in<span class="tag">&lt;/<span class="name">item</span>&gt;</span></span></span><br><span class="line"><span class="xml">    <span class="tag">&lt;<span class="name">item</span> <span class="attr">name</span>=<span class="string">"android:windowExitAnimation"</span>&gt;</span>@android:anim/fade_out<span class="tag">&lt;/<span class="name">item</span>&gt;</span></span></span><br><span class="line"><span class="tag">&lt;/<span class="name">style</span>&gt;</span></span><br></pre></td></tr></table></figure>
<p>PopupWindow 在屏幕上显示的方法如下</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//此处 View 主要是提供窗口服务的 IBinder 对象，因此随便一个控件即可以。</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">showAtLocation</span><span class="params">(View parent, <span class="keyword">int</span> gravity, <span class="keyword">int</span> x, <span class="keyword">int</span> y)</span></span></span><br></pre></td></tr></table></figure>
<p><strong>应该注意的是内容控件被套了两层 FrameLayout 的包装，第一层设置 BackgrondDrawable，第二场才被设置 WindowManager.LayoutParams 参数并添加到屏幕上去。</strong></p>
<p>也可以使用下列方法来显示，不过期参数已经指向左上角</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">showAsDropDown</span><span class="params">(View anchor)</span></span></span><br></pre></td></tr></table></figure>
<h3 id="动画效果"><a href="#动画效果" class="headerlink" title="动画效果"></a>动画效果</h3><p>设置 AnimationStyle 可以达到动画效果</p>
<figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">style</span> <span class="attr">name</span>=<span class="string">"PopupW"</span>&gt;</span></span><br><span class="line"><span class="xml">    <span class="tag">&lt;<span class="name">item</span> <span class="attr">name</span>=<span class="string">"android:windowEnterAnimation"</span>&gt;</span>@anim/slide_in_left<span class="tag">&lt;/<span class="name">item</span>&gt;</span></span></span><br><span class="line"><span class="xml">    <span class="tag">&lt;<span class="name">item</span> <span class="attr">name</span>=<span class="string">"android:windowExitAnimation"</span>&gt;</span>@anim/slide_out_right<span class="tag">&lt;/<span class="name">item</span>&gt;</span></span></span><br><span class="line"><span class="tag">&lt;/<span class="name">style</span>&gt;</span></span><br></pre></td></tr></table></figure>
<p>在 23 以上，还可以采用Transition 达到动画效果</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">p.setEnterTransition(<span class="keyword">new</span> TransitionSet().addTransition(<span class="keyword">new</span> Slide(Gravity.BOTTOM)));</span><br><span class="line">p.setExitTransition(<span class="keyword">new</span> TransitionSet().addTransition(<span class="keyword">new</span> Slide(Gravity.RIGHT)));</span><br></pre></td></tr></table></figure>
<h2 id="菜单"><a href="#菜单" class="headerlink" title="菜单"></a>菜单</h2><p>菜单包括如活动中的Option和Context菜单，Toolbar上的菜单，Navi上的菜单以及 PopupMenu 等等。</p>
<figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">item</span> <span class="attr">android:title</span>=<span class="string">"更多"</span>&gt;</span>    </span><br><span class="line">  </span><br><span class="line">      <span class="tag">&lt;<span class="name">menu</span>&gt;</span>            </span><br><span class="line">        <span class="tag">&lt;<span class="name">item</span> <span class="attr">android:title</span>=<span class="string">"设置"</span>/&gt;</span>            </span><br><span class="line">        <span class="tag">&lt;<span class="name">item</span> <span class="attr">android:title</span>=<span class="string">"关于"</span>/&gt;</span>        </span><br><span class="line">      <span class="tag">&lt;/<span class="name">menu</span>&gt;</span>    </span><br><span class="line">  </span><br><span class="line">      <span class="tag">&lt;<span class="name">item</span></span></span><br><span class="line"><span class="tag">          <span class="attr">android:id</span>=<span class="string">"@+id/action_search"</span></span></span><br><span class="line"><span class="tag">          <span class="attr">android:icon</span>=<span class="string">"@drawable/ic_action_search"</span></span></span><br><span class="line"><span class="tag">          <span class="attr">android:title</span>=<span class="string">"@string/action_search"</span></span></span><br><span class="line"><span class="tag">          <span class="attr">app:showAsAction</span>=<span class="string">"collapseActionView|always|withText"</span></span></span><br><span class="line"><span class="tag">          <span class="attr">app:actionViewClass</span>=<span class="string">"android.support.v7.widget.SearchView"</span> /&gt;</span>      </span><br><span class="line"><span class="tag">&lt;/<span class="name">item</span>&gt;</span></span><br></pre></td></tr></table></figure>
<p>MenuInflater 类负责将XML文件实例化为 Menu 对象，其对于 Menu ，Group，SubMenu 等标签有不同的解析方法。</p>
<p><strong>菜单中的 ActionView，可以改变菜单外观，如搜索框中所含的 SearchView 控件</strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">MenuItem searchItem = menu.findItem(R.id.action_search);</span><br><span class="line">SearchView searchView = (SearchView) searchItem.getActionView();</span><br><span class="line">MenuItemCompat.setOnActionExpandListener(searchItem, ...);</span><br><span class="line">MenuItemCompat.expandActionView(searchItem);</span><br></pre></td></tr></table></figure>
<p>你也可以主动为菜单设置 ActionView。</p>
<h3 id="PopupMenu"><a href="#PopupMenu" class="headerlink" title="PopupMenu"></a><a href="http://liangjingkanji.coding.me/2017/02/11/PopupMenu/" target="_blank" rel="noopener">PopupMenu</a></h3><p>PopupMenu 内部有一个 Menu 对象，将xml资源加载到该对象上，显示在锚定控件下方，可以指定对齐方式。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">PopupMenu popupMenu = <span class="keyword">new</span> PopupMenu(<span class="keyword">this</span>, textView);</span><br><span class="line">popupMenu.getMenuInflater().inflate(R.menu.main, popupMenu.getMenu());</span><br><span class="line">textView.setOnTouchListener(popupMenu.getDragToOpenListener());</span><br><span class="line">popupMenu.show();</span><br></pre></td></tr></table></figure>
<h3 id="关于-OverflowButton"><a href="#关于-OverflowButton" class="headerlink" title="关于 OverflowButton"></a>关于 OverflowButton</h3><p>1.是否永久显示 <strong>overflow菜单</strong>？</p>
<p>使用反射修改 ViewConfiguration 的 sHasPermanentMenuKey 参数既可以永久显示。</p>
<p>2.获取并修改 Overflow 按钮</p>
<p>a.可以使用主题修改</p>
<figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">&lt;style name=<span class="string">"AppTheme"</span> parent=<span class="string">"Theme.AppCompat.Light.DarkActionBar"</span>&gt;</span><br><span class="line">    &lt;item name="android:actionOverflowButtonStyle"&gt;@style/OverflowStyle&lt;/item&gt;</span><br><span class="line">&lt;/style&gt;</span><br><span class="line">&lt;style name=<span class="string">"OverflowStyle"</span>&gt;</span><br><span class="line">    &lt;item name="android:src"&gt;@android:drawable/arrow_up_float&lt;/item&gt;</span><br><span class="line">&lt;/style&gt;</span><br></pre></td></tr></table></figure>
<p>b.可以使用代码修改</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">ArrayList&lt;View&gt; outViews = <span class="keyword">new</span> ArrayList&lt;View&gt;();</span><br><span class="line">String overflowDescription = activity.getString(<span class="string">"more options"</span>);</span><br><span class="line">decorView.findViewsWithText(outViews, overflowDescription, View.FIND_VIEWS_WITH_CONTENT_DESCRIPTION);</span><br><span class="line">TintImageView overflow=(TintImageView) outViews.get(<span class="number">0</span>);</span><br><span class="line">overflow.setImageResource(imageID);</span><br></pre></td></tr></table></figure>
<h2 id="Dialog"><a href="#Dialog" class="headerlink" title="Dialog"></a>Dialog</h2><p>实际上 Activity 只要使用 Dialog 主题就可以看做Dialog，但 Dialog 实际上是没有生命周期的。</p>
<p>主要的话框是 AlertDialog，以及较新的 DialogFragment 和 BottomDialog ，也包括一些特定功能的对话框如 ProgressDialog，颜色，日期等。</p>
<p>AlertDialog 只不过预设了大量布局且可以根据构造方法来选择控件而已，这里提一下单选和多选对话框的使用。创建时应使用适配器，这样可以在对话框上添加条目</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">Builder <span class="title">setAdapter</span><span class="params">(<span class="keyword">final</span> ListAdapter adapter, <span class="keyword">final</span> OnClickListener listener)</span></span></span><br></pre></td></tr></table></figure>
<p>ProgressDialog 的实现原理就是内置了一个 ProgressDialog 。</p>
<h3 id="BottomSheetDialog"><a href="#BottomSheetDialog" class="headerlink" title="BottomSheetDialog"></a>BottomSheetDialog</h3><p>使用方法如下</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">BottomSheetDialog dialog=<span class="keyword">new</span> BottomSheetDialog(<span class="keyword">this</span>);</span><br><span class="line">dialog.setContentView(dialogView);</span><br><span class="line">dialog.show();</span><br></pre></td></tr></table></figure>
<p>这里设置布局时加入布局时做了一番手脚</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> View <span class="title">wrapInBottomSheet</span><span class="params">(<span class="keyword">int</span> layoutResId, View view, ViewGroup.LayoutParams params)</span> </span>&#123;</span><br><span class="line">    CoordinatorLayout coordinator = inflate(context,</span><br><span class="line">            R.layout.design_bottom_sheet_dialog, <span class="keyword">null</span>);</span><br><span class="line">    FrameLayout bottomSheet = (FrameLayout) coordinator.findViewById(R.id.design_bottom_sheet);</span><br><span class="line">    mBehavior = BottomSheetBehavior.from(bottomSheet);</span><br><span class="line">    mBehavior.setBottomSheetCallback(mBottomSheetCallback);</span><br><span class="line">    bottomSheet.addView(view, params);</span><br><span class="line">    coordinator.findViewById(R.id.touch_outside).setOnClickListener(<span class="keyword">new</span> View.OnClickListener() &#123;</span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onClick</span><span class="params">(View view)</span> </span>&#123;</span><br><span class="line">            <span class="keyword">if</span> (mCancelable &amp;&amp; isShowing() &amp;&amp; shouldWindowCloseOnTouchOutside()) &#123;</span><br><span class="line">                cancel();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;);</span><br><span class="line">    <span class="keyword">return</span> coordinator;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这里设置布局后，将载入一个 CoordinatorLayout，其中有一个 FrameLayout，配置 BottomSheetBehavior，并将内容添加进去。</p>
<p>加载的主题是 <code>Window.FEATURE_NO_TITLE</code>，即没有标题的对话框。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> BottomSheetBehavior&lt;FrameLayout&gt; mBehavior;</span><br></pre></td></tr></table></figure>
<h3 id="DialogFragment"><a href="#DialogFragment" class="headerlink" title="DialogFragment"></a>DialogFragment</h3><p>使用 DialogFragment 是因为 Dialog 无生命周期，在横竖屏切换时会导致丢失对话框，而 DialogFragment 本质是一个带 Dialog 对象的碎片，能够恢复和重建 。</p>
<p>实际上它不需要重写 onCreateView 方法来建立视图，只需要重写下列方法建立 Dialog 对象即可，真正显示的是 Dialog 对象而不是视图。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">Dialog <span class="title">onCreateDialog</span><span class="params">(Bundle savedInstanceState)</span></span></span><br></pre></td></tr></table></figure>
<p>而后我们使用下列方法显示对话框</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">show</span><span class="params">(FragmentManager manager, String tag)</span></span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">show</span><span class="params">(FragmentTransaction transaction, String tag)</span></span></span><br></pre></td></tr></table></figure>
<p>这实际是添加到任务栈，用第二个方法你可以的碎片在栈中的 id。这样碎片就会追随所依附活动的状态，一旦碎片处于 onStart 状态 Dialog 就会显示，而 碎片处于 onStop 状态时 Dialog 就会隐藏(不是dismiss)。</p>
<p>如果突然关闭所在页面，活动销毁会导致碎片销毁视图，经历 DestroyView 状态，则 Dialog 消失(即dismiss)，接着会触发碎片的销毁，一般而言是将碎片出栈，以释放内存。</p>
<p>此外下列方法也将完成碎片的释放</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">dismiss</span><span class="params">()</span></span>;</span><br></pre></td></tr></table></figure>
<p><strong>问题1：显示的是 Dialog 还是 View？</strong></p>
<p>下列方法被改写了，这在创建视图时也影响了 Dialog 对象。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> LayoutInflater <span class="title">getLayoutInflater</span><span class="params">(Bundle savedInstanceState)</span> </span>&#123;</span><br><span class="line">  </span><br><span class="line">    <span class="keyword">if</span> (!mShowsDialog) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">super</span>.getLayoutInflater(savedInstanceState);</span><br><span class="line">    &#125;</span><br><span class="line">    mDialog = onCreateDialog(savedInstanceState);</span><br><span class="line">    <span class="keyword">if</span> (mDialog != <span class="keyword">null</span>) &#123;</span><br><span class="line">        setupDialog(mDialog, mStyle);</span><br><span class="line">        <span class="keyword">return</span> (LayoutInflater) mDialog.getContext().getSystemService(</span><br><span class="line">                Context.LAYOUT_INFLATER_SERVICE);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> (LayoutInflater) mHost.getContext().getSystemService(</span><br><span class="line">            Context.LAYOUT_INFLATER_SERVICE);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>首先 mShowsDialog 标记了是否显示对话框，如果其为 false，那么正常加载视图进行显示。</p>
<p>而后创建 Dialog 对象，在 onActivityCreated 方法中将决定显示哪个？如果同时设置了 View，则将 View 作为 Dialog 的内容视图，此外还要给 Dialog 打上 dismiss 监听器，保证碎片的释放。</p>
<p><strong>因此如果想采用所创建的对话框，第一要保证 mShowsDialog 标记为真，第二不要画蛇添足去实现 onCreateView 方法。</strong></p>
<h3 id="更改-Dialog-主题"><a href="#更改-Dialog-主题" class="headerlink" title="更改 Dialog 主题"></a>更改 Dialog 主题</h3><p>以下是V7包里 AlertDialog 的实际布局，实际是由 <strong>标题块(带分割线)，message块，自定义块和按钮块</strong> 组成的。</p>
<figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">LinearLayout</span> <span class="attr">android:id</span>=<span class="string">"@+id/parentPanel"</span>&gt;</span></span><br><span class="line">    </span><br><span class="line">    <span class="tag">&lt;<span class="name">LinearLayout</span> <span class="attr">android:id</span>=<span class="string">"@+id/topPanel"</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">LinearLayout</span> <span class="attr">android:id</span>=<span class="string">"@+id/title_template"</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">ImageView</span> <span class="attr">android:id</span>=<span class="string">"@+id/icon"</span></span></span><br><span class="line"><span class="tag">                <span class="attr">android:src</span>=<span class="string">"@drawable/ic_dialog_info"</span> /&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">com.android.internal.widget.DialogTitle</span> <span class="attr">android:id</span>=<span class="string">"@+id/alertTitle"</span></span></span><br><span class="line"><span class="tag">                <span class="attr">style</span>=<span class="string">"?android:attr/textAppearanceLarge"</span></span></span><br><span class="line"><span class="tag">                <span class="attr">android:singleLine</span>=<span class="string">"true"</span> /&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">LinearLayout</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">ImageView</span> <span class="attr">android:id</span>=<span class="string">"@+id/titleDivider"</span></span></span><br><span class="line"><span class="tag">            <span class="attr">android:src</span>=<span class="string">"@android:drawable/divider_horizontal_dark"</span> /&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">LinearLayout</span>&gt;</span></span><br><span class="line">    </span><br><span class="line">    <span class="tag">&lt;<span class="name">LinearLayout</span> <span class="attr">android:id</span>=<span class="string">"@+id/contentPanel&gt;</span></span></span><br><span class="line"><span class="tag"><span class="string">        &lt;ScrollView android:id="</span>@+<span class="attr">id</span>/<span class="attr">scrollView</span>"&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">TextView</span> <span class="attr">android:id</span>=<span class="string">"@+id/message"</span></span></span><br><span class="line"><span class="tag">                <span class="attr">style</span>=<span class="string">"?android:attr/textAppearanceMedium"</span> /&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">ScrollView</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">LinearLayout</span>&gt;</span></span><br><span class="line">    </span><br><span class="line">    <span class="tag">&lt;<span class="name">FrameLayout</span> <span class="attr">android:id</span>=<span class="string">"@+id/customPanel"</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">FrameLayout</span> <span class="attr">android:id</span>=<span class="string">"@+android:id/custom"</span> /&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">FrameLayout</span>&gt;</span></span><br><span class="line">    </span><br><span class="line">    <span class="tag">&lt;<span class="name">LinearLayout</span> <span class="attr">android:id</span>=<span class="string">"@+id/buttonPanel"</span> &gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">LinearLayout</span> <span class="attr">style</span>=<span class="string">"?android:attr/buttonBarStyle"</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">LinearLayout</span> <span class="attr">android:id</span>=<span class="string">"@+id/leftSpacer"</span></span></span><br><span class="line"><span class="tag">                <span class="attr">android:layout_weight</span>=<span class="string">"0.25"</span></span></span><br><span class="line"><span class="tag">                <span class="attr">android:layout_width</span>=<span class="string">"0dip"</span></span></span><br><span class="line"><span class="tag">                <span class="attr">android:layout_height</span>=<span class="string">"wrap_content"</span></span></span><br><span class="line"><span class="tag">                <span class="attr">android:orientation</span>=<span class="string">"horizontal"</span></span></span><br><span class="line"><span class="tag">                <span class="attr">android:visibility</span>=<span class="string">"gone"</span> /&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">Button</span> <span class="attr">android:id</span>=<span class="string">"@+id/button1"</span></span></span><br><span class="line"><span class="tag">                <span class="attr">android:layout_width</span>=<span class="string">"0dip"</span></span></span><br><span class="line"><span class="tag">                <span class="attr">android:layout_weight</span>=<span class="string">"1"</span></span></span><br><span class="line"><span class="tag">                <span class="attr">style</span>=<span class="string">"?android:attr/buttonBarButtonStyle"</span> /&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">Button</span> <span class="attr">android:id</span>=<span class="string">"@+id/button3"</span></span></span><br><span class="line"><span class="tag">                <span class="attr">android:layout_width</span>=<span class="string">"0dip"</span></span></span><br><span class="line"><span class="tag">                <span class="attr">android:layout_gravity</span>=<span class="string">"center_horizontal"</span></span></span><br><span class="line"><span class="tag">                <span class="attr">android:layout_weight</span>=<span class="string">"1"</span></span></span><br><span class="line"><span class="tag">                <span class="attr">style</span>=<span class="string">"?android:attr/buttonBarButtonStyle"</span> /&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">Button</span> <span class="attr">android:id</span>=<span class="string">"@+id/button2"</span></span></span><br><span class="line"><span class="tag">                <span class="attr">android:layout_width</span>=<span class="string">"0dip"</span></span></span><br><span class="line"><span class="tag">                <span class="attr">android:layout_weight</span>=<span class="string">"1"</span></span></span><br><span class="line"><span class="tag">                <span class="attr">style</span>=<span class="string">"?android:attr/buttonBarButtonStyle"</span> /&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">LinearLayout</span> <span class="attr">android:id</span>=<span class="string">"@+id/rightSpacer"</span></span></span><br><span class="line"><span class="tag">                <span class="attr">android:layout_width</span>=<span class="string">"0dip"</span></span></span><br><span class="line"><span class="tag">                <span class="attr">android:layout_weight</span>=<span class="string">"0.25"</span></span></span><br><span class="line"><span class="tag">                <span class="attr">android:visibility</span>=<span class="string">"gone"</span> /&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">LinearLayout</span>&gt;</span></span><br><span class="line">     <span class="tag">&lt;/<span class="name">LinearLayout</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">LinearLayout</span>&gt;</span></span><br></pre></td></tr></table></figure>
<p>想要修改主题可以用如下构造方法</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">new</span> AlertDialog.Builder(<span class="keyword">this</span>, R.style.Test);</span><br></pre></td></tr></table></figure>
<p>这里可以传入主题，也可以传入样式，其中主题 id 均大于 0x01000000，如果是样式，则将样式应用到主题上。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">context.getTheme().resolveAttribute(R.attr.alertDialogTheme, outValue, <span class="keyword">true</span>);</span><br></pre></td></tr></table></figure>
<h3 id="Dialog-的扩展-布局定制和动画效果"><a href="#Dialog-的扩展-布局定制和动画效果" class="headerlink" title="Dialog 的扩展:布局定制和动画效果"></a>Dialog 的扩展:布局定制和动画效果</h3><p>Dialog 的扩展主要包括两个方面：布局定制和动画效果。</p>
<p>想实现 Dialog 的入场动画效果，最简单的方法如下</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">dialog.setOnShowListener(<span class="keyword">new</span> DialogInterface.OnShowListener() &#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onShow</span><span class="params">(DialogInterface d)</span> </span>&#123;</span><br><span class="line">        View view = dialog.getWindow().getDecorView();</span><br><span class="line">        view.animate().rotation(<span class="number">360</span>).setDuration(<span class="number">2000</span>).start();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>
<p>这种方法即在 DecorView 做动画，但局限性很大。</p>
<p><strong>更一般的方式是定制一个布局，或像 BottomSheetDialog 那样，对传入的布局采用 wrap 操作；最终留出根布局的接口，以便对此进行动画。</strong></p>
<p>布局定制的核心是改造 onCreate 方法</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">onCreate</span><span class="params">(Bundle savedInstanceState)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">super</span>.onCreate(savedInstanceState);</span><br><span class="line">    setContentView(R.layout.app_bar_main); </span><br><span class="line">    <span class="comment">// ......</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>动画效果的核心是设置具体的动画效果，对于显示动画，可以放在 OnShowListener 接口中，因为该接口执行的时候，布局已经添加到 Dialog 中去了，但对于消失动画而已，则无法利用 onDiamissListener 接口，因此此接口执行时，布局已经被移除。</p>
<p>此时，可以通过改造 dismiss 方法来实现消失动画。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">dismiss</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    animatorSet = <span class="keyword">new</span> AnimatorSet();</span><br><span class="line">    setupAnim();</span><br><span class="line">    animatorSet.addListener(<span class="keyword">new</span> Animator.AnimatorListener() &#123;</span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onAnimationEnd</span><span class="params">(Animator animation)</span> </span>&#123;</span><br><span class="line">            AnimDialog.<span class="keyword">super</span>.dismiss();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;);</span><br><span class="line">    animatorSet.resume();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><strong>这个方法一定要具体的子类( 此处是AnimDialog)来执行，不能交给父类AlertDialog执行，因此创建一个构造方法</strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> AnimDialog <span class="title">create</span><span class="params">(Context context)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> AnimDialog(context);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="动画的具体效果"><a href="#动画的具体效果" class="headerlink" title="动画的具体效果"></a>动画的具体效果</h3><p><strong>rotationY 是绕着y轴旋转的，为了动画之后显示正常，结束值应该设置为0。起始值如果为正，就是侧对着的感觉，有“掀开”的感觉。</strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ObjectAnimator.ofFloat(view, <span class="string">"rotationY"</span>, -<span class="number">90</span>, <span class="number">0</span>).setDuration(mDuration)</span><br></pre></td></tr></table></figure>
<p><strong>rotation 是绕着z轴旋转的，所有旋转操作的中心点都在中心处。</strong></p>
<p><strong>translationX等是平移的效果，改变方向可以取得从四边滑入的效果，也可以取得震动效果</strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ObjectAnimator.ofFloat(view, <span class="string">"translationX"</span>, <span class="number">0</span>, .<span class="number">10f</span>, -<span class="number">25</span>, .<span class="number">26f</span>, <span class="number">25</span>,.<span class="number">42f</span>, -<span class="number">25</span>, .<span class="number">58f</span>, <span class="number">25</span>,.<span class="number">74f</span>,-<span class="number">25</span>,.<span class="number">90f</span>,<span class="number">1</span>,<span class="number">0</span>)</span><br></pre></td></tr></table></figure>
<p><strong>scaleX等可以取得展开和收缩的效果。</strong></p>
<p>复合效果1：左侧旋转滚入，一般而言此类效果的方向是垂直的，从左侧滚入，那么旋转就是绕Y轴的</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ObjectAnimator.ofFloat(view, <span class="string">"rotationY"</span>, <span class="number">90</span>, <span class="number">0</span>).setDuration(<span class="number">2000</span>), <span class="comment">//负责旋转ObjectAnimator.ofFloat(view, "translationX", -300, 0).setDuration(2000), //负责左侧ObjectAnimator.ofFloat(view, "alpha", 0, 1).setDuration(2000*3/2)</span></span><br></pre></td></tr></table></figure>
<p>复合效果2：弹出展开与收缩展开</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">ObjectAnimator.ofFloat(view, <span class="string">"rotationY"</span>, <span class="number">90</span>,<span class="number">88</span>,<span class="number">88</span>,<span class="number">45</span>,<span class="number">0</span>).setDuration(<span class="number">2000</span>),</span><br><span class="line">ObjectAnimator.ofFloat(view, <span class="string">"alpha"</span>, <span class="number">0</span>,<span class="number">0.4f</span>,<span class="number">0.8f</span>, <span class="number">1</span>).setDuration(<span class="number">2000</span>*<span class="number">3</span>/<span class="number">2</span>),</span><br><span class="line">ObjectAnimator.ofFloat(view, <span class="string">"scaleX"</span>, <span class="number">0</span>,<span class="number">0.5f</span>, <span class="number">0.9f</span>, <span class="number">0.9f</span>, <span class="number">1</span>).setDuration(<span class="number">2000</span>),</span><br><span class="line">ObjectAnimator.ofFloat(view,<span class="string">"scaleY"</span>,<span class="number">0</span>,<span class="number">0.5f</span>, <span class="number">0.9f</span>, <span class="number">0.9f</span>, <span class="number">1</span>).setDuration(<span class="number">2000</span>)</span><br></pre></td></tr></table></figure>
<p>弹出展开的特殊例子是新闻风格，核心是快速旋转多个来回。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">ObjectAnimator.ofFloat(view, <span class="string">"rotation"</span>, <span class="number">1080</span>,<span class="number">720</span>,<span class="number">360</span>,<span class="number">0</span>).setDuration(<span class="number">2000</span>),</span><br><span class="line">ObjectAnimator.ofFloat(view, <span class="string">"alpha"</span>, <span class="number">0</span>, <span class="number">1</span>).setDuration(<span class="number">2000</span>*<span class="number">3</span>/<span class="number">2</span>),</span><br><span class="line">ObjectAnimator.ofFloat(view, <span class="string">"scaleX"</span>, <span class="number">0.1f</span>, <span class="number">0.5f</span>, <span class="number">1</span>).setDuration(<span class="number">2000</span>),</span><br><span class="line">ObjectAnimator.ofFloat(view,<span class="string">"scaleY"</span>,<span class="number">0.1f</span>,<span class="number">0.5f</span>,<span class="number">1</span>).setDuration(<span class="number">2000</span>)</span><br></pre></td></tr></table></figure>
<h3 id="广告对话框"><a href="#广告对话框" class="headerlink" title="广告对话框"></a><a href="https://github.com/yipianfengye/android-adDialog" target="_blank" rel="noopener">广告对话框</a></h3><p><img src="https://github.com/yipianfengye/android-adDialog/raw/master/images/ezgif.com-video-to-gif1.gif" alt="广告对话框"></p>

        
      
    </div>

    
    
    
      <footer class="post-footer">
          <div class="post-eof"></div>
        
      </footer>
  </div>
  
  
  
  </article>

    
        <article itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block home">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2017/08/24/android/View/一些有意思的 View/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="xiang">
      <meta itemprop="description" content="谨守而勿失，是谓反其真">
      <meta itemprop="image" content="/images/1.jpg">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="lxt">
    </span>
      <header class="post-header">
        <h1 class="post-title" itemprop="name headline">
            
            <a href="/2017/08/24/android/View/一些有意思的 View/" class="post-title-link" itemprop="url">一些有意思的 View</a>
          
        </h1>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              
                
              

              <time title="创建时间：2017-08-24 09:26:26" itemprop="dateCreated datePublished" datetime="2017-08-24T09:26:26+08:00">2017-08-24</time>
            </span>
          
            

            
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="fa fa-calendar-check-o"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2019-09-18 15:10:43" itemprop="dateModified" datetime="2019-09-18T15:10:43+08:00">2019-09-18</time>
              </span>
            
          
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing"><a href="/categories/android/" itemprop="url" rel="index"><span itemprop="name">android</span></a></span>

                
                
                  ，
                
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing"><a href="/categories/android/View/" itemprop="url" rel="index"><span itemprop="name">View</span></a></span>

                
                
              
            </span>
          

          
          <br>
            <span class="post-meta-item" title="本文字数">
              <span class="post-meta-item-icon">
                <i class="fa fa-file-word-o"></i>
              </span>
              
                <span class="post-meta-item-text">本文字数：</span>
              
              <span>2.7k</span>
            </span>
          
            <span class="post-meta-item" title="阅读时长">
              <span class="post-meta-item-icon">
                <i class="fa fa-clock-o"></i>
              </span>
              
                <span class="post-meta-item-text">阅读时长 &asymp;</span>
              
              <span>2 分钟</span>
            </span>
          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <p>自定义View的套路包括以下四种。</p>
<h2 id="绘制效果型"><a href="#绘制效果型" class="headerlink" title="绘制效果型"></a>绘制效果型</h2><p>直接使用 Canvas 添加绘制效果是最简单的一种套路。例如<a href="https://github.com/Jichensheng/BaiduWave" target="_blank" rel="noopener">BaiduWave</a>的效果不过是通过截断 Canvas 来实现的。</p>
<img src="/2017/08/24/android/View/一些有意思的%20View/baidu.gif">
<p>又比如<a href="https://github.com/SparkYuan/SubmitButton" target="_blank" rel="noopener">SubmitButton</a>的动画效果看起来很华丽，但可以将其过程拆成几段分别进行绘制。</p>
<img src="/2017/08/24/android/View/一些有意思的%20View/submitbutton.gif">
<h3 id="PatternLockView"><a href="#PatternLockView" class="headerlink" title="PatternLockView"></a><a href="https://github.com/aritraroy/PatternLockView" target="_blank" rel="noopener">PatternLockView</a></h3><p><img src="https://github.com/aritraroy/PatternLockView/raw/master/screenshots/pattern_lock_view_small.gif?raw=true" alt="PatternLockView"></p>
<p>PatternLockView 的绘制效果还与触摸事件有关，属于此类型中较为复杂的。</p>
<h2 id="偷梁换柱型"><a href="#偷梁换柱型" class="headerlink" title="偷梁换柱型"></a>偷梁换柱型</h2><p>偷梁换柱型指的是在原生的系统控件上添加或替换控件，典型的例子就是 <a href="https://github.com/AlexLiuSheng/BadgeView" target="_blank" rel="noopener">BadgeView</a>。</p>
<img src="/2017/08/24/android/View/一些有意思的%20View/version1.0.5.png">
<p>BadgeView 是怎样实现给已经存在的控件“打上”标记呢？</p>
<p>将原来的控件(如 ImageView)从视图树中移除，但记录它的布局参数，ID等信息。而后新建一个 FrameLayout ，将ImageView 和准备好的角标加入这个布局，最后将 FrameLayout 添加到视图树中去，并复原它的 id ，布局参数等信息。</p>
<blockquote>
<p>实际上要实现 Badger 效果，完全可以靠扩展控件的 onDraw 方法来实现，不过这种实现没有通用性。</p>
</blockquote>
<p><a href="https://github.com/tyrantgit/ExplosionField" target="_blank" rel="noopener">升级版的BadgeView</a>还实现了动画效果。</p>
<img src="/2017/08/24/android/View/一些有意思的%20View/8f5ab3aa-5db8-11e6-808c-6033f5d5c4ec.gif">
<h3 id="AndroidResideMenu"><a href="#AndroidResideMenu" class="headerlink" title="AndroidResideMenu"></a><a href="https://github.com/SpecialCyCi/AndroidResideMenu" target="_blank" rel="noopener">AndroidResideMenu</a></h3><img src="/2017/08/24/android/View/一些有意思的%20View/2.gif">
<p>AndroidResideMenu 在Activity的根布局中插入新布局，点击后用动画。还要处理 Activity 的 dispatchTouchEvent方法。</p>
<h3 id="ShowcaseView"><a href="#ShowcaseView" class="headerlink" title="ShowcaseView"></a><a href="https://github.com/amlcurran/ShowcaseView" target="_blank" rel="noopener">ShowcaseView</a></h3><img src="/2017/08/24/android/View/一些有意思的%20View/example2@2x.png">
<h3 id="TapTargetView"><a href="#TapTargetView" class="headerlink" title="TapTargetView"></a><a href="https://github.com/KeepSafe/TapTargetView" target="_blank" rel="noopener">TapTargetView</a></h3><img src="/2017/08/24/android/View/一些有意思的%20View/screenshot1.png">
<p>TapTargetView 显示 SpannableString作为提示。</p>
<h2 id="GuillotineMenu-Android"><a href="#GuillotineMenu-Android" class="headerlink" title="GuillotineMenu-Android"></a><a href="https://github.com/Yalantis/GuillotineMenu-Android" target="_blank" rel="noopener">GuillotineMenu-Android</a></h2><img src="/2017/08/24/android/View/一些有意思的%20View/68747.gif">
<p>这个库的交互方式非常有意思，它将换上的布局旋转-90度隐藏起来，而后执行动画显示。难点在于如何处理遮挡NaviMenu的问题。</p>
<h2 id="组合排列型"><a href="#组合排列型" class="headerlink" title="组合排列型"></a>组合排列型</h2><p>组合排列型是将几种控件组合在容器中，也是较为简单和常用的方法。</p>
<h3 id="SpaceTabLayout"><a href="#SpaceTabLayout" class="headerlink" title="SpaceTabLayout"></a><a href="https://github.com/thelong1EU/SpaceTabLayout" target="_blank" rel="noopener"><strong>SpaceTabLayout</strong></a></h3><img src="/2017/08/24/android/View/一些有意思的%20View/3.gif">
<p>这里是将组合和绘制结合在一起了。</p>
<h3 id="AndroidTreeView"><a href="#AndroidTreeView" class="headerlink" title="AndroidTreeView"></a><a href="https://github.com/bmelnychuk/AndroidTreeView" target="_blank" rel="noopener">AndroidTreeView</a></h3>
<p>这个树结构的View是纯粹的排列组合式，不过特殊之处在于要设计节点的的数据结构，即树。节点的抽象类TreeNode如下</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">TreeNode</span> </span>&#123;</span><br><span class="line">  <span class="keyword">private</span> TreeNode mParent; </span><br><span class="line">  <span class="keyword">private</span> <span class="keyword">final</span> List&lt;TreeNode&gt; children;</span><br><span class="line">  <span class="keyword">private</span> BaseNodeViewHolder mViewHolder;<span class="comment">//布局</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>各层的容器实际是 LinearLayout。获得根节点后，将每一个子节点中的布局添加进去即可，唯一值得注意的是这个一个递归过程，你还可以决定是否要扩展或收缩整个布局以及是否使用动画效果。</p>
<h2 id="动画驱动型"><a href="#动画驱动型" class="headerlink" title="动画驱动型"></a>动画驱动型</h2><p>动画驱动型泛指为添加动画行为，与其它几种类型可以同时使用。例如 <a href="https://github.com/flavioarfaria/KenBurnsView" target="_blank" rel="noopener">KenBurnsView</a>就是在ImageView上应用属性动画而已。</p>
<img src="/2017/08/24/android/View/一些有意思的%20View/anim.gif">
<p>在比如<a href="https://github.com/varunest/SparkButton" target="_blank" rel="noopener">SparkButton</a>是对自定义的绘制效果使用动画。</p>

<h3 id="FloatingView"><a href="#FloatingView" class="headerlink" title="FloatingView"></a><a href="https://github.com/UFreedom/FloatingView" target="_blank" rel="noopener">FloatingView</a></h3><img src="/2017/08/24/android/View/一些有意思的%20View/demo.gif">
<p>FloatingView 是偷懒换柱的实现，兼备动画效果。</p>
<p>FloatingView 在 DecorView 上添加了一层 FrameLayout，确定 anchorView 在屏幕上的位置将其在添加的FrameLayout上复制，并执行动画。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">Rect rect = <span class="keyword">new</span> Rect();</span><br><span class="line">anchorView.getGlobalVisibleRect(rect);</span><br><span class="line"><span class="keyword">int</span>[] location = <span class="keyword">new</span> <span class="keyword">int</span>[<span class="number">2</span>];</span><br><span class="line">mFloatingDecorView.getLocationOnScreen(location);</span><br><span class="line">rect.offset(-location[<span class="number">0</span>], -location[<span class="number">1</span>]);</span><br><span class="line"><span class="comment">//anchorView 的测量和布局</span></span><br><span class="line">mFloatingDecorView.addView(targetView,lp);</span><br><span class="line"><span class="comment">//此后是应用动画</span></span><br></pre></td></tr></table></figure>
<p>类似的是<a href="https://github.com/tyrantgit/HeartLayout" target="_blank" rel="noopener">HeartLayout</a></p>
<img src="/2017/08/24/android/View/一些有意思的%20View/heartlayout.gif">
<h3 id="folding-cell-android"><a href="#folding-cell-android" class="headerlink" title="folding-cell-android"></a><a href="https://github.com/Ramotion/folding-cell-android" target="_blank" rel="noopener">folding-cell-android</a></h3><img src="/2017/08/24/android/View/一些有意思的%20View/folding_cell_preview.gif">
<p>使用翻页动画来显示简介和详情，有意思的交互。</p>
<p>FoldingCell 本身是一个容器，将若干个布局折叠存放起来，点击时对这些页执行动画。</p>
<h3 id="AndroidFillableLoaders"><a href="#AndroidFillableLoaders" class="headerlink" title="AndroidFillableLoaders"></a><a href="https://github.com/JorgeCastilloPrz/AndroidFillableLoaders" target="_blank" rel="noopener">AndroidFillableLoaders</a></h3><img src="/2017/08/24/android/View/一些有意思的%20View/demoWaves.gif">
<h3 id="VectAlign"><a href="#VectAlign" class="headerlink" title="VectAlign"></a><a href="https://github.com/bonnyfone/vectalign" target="_blank" rel="noopener">VectAlign</a></h3><img src="/2017/08/24/android/View/一些有意思的%20View/6966.gif">
<h3 id="AndroidViewHover"><a href="#AndroidViewHover" class="headerlink" title="AndroidViewHover"></a><a href="https://github.com/daimajia/AndroidViewHover" target="_blank" rel="noopener">AndroidViewHover</a></h3><img src="/2017/08/24/android/View/一些有意思的%20View/76966.gif">
<h3 id="Grav"><a href="#Grav" class="headerlink" title="Grav"></a><a href="https://github.com/glomadrian/Grav" target="_blank" rel="noopener">Grav</a></h3><img src="/2017/08/24/android/View/一些有意思的%20View/login.gif">
<h2 id="综合使用"><a href="#综合使用" class="headerlink" title="综合使用"></a>综合使用</h2><p>例如<a href="https://github.com/Yalantis/Context-Menu.Android" target="_blank" rel="noopener">Context-Menu</a>这个库同时使用了偷梁换柱和组合排列，还添加了动画效果。</p>
<img src="/2017/08/24/android/View/一些有意思的%20View/8745.gif">
<p>有一些效果有多种实现方式，例如文字的跑马灯效果，可以纯粹绘制路径的方式实现，也可以用控件的组合的方式实现。</p>
<p><a href="https://github.com/oubowu/MarqueeLayoutLibrary" target="_blank" rel="noopener">MarqueeLayoutLibrary</a>将控件并排排列，每一个子控件的尺寸都与容器相同，利用 Scroller 产生滚动效果。</p>

<p><a href="https://github.com/sdsmdg/RotatingText" target="_blank" rel="noopener">RotatingText</a></p>
<img src="/2017/08/24/android/View/一些有意思的%20View/gif_cover.gif">
<p>则采用直接绘制的方式完成。</p>
<h3 id="DiagonalLayout"><a href="#DiagonalLayout" class="headerlink" title="DiagonalLayout"></a><a href="https://github.com/florent37/DiagonalLayout" target="_blank" rel="noopener">DiagonalLayout</a></h3><img src="/2017/08/24/android/View/一些有意思的%20View/sample.gif">
<h3 id="StepView"><a href="#StepView" class="headerlink" title="StepView"></a><a href="https://github.com/baoyachi/StepView" target="_blank" rel="noopener">StepView</a></h3><img src="/2017/08/24/android/View/一些有意思的%20View/snapshot.png">
<p>StepView 是组合控件兼顾了绘制效果，它本身是一个 LinearLayout，容纳的布局如下</p>
<figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">LinearLayout</span> <span class="attr">xmlns:android</span>=<span class="string">"http://schemas.android.com/apk/res/android"</span></span></span><br><span class="line"><span class="tag">              <span class="attr">android:layout_width</span>=<span class="string">"match_parent"</span></span></span><br><span class="line"><span class="tag">              <span class="attr">android:layout_height</span>=<span class="string">"match_parent"</span></span></span><br><span class="line"><span class="tag">              <span class="attr">android:orientation</span>=<span class="string">"vertical"</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">com.baoyachi.stepview.HorizontalStepsViewIndicator</span></span></span><br><span class="line"><span class="tag">        <span class="attr">android:id</span>=<span class="string">"@+id/steps_indicator"</span></span></span><br><span class="line"><span class="tag">        <span class="attr">android:layout_width</span>=<span class="string">"match_parent"</span></span></span><br><span class="line"><span class="tag">        <span class="attr">android:layout_height</span>=<span class="string">"wrap_content"</span>"/&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">RelativeLayout</span></span></span><br><span class="line"><span class="tag">        <span class="attr">android:id</span>=<span class="string">"@+id/rl_text_container"</span></span></span><br><span class="line"><span class="tag">        <span class="attr">android:layout_width</span>=<span class="string">"match_parent"</span></span></span><br><span class="line"><span class="tag">        <span class="attr">android:layout_height</span>=<span class="string">"wrap_content"</span></span></span><br><span class="line"><span class="tag">        /&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">LinearLayout</span>&gt;</span></span><br></pre></td></tr></table></figure>
<p>其中RelativeLayout负责容纳TextView控件， HorizontalStepsViewIndicator 负责绘制效果。</p>
<h3 id="NavigationTabBar"><a href="#NavigationTabBar" class="headerlink" title="NavigationTabBar"></a><a href="https://github.com/Devlight/NavigationTabBar" target="_blank" rel="noopener">NavigationTabBar</a></h3><img src="/2017/08/24/android/View/一些有意思的%20View/54645.gif">
<h3 id="TapBarMenu"><a href="#TapBarMenu" class="headerlink" title="TapBarMenu"></a><a href="https://github.com/michaldrabik/TapBarMenu" target="_blank" rel="noopener">TapBarMenu</a></h3><img src="/2017/08/24/android/View/一些有意思的%20View/2e676966.gif">

        
      
    </div>

    
    
    
      <footer class="post-footer">
          <div class="post-eof"></div>
        
      </footer>
  </div>
  
  
  
  </article>

    
        <article itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block home">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2017/08/20/android/View/一些提示性的控件/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="xiang">
      <meta itemprop="description" content="谨守而勿失，是谓反其真">
      <meta itemprop="image" content="/images/1.jpg">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="lxt">
    </span>
      <header class="post-header">
        <h1 class="post-title" itemprop="name headline">
            
            <a href="/2017/08/20/android/View/一些提示性的控件/" class="post-title-link" itemprop="url">一些提示性的控件</a>
          
        </h1>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              
                
              

              <time title="创建时间：2017-08-20 14:28:29" itemprop="dateCreated datePublished" datetime="2017-08-20T14:28:29+08:00">2017-08-20</time>
            </span>
          
            

            
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="fa fa-calendar-check-o"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2019-09-18 15:21:08" itemprop="dateModified" datetime="2019-09-18T15:21:08+08:00">2019-09-18</time>
              </span>
            
          
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing"><a href="/categories/android/" itemprop="url" rel="index"><span itemprop="name">android</span></a></span>

                
                
                  ，
                
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing"><a href="/categories/android/View/" itemprop="url" rel="index"><span itemprop="name">View</span></a></span>

                
                
              
            </span>
          

          
          <br>
            <span class="post-meta-item" title="本文字数">
              <span class="post-meta-item-icon">
                <i class="fa fa-file-word-o"></i>
              </span>
              
                <span class="post-meta-item-text">本文字数：</span>
              
              <span>5.1k</span>
            </span>
          
            <span class="post-meta-item" title="阅读时长">
              <span class="post-meta-item-icon">
                <i class="fa fa-clock-o"></i>
              </span>
              
                <span class="post-meta-item-text">阅读时长 &asymp;</span>
              
              <span>5 分钟</span>
            </span>
          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <p>提示性的控件代表了着一种典型的自定义控件的实现思路，即<strong>在某个布局上添加自定义的布局。</strong></p>
<p>像系统定义的 Toast，Dialog，甚至 Activity 都是在 Window 上添加自定义布局，SnackBar 则是在 CoordinatorLayout 布局上添加自定义布局，以便利用自定义的 Behavior 类。</p>
<p>在具体实现上，不同的控件根据实现效果还要考虑 IPC 过程，动画效果，触摸事件等。</p>
<h2 id="Toast"><a href="#Toast" class="headerlink" title="Toast"></a>Toast</h2><p>Toast 是一个系统提供的提示性控件，<strong>本质和 PopupWindow 一样，是在 Window 上添加和移除 View</strong>，所以最重要的是设置 View，否则显示的时候将出现异常。它的使用分为两步</p>
<p>1.构造。</p>
<p>常用的 makeText 方法即构造了一个只包括 TextView 的布局，<strong>如果要设置文本，必须将其 id 设置为android.R.id.message。</strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> Toast <span class="title">makeText</span><span class="params">(Context context, CharSequence text, @Duration <span class="keyword">int</span> duration)</span> </span>&#123;</span><br><span class="line">    Toast result = <span class="keyword">new</span> Toast(context);</span><br><span class="line">    View v = inflate.inflate(com.android.internal.R.layout.transient_notification, <span class="keyword">null</span>);</span><br><span class="line">    TextView tv = (TextView)v.findViewById(com.android.internal.R.id.message);</span><br><span class="line">    tv.setText(text);</span><br><span class="line">    </span><br><span class="line">    result.mNextView = v;</span><br><span class="line">    result.mDuration = duration;</span><br><span class="line">    <span class="keyword">return</span> result;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>2.显示。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">show</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (mNextView == <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> RuntimeException(<span class="string">"setView must have been called"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    tn.mNextView = mNextView;</span><br><span class="line">    INotificationManager service = getService();</span><br><span class="line">    String pkg = mContext.getOpPackageName();</span><br><span class="line">    TN tn = mTN;</span><br><span class="line">    service.enqueueToast(pkg, tn, mDuration);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>显示的过程是一个 IPC 过程，这是为了避免与其他应用的 Toast 冲突。显示 Toast 依靠 Handler 来实现，本质是通过 WindowManager 服务添加 mNextView 来实现的。<strong>Toast 可以配置的参数都应用在WindowManager.LayoutParams 上。 包括 gravity，偏移量，margin等。</strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">WindowManager mWM = (WindowManager)context.getSystemService(Context.WINDOW_SERVICE);</span><br><span class="line">mParams.gravity = gravity;</span><br><span class="line">mWM.addView(mView, mParams);</span><br></pre></td></tr></table></figure>
<h3 id="自定义View"><a href="#自定义View" class="headerlink" title="自定义View"></a>自定义View</h3><p>因为可以设置 View，故而可以通过自定义 View 来实现各种效果，甚至可以通过 onAttachedToWindow 方法来获得动画效果。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">onAttachedToWindow</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">super</span>.onAttachedToWindow();</span><br><span class="line">    ValueAnimator va = ValueAnimator.ofInt(Color.GREEN, Color.CYAN).setDuration(<span class="number">1500</span>);</span><br><span class="line">    va.addUpdateListener(<span class="keyword">new</span> ValueAnimator.AnimatorUpdateListener() &#123;</span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onAnimationUpdate</span><span class="params">(ValueAnimator animation)</span> </span>&#123;</span><br><span class="line">            drawable.setColor((Integer) animation.getAnimatedValue());</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;);</span><br><span class="line">    va.start();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="SnackBar"><a href="#SnackBar" class="headerlink" title="SnackBar"></a>SnackBar</h2><p>SnackBar 比 Toast 要轻量，它也要防止冲突，但并非通过 IPC 机制来完成。</p>
<p>首先是构建</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> Snackbar <span class="title">make</span><span class="params">(View view, <span class="keyword">int</span> resId, @Duration <span class="keyword">int</span> duration)</span></span></span><br></pre></td></tr></table></figure>
<p>这里的 View 只用来寻找 Parent 布局，或者是 CoordinatorLayout 或者是 android.R.id.content，而后是加载 SnackbarLayout 到布局。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">final</span> ViewGroup mTargetParent;</span><br><span class="line"><span class="keyword">final</span> SnackbarLayout mView;</span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="title">Snackbar</span><span class="params">(ViewGroup parent)</span> </span>&#123;</span><br><span class="line">    mTargetParent = parent;</span><br><span class="line">    mView = (SnackbarLayout) inflater.inflate(</span><br><span class="line">            R.layout.design_layout_snackbar, mTargetParent, <span class="keyword">false</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这个 SnackbarLayout 是一个线性布局，它采用 LayoutInflate 将带 merge 标签的布局加载进自己</p>
<figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">merge</span> <span class="attr">xmlns:android</span>=<span class="string">"http://schemas.android.com/apk/res/android"</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">TextView</span> <span class="attr">android:id</span>=<span class="string">"@+id/snackbar_text"</span>"/&gt;</span></span><br><span class="line">    </span><br><span class="line">    <span class="tag">&lt;<span class="name">Button</span> <span class="attr">android:id</span>=<span class="string">"@+id/snackbar_action"</span></span></span><br><span class="line"><span class="tag">            <span class="attr">android:textColor</span>=<span class="string">"?attr/colorAccent"</span></span></span><br><span class="line"><span class="tag">            <span class="attr">style</span>=<span class="string">"?attr/borderlessButtonStyle"</span>/&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">merge</span>&gt;</span></span><br></pre></td></tr></table></figure>
<p>这样 setAction 方法就是此 Button 点击事件的委托处理，点击将执行 dispatchDismiss 方法，</p>
<p>show 方法交给 SnackbarManager 来处理，这个类管理两个 SnackbarRecord 实例，以避免叠加</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> SnackbarRecord mCurrentSnackbar;</span><br><span class="line"><span class="keyword">private</span> SnackbarRecord mNextSnackbar;</span><br></pre></td></tr></table></figure>
<p>显示的时候，要取消当前，实例化和显示后者，SnackbarRecord 实际就是一个包装了功能的回调，其执行内容为 Callback 的 show 方法。真实的显示方法为</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">final</span> <span class="keyword">void</span> <span class="title">showView</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (mView.getParent() == <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="keyword">final</span> ViewGroup.LayoutParams lp = mView.getLayoutParams();</span><br><span class="line">        <span class="keyword">if</span> (lp <span class="keyword">instanceof</span> CoordinatorLayout.LayoutParams) &#123;</span><br><span class="line">            CoordinatorLayout.LayoutParams clp = (CoordinatorLayout.LayoutParams) lp;</span><br><span class="line">            Behavior behavior = <span class="keyword">new</span> Behavior();</span><br><span class="line">            behavior.setListener(<span class="keyword">new</span> SwipeDismissBehavior.OnDismissListener());</span><br><span class="line">            clp.setBehavior(behavior);</span><br><span class="line">            clp.insetEdge = Gravity.BOTTOM;</span><br><span class="line">        &#125;</span><br><span class="line">        mTargetParent.addView(mView);</span><br><span class="line">        <span class="comment">//使用动画</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这里 SnackbarLayout 将配置上 SwipeDismissBehavior，该类决定了其行为。SwipeDismissBehavior 是一个提供 swipe-to-dismiss 的类，依靠 ViewDragHelper 实现，</p>
<h3 id="FloatingToolbar"><a href="#FloatingToolbar" class="headerlink" title="FloatingToolbar"></a><a href="https://github.com/rubensousa/FloatingToolbar" target="_blank" rel="noopener">FloatingToolbar</a></h3><p>FloatingToolbar 是模仿 Snackbar 实现的一个库。</p>
<img src="/2017/08/20/android/View/一些提示性的控件/demo.gif">
<p>如果将动画放慢，就会发现首先 Fab 先消失(alpha动画)，而后 FloatingToolbar 才扩展出现(scaleX动画)，因此主要的工作是设置和添加布局。</p>
<p>FloatingToolbar 是一个线性布局，可以添加自定义布局，也可以添加菜单。Fab 的点击事件发生后，将执行动画显示；如果再点击菜单中的控件，将执行各自ItemClick，并执行隐藏操作。</p>
<p>FloatingToolbar 的优点还在于考虑了与Snackbar 冲突的情况，通过添加 OnScrollListener 来在 RecyclerView 滑动时隐藏 FloatingToolbar 。</p>
<p><strong>FloatingToolbar 需要在自定义布局，虽然有自由度，但没有 Snackbar 封装的那么好，而且也没有利用Behavior类。</strong></p>
<p>Fab 的点击事件发生后，将执行动画显示；如果再点击菜单中的控件，将执行各自ItemClick，并执行隐藏操作。</p>
<h2 id="Alert"><a href="#Alert" class="headerlink" title="Alert"></a><a href="https://github.com/Tapadoo/Alerter" target="_blank" rel="noopener">Alert</a></h2><img src="/2017/08/20/android/View/一些提示性的控件/alert_default.gif">
<p>与之类似还有<a href="https://github.com/code-mc/loadtoast" target="_blank" rel="noopener">LoadToast</a>， 原理是在 Window 上添加控件，并使用动画来显示。</p>
<h2 id="通知"><a href="#通知" class="headerlink" title="通知"></a><a href="http://hukai.me/android-training-course-in-chinese/ux/notify-user/index.html" target="_blank" rel="noopener">通知</a></h2><p>服务 NotificationManager 将通知展示在状态栏处，属于跨进程通信。</p>
<p>其中 Notification 类是 Parcelable 对象，包装了通知所需的数据，包括关于信息的，关于布局的。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">NotificationManager manager = (NotificationManager) getSystemService(NOTIFICATION_SERVICE);</span><br><span class="line">Notification compat = <span class="keyword">new</span> NotificationCompat.Builder(<span class="keyword">this</span>)</span><br><span class="line">        .setSmallIcon(R.drawable.boot)</span><br><span class="line">        .setContentText(<span class="string">"通知必须有：标题，内容和显示在状态栏的Small图标"</span>)</span><br><span class="line">        .setContentTitle(<span class="string">"标题"</span>)</span><br><span class="line">        .setLargeIcon(BitmapFactory.decodeResource(getResources(), R.drawable.beauty))</span><br><span class="line">        .setSubText(<span class="string">"子标题"</span>)          </span><br><span class="line">        .setCustomBigContentView(remoteViews) <span class="comment">//大图</span></span><br><span class="line">        .setAutoCancel(<span class="keyword">true</span>) <span class="comment">//点击取消</span></span><br><span class="line">        .setTicker(<span class="string">"通知"</span>) <span class="comment">//显示在状态栏的标题</span></span><br><span class="line">        .setDefaults(Notification.DEFAULT_ALL) <span class="comment">//效果</span></span><br><span class="line">        .build();</span><br><span class="line">manager.notify(<span class="string">"like"</span>, <span class="number">6</span>, compat);</span><br></pre></td></tr></table></figure>
<blockquote>
<p>通知必须有：标题，内容和显示在状态栏的Small图标</p>
</blockquote>

        
      
    </div>

    
    
    
      <footer class="post-footer">
          <div class="post-eof"></div>
        
      </footer>
  </div>
  
  
  
  </article>

    
        <article itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block home">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2017/08/18/android/View/与Drawable相关的实践/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="xiang">
      <meta itemprop="description" content="谨守而勿失，是谓反其真">
      <meta itemprop="image" content="/images/1.jpg">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="lxt">
    </span>
      <header class="post-header">
        <h1 class="post-title" itemprop="name headline">
            
            <a href="/2017/08/18/android/View/与Drawable相关的实践/" class="post-title-link" itemprop="url">与Drawable相关的实践</a>
          
        </h1>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              
                
              

              <time title="创建时间：2017-08-18 21:26:26" itemprop="dateCreated datePublished" datetime="2017-08-18T21:26:26+08:00">2017-08-18</time>
            </span>
          
            

            
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="fa fa-calendar-check-o"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2019-09-18 14:22:40" itemprop="dateModified" datetime="2019-09-18T14:22:40+08:00">2019-09-18</time>
              </span>
            
          
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing"><a href="/categories/android/" itemprop="url" rel="index"><span itemprop="name">android</span></a></span>

                
                
                  ，
                
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing"><a href="/categories/android/View/" itemprop="url" rel="index"><span itemprop="name">View</span></a></span>

                
                
              
            </span>
          

          
          <br>
            <span class="post-meta-item" title="本文字数">
              <span class="post-meta-item-icon">
                <i class="fa fa-file-word-o"></i>
              </span>
              
                <span class="post-meta-item-text">本文字数：</span>
              
              <span>4.7k</span>
            </span>
          
            <span class="post-meta-item" title="阅读时长">
              <span class="post-meta-item-icon">
                <i class="fa fa-clock-o"></i>
              </span>
              
                <span class="post-meta-item-text">阅读时长 &asymp;</span>
              
              <span>4 分钟</span>
            </span>
          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <p><strong>Drawable 是 Android 绘制机制的代表</strong>，很多时候实现绘制效果并不需要自定义控件，这里谈谈如何自定义 Drawable 以及如何<strong>产生动画效果</strong>。</p>
<h3 id="自定义Drawable的典型例子：FadeDrawable-Picasso"><a href="#自定义Drawable的典型例子：FadeDrawable-Picasso" class="headerlink" title="自定义Drawable的典型例子：FadeDrawable(Picasso)"></a>自定义Drawable的典型例子：FadeDrawable(Picasso)</h3><p>Picasso 中加载完 Bitmap 后有一个渐显效果，这是通过自定义 FadeDrawable 来实现的，其简单逻辑如下</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">FadeDrawable</span> <span class="keyword">extends</span> <span class="title">BitmapDrawable</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">long</span> mStartTime = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">long</span> mDuration = <span class="number">2000</span>;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">draw</span><span class="params">(Canvas canvas)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">super</span>.draw(canvas);</span><br><span class="line">        <span class="keyword">long</span> time = System.currentTimeMillis() - mStartTime;</span><br><span class="line">        <span class="keyword">if</span>(time&lt;mDuration)&#123;</span><br><span class="line">            <span class="keyword">int</span> alpha = (<span class="keyword">int</span>) (<span class="number">255</span> * max(<span class="number">0</span>, time) / mDuration);</span><br><span class="line">            setAlpha(alpha);</span><br><span class="line">            invalidateSelf();</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            setAlpha(<span class="number">255</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">fade</span><span class="params">()</span></span>&#123;</span><br><span class="line">        mStartTime = System.currentTimeMillis();</span><br><span class="line">        invalidateSelf();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这样调用 fade() 方法后，在两秒内将有一个渐显得动画效果出现。</p>
<p>实际上这个效果还可以通过属性动画来实现</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">ValueAnimator va = ValueAnimator.ofInt(<span class="number">0</span>, <span class="number">255</span>).setDuration(<span class="number">2000</span>);</span><br><span class="line">va.addUpdateListener(<span class="keyword">new</span> ValueAnimator.AnimatorUpdateListener() &#123;</span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onAnimationUpdate</span><span class="params">(ValueAnimator animation)</span> </span>&#123;</span><br><span class="line">                bitmapDrawable.setAlpha((Integer) animation.getAnimatedValue());</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);</span><br><span class="line">va.start();</span><br></pre></td></tr></table></figure>
<p>这是通过操纵 bitmapDrawable 对象来实现的，实际还可以直接操作 ImageView 控件来实现。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">mImageView.animate().alpha(<span class="number">1f</span>).withLayer().setDuration(<span class="number">2000</span>).start();</span><br></pre></td></tr></table></figure>
<p>这三种方法第三种间接，第一种封装性好，适合广泛性。</p>
<blockquote>
<p>自定义 Drawable 的典型方法就是通过<strong>设置参数来控制绘制效果</strong>，既可以<strong>通过设置条件来终结重绘过程，亦可以直接使用属性动画。</strong></p>
</blockquote>
<h3 id="PathDrawable-及动画"><a href="#PathDrawable-及动画" class="headerlink" title="PathDrawable 及动画"></a>PathDrawable 及动画</h3><p><strong>通过构建路径具备相当的灵活性，可以实现什么绘制效果主要取决于想象力。</strong></p>
<p>应该注意到路径的初始化应该放在如下方法中</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">onBoundsChange</span><span class="params">(Rect bounds)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">super</span>.onBoundsChange(bounds);</span><br><span class="line">    createPath();</span><br></pre></td></tr></table></figure>
<p>其次记录路径的描述点最好使用二维数组</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">float</span>[][] as = <span class="keyword">new</span> <span class="keyword">float</span>[<span class="number">2</span>][<span class="number">5</span>];</span><br></pre></td></tr></table></figure>
<p>这样可以便于构建对象的属性对象(Property)</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Property&lt;View, <span class="keyword">float</span>[][]&gt; mBProperty = <span class="keyword">new</span> Property&lt;View, <span class="keyword">float</span>[][]&gt;(<span class="keyword">float</span>[][].class, <span class="string">"bs"</span>)</span><br></pre></td></tr></table></figure>
<p>例如抽屉控件中的 DrawerArrowDrawable 就是一个典型的 PathDrawable，且有动画效果。它的绘制效果是绘制三条线，同时采用一个 process 参数(float)来控制线的起始位置和长度，以及旋转角度。其实现可以简化为</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">draw</span><span class="params">(Canvas canvas)</span> </span>&#123;</span><br><span class="line">    Rect bounds = getBounds();</span><br><span class="line">    <span class="keyword">int</span> width = bounds.width();</span><br><span class="line">    <span class="keyword">int</span> height = bounds.height();</span><br><span class="line">    <span class="keyword">float</span> midX = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">float</span> midY = bounds.centerY();</span><br><span class="line">    <span class="keyword">float</span> topY = lerp(midY - height / <span class="number">3</span>, midY, mProgress);</span><br><span class="line">    <span class="keyword">float</span> botY = lerp(midY + height / <span class="number">3</span>, midY, mProgress);</span><br><span class="line">    <span class="keyword">float</span> dx = lerp(width, width / <span class="number">2</span>, mProgress);</span><br><span class="line">    mPath.rewind();</span><br><span class="line">    <span class="comment">// draw middle bar</span></span><br><span class="line">    mPath.moveTo(midX, midY);</span><br><span class="line">    mPath.rLineTo(width, <span class="number">0</span>);</span><br><span class="line">    <span class="comment">// bottom bar</span></span><br><span class="line">    mPath.moveTo(midX, botY);</span><br><span class="line">    mPath.rLineTo(dx, midY + height / <span class="number">3</span> - botY);</span><br><span class="line">    <span class="comment">// top bar</span></span><br><span class="line">    mPath.moveTo(midX, topY);</span><br><span class="line">    mPath.rLineTo(dx, midY - height / <span class="number">3</span> - topY); </span><br><span class="line">    mPath.close();</span><br><span class="line">    canvas.save();</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">float</span> rotate = lerp(<span class="number">0</span>, <span class="number">270</span>, mProgress);  <span class="comment">//将 Path 旋转，区间为[0, 270]</span></span><br><span class="line">    canvas.rotate(rotate, bounds.centerX(), bounds.centerY());</span><br><span class="line">    canvas.drawPath(mPath, mPaint);</span><br><span class="line">    canvas.restore();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这样绘制路径就被 mProcess 参数完全控制了，可以对其使用属性动画。</p>
<h3 id="TextDrawable"><a href="#TextDrawable" class="headerlink" title="TextDrawable"></a><a href="https://github.com/amulyakhare/TextDrawable" target="_blank" rel="noopener">TextDrawable</a></h3><img src="/2017/08/18/android/View/与Drawable相关的实践/screen1-material.png">
<p>TextDrawable 继承 ShapeDrawable，它之所以能够绘制文字和底边是使用 Paint 的结果，绘制文字的核心代码如下</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">draw</span><span class="params">(Canvas canvas)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">super</span>.draw(canvas);</span><br><span class="line">    Rect r = getBounds();</span><br><span class="line">    <span class="keyword">int</span> count = canvas.save();</span><br><span class="line">    canvas.translate(r.left, r.top);</span><br><span class="line">    <span class="keyword">int</span> width = <span class="keyword">this</span>.width &lt; <span class="number">0</span> ? r.width() : <span class="keyword">this</span>.width;</span><br><span class="line">    <span class="keyword">int</span> height = <span class="keyword">this</span>.height &lt; <span class="number">0</span> ? r.height() : <span class="keyword">this</span>.height; </span><br><span class="line">    <span class="comment">//字体尺寸不超过高度的一半</span></span><br><span class="line">    <span class="keyword">int</span> fontSize = <span class="keyword">this</span>.fontSize &lt; <span class="number">0</span> ? (Math.min(width, height) / <span class="number">2</span>) : <span class="keyword">this</span>.fontSize;</span><br><span class="line">    textPaint.setTextSize(fontSize);</span><br><span class="line">    canvas.drawText(text, width / <span class="number">2</span>, height / <span class="number">2</span> - ((textPaint.descent() + textPaint.ascent()) / <span class="number">2</span>), textPaint);</span><br><span class="line">    canvas.restoreToCount(count);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这里画笔的对齐方式设置成居中 Paint.Align.CENTER，绘制点在水平方向上位于半宽度，<strong>在垂直方向上需要得到 baselinde 的位置，而不是垂直居中的位置。</strong></p>
<p><strong>以字体尺寸为 24sp 的 Paint 而言，其 ascent 值为 -22.265625， descent 值为 5.859375，二者的差值即为从中线向下的偏移量。</strong></p>
<p>该库的使用时应该有个有意思的点：</p>
<p><strong>1.用两个 TextDrawable 合成 LayerDrawable，造成各占据一边的结果</strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">Drawable[] layerList = &#123;</span><br><span class="line">        <span class="keyword">new</span> InsetDrawable(left, <span class="number">0</span>, <span class="number">0</span>, toPx(<span class="number">31</span>), <span class="number">0</span>),</span><br><span class="line">        <span class="keyword">new</span> InsetDrawable(right, toPx(<span class="number">31</span>), <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>)</span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">return</span> <span class="keyword">new</span> LayerDrawable(layerList);</span><br></pre></td></tr></table></figure>
<p><strong>2.形成 AnimationDrawable 帧动画。</strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">AnimationDrawable animationDrawable = <span class="keyword">new</span> AnimationDrawable();</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">10</span>; i &gt; <span class="number">0</span>; i--) &#123;</span><br><span class="line">    TextDrawable frame = builder.build(String.valueOf(i), mGenerator.getRandomColor());</span><br><span class="line">    animationDrawable.addFrame(frame, <span class="number">1200</span>);</span><br><span class="line">&#125;</span><br><span class="line">animationDrawable.setOneShot(<span class="keyword">false</span>);</span><br><span class="line">animationDrawable.start();</span><br></pre></td></tr></table></figure>
<blockquote>
<p>这样实现的动画效果，实际并不聪明，浪费内存。</p>
</blockquote>
<h2 id="MaterialProgressDrawable-SwipeRefreshLayout"><a href="#MaterialProgressDrawable-SwipeRefreshLayout" class="headerlink" title="MaterialProgressDrawable(SwipeRefreshLayout)"></a>MaterialProgressDrawable(SwipeRefreshLayout)</h2><p>MaterialProgressDrawable 是一个典型的循环动画 Drawable，</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">draw</span><span class="params">(Canvas c)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">final</span> Rect bounds = getBounds();</span><br><span class="line">    <span class="keyword">final</span> <span class="keyword">int</span> saveCount = c.save();</span><br><span class="line">    c.rotate(mRotation, bounds.exactCenterX(), bounds.exactCenterY());</span><br><span class="line">    mRing.draw(c, bounds);</span><br><span class="line">    c.restoreToCount(saveCount);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>从绘制方法上看，动画效果是通过rotate操作达成的，具体绘制委托给了 Ring 对象。</p>

        
      
    </div>

    
    
    
      <footer class="post-footer">
          <div class="post-eof"></div>
        
      </footer>
  </div>
  
  
  
  </article>

    
        <article itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block home">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2017/08/16/android/View/View和ViewGroup/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="xiang">
      <meta itemprop="description" content="谨守而勿失，是谓反其真">
      <meta itemprop="image" content="/images/1.jpg">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="lxt">
    </span>
      <header class="post-header">
        <h1 class="post-title" itemprop="name headline">
            
            <a href="/2017/08/16/android/View/View和ViewGroup/" class="post-title-link" itemprop="url">View和ViewGroup</a>
          
        </h1>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              
                
              

              <time title="创建时间：2017-08-16 21:26:26" itemprop="dateCreated datePublished" datetime="2017-08-16T21:26:26+08:00">2017-08-16</time>
            </span>
          
            

            
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="fa fa-calendar-check-o"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2019-09-18 14:06:39" itemprop="dateModified" datetime="2019-09-18T14:06:39+08:00">2019-09-18</time>
              </span>
            
          
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing"><a href="/categories/android/" itemprop="url" rel="index"><span itemprop="name">android</span></a></span>

                
                
                  ，
                
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing"><a href="/categories/android/View/" itemprop="url" rel="index"><span itemprop="name">View</span></a></span>

                
                
              
            </span>
          

          
          <br>
            <span class="post-meta-item" title="本文字数">
              <span class="post-meta-item-icon">
                <i class="fa fa-file-word-o"></i>
              </span>
              
                <span class="post-meta-item-text">本文字数：</span>
              
              <span>21k</span>
            </span>
          
            <span class="post-meta-item" title="阅读时长">
              <span class="post-meta-item-icon">
                <i class="fa fa-clock-o"></i>
              </span>
              
                <span class="post-meta-item-text">阅读时长 &asymp;</span>
              
              <span>19 分钟</span>
            </span>
          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h2 id="位置与尺寸"><a href="#位置与尺寸" class="headerlink" title="位置与尺寸"></a>位置与尺寸</h2><p>1.关于控件的位置，有left，translationX 和 X三种，他们都和 RenderNode 有关，计算公式为</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">float</span> <span class="title">getX</span><span class="params">()</span> </span>&#123;    </span><br><span class="line">    <span class="keyword">return</span> mLeft + getTranslationX();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>为什么要在View中搞出这么多变量呢？</p>
<p>如果只变更 left，则只是左边界的变化，View 的视觉宽度将发生变化；TranslationX 则能够产生平移的效果，它同时附加在 left 和 right 上。</p>
<p>实际上同时移动 left 和right 相同的距离，也能达到平移的效果，类似于ViewCompat.offsetLeftAndRight 造成的效果，但这个与 TranslationX 实现的平移效果有所区别。</p>
<p>实际上同时移动 left 和right 相同的距离，也能达到平移的效果，类似于 ViewCompat.offsetLeftAndRight 造成的效果，但这个与 TranslationX 实现的平移效果有所区别。</p>
<p>前者只是非常机械的渲染效果，只要碰上 requestLayout 方法就复原了，后者的平移在重新布局后仍然有效。而且只变更left不会考虑一些类似于居中的要求，控件在变化过程中往往就“失真’’了。</p>
<p>如果确实要改变控件的宽度，应该从 LayoutParams.width 入手，修改此值，并调用方法，控件会重新进行测量。</p>
<p>2.再来说说 mScrollX/mScrollY ，它们只影响内容的绘制，不会影响背景 Drawable 的绘制，实际是通过对内容区域加偏移造成，最终的绘制效果是偏移后的内容区域与原本区域的。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">invalidate</span><span class="params">(Rect dirty)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">final</span> <span class="keyword">int</span> scrollX = mScrollX;</span><br><span class="line">    <span class="keyword">final</span> <span class="keyword">int</span> scrollY = mScrollY;</span><br><span class="line">    invalidateInternal(dirty.left - scrollX, dirty.top - scrollY,</span><br><span class="line">            dirty.right - scrollX, dirty.bottom - scrollY, <span class="keyword">true</span>, <span class="keyword">false</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>3.此外还可以使用动画来改变控件位置，属性动画就不提了，值得一提的是补间动画，默认的四种补间动画采用Transformation里的矩阵来操作渲染结果，但并不真的改变属性，如果要达成属性动画的效果，可以利用下面的方法</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setFillBefore</span><span class="params">(<span class="keyword">boolean</span> fillBefore)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setFillAfter</span><span class="params">(<span class="keyword">boolean</span> fillAfter)</span></span>;</span><br></pre></td></tr></table></figure>
<p>最后评价下各种操作的性能</p>
<ul>
<li>left 虽然是RenderNode实现，但需要 CPU 更新 displayList，调用和递归多(56/1022)，GPU监视上蓝色部分长</li>
<li>translationX 基本无更新 displayList 的调用和递归存在，蓝线几乎没有，耗时极少</li>
<li>LayoutParams 除非测量事件，耗时验证</li>
<li>offset ，耗时极少</li>
<li>animation 更新 displayList极多</li>
<li>animtor 不更新 displayList，快</li>
</ul>
<h3 id="layout-机制与-LayoutParams"><a href="#layout-机制与-LayoutParams" class="headerlink" title="layout_* 机制与 LayoutParams"></a>layout_* 机制与 LayoutParams</h3><p>layout<em>*机制通过内部类 LayoutParams 中定义以 layout</em>为前缀的属性供子控件使用，从而控制子控件的行为，这些属性并不为布局类自己所使用。以AppBarLayout为例</p>
<figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">android.support.design.widget.AppBarLayout</span>&gt;</span></span><br><span class="line">  </span><br><span class="line">  <span class="tag">&lt;<span class="name">android.support.v7.widget.Toolbar</span></span></span><br><span class="line"><span class="tag">    <span class="attr">app:layout_scrollFlags</span>=<span class="string">"scroll|enterAlways"</span> /&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">android.support.design.widget.AppBarLayout</span> &gt;</span></span><br></pre></td></tr></table></figure>
<p>Toolbar 本身并没有 layout<em>scrollFlags 属性，该属性定义在类 AppBarLayout.LayoutParams 中，加前缀 layout</em>表示这是一个父布局定义而子控件使用的属性。虽然这个属性是由容器来读取 XML文件进行解析和实例化的。</p>
<p>最广泛最著名的属性来自于 ViewGroup.LayoutParams 中的属性：layout_width 与 layout_height， 是容器用来约束子控件的宽度和高度的，ViewGroup.MarginLayoutParams 增加了6个margin属性，如果采用这种 LayoutParams，就能够给子控件设置 layout__margin属性，容器会在布局时利用这个属性。</p>
<p>自定义 LayoutParams 需要覆盖以下4个方法，这些方法是为子控件生成 LayoutParams 对象所必须的</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">boolean</span> <span class="title">checkLayoutParams</span><span class="params">(ViewGroup.LayoutParams p)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> p <span class="keyword">instanceof</span> LayoutParams;</span><br><span class="line">&#125;</span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> LayoutParams <span class="title">generateLayoutParams</span><span class="params">(AttributeSet attrs)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> LayoutParams(getContext(), attrs);</span><br><span class="line">&#125;</span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">protected</span> LayoutParams <span class="title">generateDefaultLayoutParams</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> LayoutParams(LayoutParams.MATCH_PARENT, LayoutParams.WRAP_CONTENT);</span><br><span class="line">&#125;</span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">protected</span> LayoutParams <span class="title">generateLayoutParams</span><span class="params">(ViewGroup.LayoutParams p)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> LayoutParams(p);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>实际上布局每添加一个控件，都会采用 generateDefaultLayoutParams() 方法来生成一个 LayoutParams 对象应用在子控件上(见addView方法)。</p>
<p>如果默认产生的 LayoutParams 对象不能通过 checkLayoutParams 方法的检查，则使用 generateLayoutParams 方法来产生 LayoutParams 对象。</p>
<p><strong>因此自定义LayoutParams 时要故意使得 generateDefaultLayoutParams 产生的对象通不过检查，而使用 generateLayoutParams(AttributeSet attrs)产生的 LayoutParams 对象。</strong></p>
<blockquote>
<p>约定 LayoutParams 中解析的属性值均要以 layout_ 开头。</p>
</blockquote>
<h3 id="尺寸测量"><a href="#尺寸测量" class="headerlink" title="尺寸测量"></a>尺寸测量</h3><p>控件的尺寸测量实际比想象的复杂，我们先看系统的默认实现。对于容器而言，除了测量自身，还要考虑测量子控件，这一步往往是调用 measureChild 方法来完成的</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">measureChild</span><span class="params">(View child, <span class="keyword">int</span> parentWidthMeasureSpec,</span></span></span><br><span class="line"><span class="function"><span class="params">        <span class="keyword">int</span> parentHeightMeasureSpec)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">final</span> LayoutParams lp = child.getLayoutParams();</span><br><span class="line">    <span class="keyword">final</span> <span class="keyword">int</span> childWidthMeasureSpec = getChildMeasureSpec(parentWidthMeasureSpec,</span><br><span class="line">            mPaddingLeft + mPaddingRight, lp.width);</span><br><span class="line">    <span class="keyword">final</span> <span class="keyword">int</span> childHeightMeasureSpec = getChildMeasureSpec(parentHeightMeasureSpec,</span><br><span class="line">            mPaddingTop + mPaddingBottom, lp.height);</span><br><span class="line">    child.measure(childWidthMeasureSpec, childHeightMeasureSpec);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><strong>在真正的测量方法前，将对复合尺寸进行重新计算，以求得实际的控件尺寸。</strong>其方法如下</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//spec 的复合尺寸，padding 是控件的留白</span></span><br><span class="line"><span class="comment">//childDimension 是赋给LayoutParams的尺寸，是控件想达到的尺寸，可能是 -1 -2 或 具体数值</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">int</span> <span class="title">getChildMeasureSpec</span><span class="params">(<span class="keyword">int</span> spec, <span class="keyword">int</span> padding, <span class="keyword">int</span> childDimension)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> specMode = MeasureSpec.getMode(spec); <span class="comment">// 容器的尺寸模式</span></span><br><span class="line">    <span class="keyword">int</span> specSize = MeasureSpec.getSize(spec); <span class="comment">// 容器的尺寸大小</span></span><br><span class="line">    <span class="keyword">int</span> size = Math.max(<span class="number">0</span>, specSize - padding); <span class="comment">// 容器的尺寸大小 - 控件的留白 == 控件在容器中的最大尺寸</span></span><br><span class="line">    <span class="keyword">int</span> resultSize = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">int</span> resultMode = <span class="number">0</span>;</span><br><span class="line">	<span class="comment">// 根据 LayoutParams 和 MeasureSpec 确定最终的复合尺寸</span></span><br><span class="line">    <span class="keyword">return</span> MeasureSpec.makeMeasureSpec(resultSize, resultMode);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>控件最终的复合尺寸受到两个因素的影响，即控件自定义的 LayoutParams 和容器的 MeasureSpec。其结果如下表所示</p>
<div class="table-container">
<table>
<thead>
<tr>
<th style="text-align:left">Spec\Params</th>
<th style="text-align:center">MATCH_PARENT</th>
<th style="text-align:center">WRAP_CONTENT</th>
<th style="text-align:center">具体数值(NUM)</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:left"><strong>EXACTLY</strong></td>
<td style="text-align:center"><strong>EXACTLY + size</strong></td>
<td style="text-align:center"><strong>AT_MOST + size</strong></td>
<td style="text-align:center"><strong>EXACTLY+ NUM</strong></td>
</tr>
<tr>
<td style="text-align:left">AT_MOST</td>
<td style="text-align:center">AT_MOST + size</td>
<td style="text-align:center">AT_MOST + size</td>
<td style="text-align:center">EXACTLY + NUM</td>
</tr>
<tr>
<td style="text-align:left">UNSPECIFIED</td>
<td style="text-align:center">UNSPECIFIED + size</td>
<td style="text-align:center">UNSPECIFIED + size</td>
<td style="text-align:center">EXACTLY + NUM</td>
</tr>
</tbody>
</table>
</div>
<blockquote>
<p><strong>实际默认的容器 SpecMode 往往是 EXACTLY，因此关注第一行。子控件设置为 match_parent 和 具体数值时，都将获得 exactly模式，不过尺寸有所差别而已，而 warp_content 的情况较为复杂，其模式为 at_most，尺寸想达到容器尺寸，需要进一步处理。</strong></p>
</blockquote>
<p>而后就是控件自身的测量方法</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">onMeasure</span><span class="params">(<span class="keyword">int</span> widthMeasureSpec, <span class="keyword">int</span> heightMeasureSpec)</span> </span>&#123;</span><br><span class="line">    setMeasuredDimension(getDefaultSize(getSuggestedMinimumWidth(), widthMeasureSpec),</span><br><span class="line">            getDefaultSize(getSuggestedMinimumHeight(), heightMeasureSpec));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>默认情况下的最小尺寸为背景 drawable 的尺寸 ，要在所得的尺寸和这个最小尺寸间做出决定，即 getDefaultSize 方法</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//size 是最小尺寸，measureSpec 是复合尺寸</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">int</span> <span class="title">getDefaultSize</span><span class="params">(<span class="keyword">int</span> size, <span class="keyword">int</span> measureSpec)</span> </span>&#123;&#125;</span><br></pre></td></tr></table></figure>
<p>getDefaultSize 方法将根据复合尺寸的模式得到最终在最小尺寸和复合尺寸间做出选择。</p>
<div class="table-container">
<table>
<thead>
<tr>
<th>specMode</th>
<th style="text-align:center">UNSPECIFIED</th>
<th style="text-align:center">AT_MOST</th>
<th style="text-align:center">EXACTLY</th>
</tr>
</thead>
<tbody>
<tr>
<td>最终尺寸</td>
<td style="text-align:center">size</td>
<td style="text-align:center"><strong>specSize</strong></td>
<td style="text-align:center">specSize</td>
</tr>
</tbody>
</table>
</div>
<p><strong>即仅在容器指定尺寸模式为 UNSPECIFIED 的情况下使用最小尺寸，其余情况可以默认这一步不存在。</strong></p>
<blockquote>
<p>这里有一个问题如果控件采用 warp_content，那么到这一步的 specSize 实际是容器的尺寸。<strong>这说明默认情况下处理 warp_content 是不合理，自定义控件直接继承View时要注意。</strong></p>
</blockquote>
<p>最后就是为测量尺寸 mMeasuredWidth 和 mMeasuredHeight 赋值。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">setMeasuredDimensionRaw</span><span class="params">(<span class="keyword">int</span> measuredWidth, <span class="keyword">int</span> measuredHeight)</span> </span>&#123;</span><br><span class="line">    mMeasuredWidth = measuredWidth;</span><br><span class="line">    mMeasuredHeight = measuredHeight;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="resolveSizeAndState"><a href="#resolveSizeAndState" class="headerlink" title="resolveSizeAndState"></a>resolveSizeAndState</h3><p>刚才说了默认的 measureChild 在碰到子控件设置了 warp_content 时会取容器尺寸的问题，除非子控件不采用默认的自测量方式。这个问题可以用 resolveSizeAndState 方法修复。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> size How big the view wants to be.</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> measureSpec Constraints imposed by the parent.</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> childMeasuredState Size information bit mask for the view's children.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">int</span> <span class="title">resolveSizeAndState</span><span class="params">(<span class="keyword">int</span> size, <span class="keyword">int</span> measureSpec, <span class="keyword">int</span> childMeasuredState)</span></span>;</span><br></pre></td></tr></table></figure>
<div class="table-container">
<table>
<thead>
<tr>
<th>specMode</th>
<th style="text-align:center">AT_MOST</th>
<th style="text-align:center">EXACTLY</th>
<th style="text-align:center">UNSPECIFIED</th>
</tr>
</thead>
<tbody>
<tr>
<td>最终尺寸</td>
<td style="text-align:center"><strong>Min(specSize, size)</strong></td>
<td style="text-align:center">specSize</td>
<td style="text-align:center">size</td>
</tr>
</tbody>
</table>
</div>
<p><strong>resolveSizeAndState 方法和 getDefaultSize 方法不同之处在于如何解析 AT_MOST，这是关键之处。</strong></p>
<p>即将默认的测量方法改为</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">onMeasure</span><span class="params">(<span class="keyword">int</span> widthMeasureSpec, <span class="keyword">int</span> heightMeasureSpec)</span> </span>&#123;</span><br><span class="line">    setMeasuredDimension(</span><br><span class="line">      resolveSizeAndState(getSuggestedMinimumWidth(), widthMeasureSpec, MEASURED_STATE_MASK),</span><br><span class="line">      resolveSizeAndState(getSuggestedMinimumHeight(), heightMeasureSpec, MEASURED_STATE_MASK));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="自定义测量方法"><a href="#自定义测量方法" class="headerlink" title="自定义测量方法"></a>自定义测量方法</h3><p>如果想达到一些其它效果，如在 DrawLayout 中要求内容控件占据容器，实际上在 LayoutParams 上的设置已无任何意义，测量时完全不予考虑，这时就要求抛弃默认的测量方法，去自定义测量方法。</p>
<p><strong>自定义测量方法y要依赖控件的自测量方法，其核心在于在合适的时机改造复合尺寸。</strong></p>
<p>例如要求一个控件占据容器是最容易的情况，此时完全不用考虑容器Spec模式和 LayoutParams 参数。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">mContent.measure(</span><br><span class="line">   MeasureSpec.makeMeasureSpec(</span><br><span class="line">        getMeasuredWidth() - getPaddingLeft() - getPaddingRight(), MeasureSpec.EXACTLY), </span><br><span class="line">   MeasureSpec.makeMeasureSpec(</span><br><span class="line">        getMeasuredHeight() - getPaddingTop() - getPaddingBottom(), MeasureSpec.EXACTLY)</span><br><span class="line">);</span><br></pre></td></tr></table></figure>
<p>在控件内部首先对传入的尺寸进行改造</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">onMeasure</span><span class="params">(<span class="keyword">int</span> widthSpec, <span class="keyword">int</span> heightSpec)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">switch</span> (MeasureSpec.getMode(widthSpec)) &#123;</span><br><span class="line">        <span class="keyword">case</span> MeasureSpec.EXACTLY:</span><br><span class="line">            <span class="comment">// Nothing to do</span></span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        <span class="keyword">case</span> MeasureSpec.AT_MOST:</span><br><span class="line">            widthSpec = MeasureSpec.makeMeasureSpec(</span><br><span class="line">                    Math.min(MeasureSpec.getSize(widthSpec), mMaxWidth), MeasureSpec.EXACTLY);</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        <span class="keyword">case</span> MeasureSpec.UNSPECIFIED:</span><br><span class="line">            widthSpec = MeasureSpec.makeMeasureSpec(mMaxWidth, MeasureSpec.EXACTLY);</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// Let super sort out the height</span></span><br><span class="line">    <span class="keyword">super</span>.onMeasure(widthSpec, heightSpec);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>最要命的情况是要同时处理容器Spec模式和 LayoutParams 参数共九种情况，不过好在遵循 getChildMeasureSpec 方法的套路就行。</p>
<h3 id="布局机制"><a href="#布局机制" class="headerlink" title="布局机制"></a>布局机制</h3><p>布局机制比测量机制要简单地多，但应该注意到布局时会掉用测量过程，此外有时子控件如何布局与 LayoutParams 参数有关，布局时要考虑 padding 和 margin 的影响，获取控件宽度不应该用 LayoutParams.width (可能为负值) 等等。</p>
<h3 id="触摸机制"><a href="#触摸机制" class="headerlink" title="触摸机制"></a>触摸机制</h3><p>触摸机制首先从 Activity 开始，而后有ViewRootImpl传递下去</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">dispatchTouchEvent</span><span class="params">(MotionEvent ev)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (getWindow().superDispatchTouchEvent(ev)) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> onTouchEvent(ev);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><strong>默认的处理流程是一个来回：一半是事件分发(dispatchTouchEvent方法)，一半是事件处理(onTouch 方法)。</strong>其中容器 ViewGroup 和控件 View 的分发方法是不一致的，前者会使用 onInterceptTouchEvent 方法拦截事件，且默认情况下不拦截，逐层交给子控件分发，直到根View；控件 View 的分发会调用事件处理，且会逐级上溯，直到返回 Activity 。</p>
<p>假设布局层级是 TopLayout，BottomLayout 和 CircleImage，则默认情况下流程是</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">//1.向下传递拦截事件</span><br><span class="line">TopLayout onInterceptTouchEvent: false 0</span><br><span class="line">BottomLayout onInterceptTouchEvent: false 0</span><br><span class="line">//2.向上传递处理事件</span><br><span class="line">CircleImage onTouchEvent: false 0</span><br><span class="line">CircleImage dispatchTouchEvent: false 0</span><br><span class="line">BottomLayout onTouchEvent: false 0</span><br><span class="line">BottomLayout dispatchTouchEvent: false 0</span><br><span class="line">TopLayout onTouchEvent: false 0</span><br><span class="line">TopLayout dispatchTouchEvent: false 0</span><br><span class="line">MainActivity onTouchEvent: false 0</span><br><span class="line">MainActivity dispatchTouchEvent: false 0</span><br><span class="line">//3.无人处理</span><br><span class="line">MainActivity onTouchEvent: false 2</span><br><span class="line">MainActivity dispatchTouchEvent: false 2</span><br></pre></td></tr></table></figure>
<p><strong>默认情况下整个流程是不进行拦截的处理的，所以流程会从顶到根走一个来回，但仅能处理 Action_down 的情况，后续的其它动作如Action_Move 等将停留在Activity 中。</strong></p>
<p>如果在 BottomLayout 中截断事件，这里有几种情况。只拦截不处理和默认情况一样。同时拦截和处理结果如下</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">TopLayout onInterceptTouchEvent: false ACTION_DOWNBottomLayout onInterceptTouchEvent: true ACTION_DOWN //拦截方法只能执行一次BottomLayout onTouchEvent: true ACTION_DOWNBottomLayout dispatchTouchEvent: true ACTION_DOWNTopLayout dispatchTouchEvent: true ACTION_DOWNMainActivity dispatchTouchEvent: true ACTION_DOWNTopLayout onInterceptTouchEvent: false ACTION_MOVE  //父布局的拦截方法倒是能多次执行BottomLayout onTouchEvent: true ACTION_MOVEBottomLayout dispatchTouchEvent: true ACTION_MOVETopLayout dispatchTouchEvent: true ACTION_MOVE //消灭这一行，禁止 TopLayout 拦截MainActivity dispatchTouchEvent: true ACTION_MOVETopLayout onInterceptTouchEvent: false ACTION_UPBottomLayout onTouchEvent: true ACTION_UPBottomLayout dispatchTouchEvent: true ACTION_UPTopLayout dispatchTouchEvent: true ACTION_UPMainActivity dispatchTouchEvent: true ACTION_UP</span><br></pre></td></tr></table></figure>
<p>即流程到 BottomLayout 这一层被截断了，如果要 TopLayout 不进行拦截，可以使用下列方法</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">getParent().requestDisallowInterceptTouchEvent(<span class="keyword">true</span>);</span><br></pre></td></tr></table></figure>
<p>如果不拦截，只处理结果如下</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">TopLayout onInterceptTouchEvent: false 0BottomLayout onInterceptTouchEvent: false 0CircleImage onTouchEvent: false 0CircleImage dispatchTouchEvent: false 0BottomLayout onTouchEvent: true 0BottomLayout dispatchTouchEvent: true 0TopLayout dispatchTouchEvent: true 0MainActivity dispatchTouchEvent: true 0TopLayout onInterceptTouchEvent: false 2BottomLayout onTouchEvent: true 2BottomLayout dispatchTouchEvent: true 2TopLayout dispatchTouchEvent: true 2MainActivity dispatchTouchEvent: true 2TopLayout onInterceptTouchEvent: false 1BottomLayout onTouchEvent: true 1BottomLayout dispatchTouchEvent: true 1TopLayout dispatchTouchEvent: true 1MainActivity dispatchTouchEvent: true 1</span><br></pre></td></tr></table></figure>
<p><strong>区别是下面的子控件还能得到一次处理的机会， 否则即便子控件设置了处理方法，也不会得到执行机会。当然如果子控件不处理，那么以后依然将会被屏蔽。</strong></p>
<blockquote>
<p>监听器是事件处理的特殊情况，如果配置了监听器，等同于设置了事件处理。如果容器和子控件都配置了监听器，那么按照事件处理的顺序是子控件优先截断控制权；容器如果想夺回控制权，只能使用拦截方法进行拦截。</p>
</blockquote>
<h3 id="修改触摸机制"><a href="#修改触摸机制" class="headerlink" title="修改触摸机制"></a>修改触摸机制</h3><p><strong>修改触摸机制的核心是确定那个控件在哪种情况下能够进行拦截和消费事件，这样使得不同的控件都有机会处理触摸事件。</strong></p>
<p>先说下可以着手的三个地方</p>
<ul>
<li><strong>onInterceptTouchEvent 方法：返回 true，则事件不再向下分发，即屏蔽了子控件，使得子控件设置的点击事件失效，因此要谨慎使用。此外如果容器消费了事件，该方法只执行一次。</strong></li>
<li>onTouchEvent 方法：返回 true，则此后的处理流程就到这一层。</li>
<li>dispatchTouchEvent 方法：返回 true，<strong>此时不管*onTouchEvent 方法如何，都能形成闭合流程。</strong></li>
</ul>
<p>例如我们要求在 TopLayout 中拦截左右滑动，在 BottomLayout 中拦截 上下滑动，同时也要保证 CircleImage 能够响应点击事件。</p>
<p>三个控件都要能拦截事件，这就要求它们各自精确拦截自己的那一部分。</p>
<p><strong>首先给 CircleImage 设置一个监听器，此时事件是到 CircleImage 这里得到处理的，但TopLayout 和 BottomLayout 还有拦截事件的机会。</strong></p>
<p><strong>再来改造 TopLayout ，前提是不能拦截 ACTION_DOWN 和 ACTION_UP，这样就屏蔽了子控件的点击监听，这两个动作里只能做一些初始化和清理的工作。而后在 ACTION_MOVE 中进行拦截</strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">onInterceptTouchEvent</span><span class="params">(MotionEvent ev)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">boolean</span> isIntercept = <span class="keyword">false</span>;</span><br><span class="line">    <span class="keyword">int</span> action = ev.getAction();</span><br><span class="line">    <span class="keyword">switch</span> (action) &#123;</span><br><span class="line">        <span class="keyword">case</span> MotionEvent.ACTION_DOWN:</span><br><span class="line">            isIntercept = <span class="keyword">false</span>;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        <span class="keyword">case</span> MotionEvent.ACTION_MOVE:</span><br><span class="line">            <span class="keyword">if</span> (<span class="string">"左右滑动"</span>) &#123;</span><br><span class="line">                isIntercept = <span class="keyword">true</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        <span class="keyword">case</span> MotionEvent.ACTION_UP:</span><br><span class="line">        <span class="keyword">default</span>:</span><br><span class="line">            isIntercept = <span class="keyword">false</span>;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> isIntercept;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>还有在 onTouchEvent 方法里也不能在 ACTION_DOWN 和 ACTION_UP 里进行事件的处理，这样也会导致子控件的点击事件失效。只能在 ACTION_MOVE 进行相同条件下的处理，这样才能构成闭环处理流程。</p>
<p>最后是 BottomLayout ，和TopLayout 类似，只需要改一下拦截和处理的条件。</p>
<blockquote>
<p>这里三个控件都要获得拦截事件的机会，底层的控件尤其重要，它要求响应点击事件的特性使得父控件无法拦截和处理 ACTION_DOWN 和 ACTION_UP。父控件之间更是不得不小心翼翼，避免彼此之间的冲突。</p>
</blockquote>
<h4 id="实践：点击控件带扩张效果"><a href="#实践：点击控件带扩张效果" class="headerlink" title="实践：点击控件带扩张效果"></a>实践：点击控件带扩张效果</h4><p><img src="https://cloud.githubusercontent.com/assets/24237865/22188970/cc138f6a-e15c-11e6-8a17-a8bccb3e6dcd.gif" alt="ElasticViews"></p>
<p>要达成这样的效果，且要求保留子控件的点击事件，实际上不需要进行事件的拦截，只需要在 dispatchTouchEvent 中添加一个动画即可。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">dispatchTouchEvent</span><span class="params">(MotionEvent event)</span> </span>&#123;</span><br><span class="line">    <span class="comment">//只处理 ACTION_UP，防止执行多个动画，造成View参数紊乱</span></span><br><span class="line">    <span class="keyword">if</span>(event.getAction() == MotionEvent.ACTION_UP) &#123; </span><br><span class="line">        ViewCompat.animate(view).setDuration(duration)</span><br><span class="line">          .scaleX(scale).scaleY(scale).setInterpolator(<span class="keyword">new</span> CycleInterpolator(<span class="number">0.5f</span>))</span><br><span class="line">          .withLayer()</span><br><span class="line">          .start();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">super</span>.dispatchTouchEvent(event);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<blockquote>
<p>这里要注意的是如果容器即其子控件不设置点击事件监听器，那么可以不加第一行，因为此时dispatchTouchEvent只执行一次，在ACTION_DOWN之后就被屏蔽了；</p>
<p>然而这过于理想了，一旦有一个子控件拦截的事件，将造成多个动画同时执行，View的scale参数将紊乱。因此为了安全，需要添加第一行。</p>
</blockquote>
<h4 id="MotionEvent和手势"><a href="#MotionEvent和手势" class="headerlink" title="MotionEvent和手势"></a>MotionEvent和手势</h4><p>动作包含动作码和坐标集合两个部分，前者表示是按下还是离开等；此外多触摸屏幕还可以响应多个手指，其中只能有一个起作用的，即常见的 mActivePointerId。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">final</span> <span class="keyword">int</span> action = MotionEventCompat.getActionMasked(event);</span><br><span class="line"><span class="keyword">final</span> <span class="keyword">int</span> actionIndex = MotionEventCompat.getActionIndex(event);</span><br><span class="line"><span class="keyword">int</span> pointerCount = event.getPointerCount();</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; pointerCount; i++) &#123;</span><br><span class="line">    <span class="keyword">int</span> pointerId = event.getPointerId(i);</span><br><span class="line">    <span class="keyword">float</span> x = event.getX(actionIndex);</span><br><span class="line">    <span class="keyword">float</span> y = event.getY(actionIndex);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<blockquote>
<p>手势库：<a href="https://github.com/nisrulz/sensey" target="_blank" rel="noopener">Sensey</a></p>
</blockquote>
<h3 id="滚动机制-Scroller"><a href="#滚动机制-Scroller" class="headerlink" title="滚动机制(Scroller)"></a>滚动机制(Scroller)</h3><p><strong>scrollTo 方法就能够使得控件内容移位，其原理是改变参数 mScrollX/mScrollY ，这两个数值会在绘制的时候移动绘制区域，这是滚动机制的基础。</strong></p>
<p><strong>scrollTo 方法的问题在于滚动花费的时间太短，Scroller 通过拉长这个时间带来平滑的视觉效果，具体做法是将整个过程拆分成若干的步进过程，逐步改变 mScrollX/mScrollY 的数值。</strong></p>
<p>Scroller 类本身是一个纯属性类，只需要传入滑动时间，起始值等描述一次滑动过程的必要参数。但它并不能直接滑动控件，想要滑动控件需要与具体控件配合驱动步进计算。Scroller类的手动更新方法是</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//1.启动滚动过程</span></span><br><span class="line">mScroller.startScroll(getScrollX(), getScrollY(), <span class="number">100</span>, <span class="number">100</span>);</span><br><span class="line">invalidate();</span><br><span class="line"><span class="comment">//2.自我驱动</span></span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">computeScroll</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (mScroller != <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="keyword">if</span> (mScroller.computeScrollOffset()) &#123;                    <span class="comment">//判断是否完成</span></span><br><span class="line">            scrollTo(mScroller.getCurrX(), mScroller.getCurrY()); <span class="comment">//实现滚动的一小步 </span></span><br><span class="line">            setAlpha(<span class="number">1f</span>*scroller.getCurrX()/scroller.getFinalX());<span class="comment">//附加效果</span></span><br><span class="line">            postInvalidate();                                     <span class="comment">//实现滚动循环</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>
<p><strong>这里达成真实的滚动效果是靠改变控件 mScrollX/mScrollY 位置来产生的，完全可以考改变其它属性来达成其它动画效果。</strong></p>
<p>为了兼容性，可以使用类ScrollerCompat代替实现，该类还提供了fling 和 springback 两种滑动方式。</p>
<h3 id="绘制机制与动画机制"><a href="#绘制机制与动画机制" class="headerlink" title="绘制机制与动画机制"></a>绘制机制与动画机制</h3><p>View 的实际绘制区域与布局区域是不一致的，它与 mScrollX/mScrollY 有关</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">getDrawingRect</span><span class="params">(Rect outRect)</span> </span>&#123;    </span><br><span class="line">    outRect.left = mScrollX;    </span><br><span class="line">    outRect.top = mScrollY;    </span><br><span class="line">    outRect.right = mScrollX + (mRight - mLeft);    </span><br><span class="line">    outRect.bottom = mScrollY + (mBottom - mTop);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><strong>在 onDraw 方法上添加附加效果是一种常用的手段。</strong></p>
<p>View 可以执行三种动画</p>
<p>1.补间动画</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">startAnimation</span><span class="params">(Animation animation)</span></span></span><br></pre></td></tr></table></figure>
<p>2.状态转移动画</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setStateListAnimator</span><span class="params">(StateListAnimator stateListAnimator)</span></span>;</span><br></pre></td></tr></table></figure>
<p>3.属性动画</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> ViewPropertyAnimator <span class="title">animate</span><span class="params">()</span></span>;</span><br></pre></td></tr></table></figure>
<h4 id="EdgeEffect"><a href="#EdgeEffect" class="headerlink" title="EdgeEffect"></a>EdgeEffect</h4><p>EdgeEffect 是用来绘制边界阴影的，它的实质是画一个弧顶过某边的圆，同时截取弧顶部分。默认情况下绘制的顶边。</p>
<p>通过 onPull, onAbsorb 方法，EdgeEffect 可以控制弧顶漏出的比例，这是纯属性设置的方法，必须刷新绘制才能生效。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onPull</span><span class="params">(<span class="keyword">float</span> deltaDistance, <span class="keyword">float</span> displacement)</span></span></span><br></pre></td></tr></table></figure>
<p>通过 onRelease 方法可以产生回弹，这与Scroll 自我驱动更新的原理是一样的</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">draw</span><span class="params">(Canvas canvas)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">super</span>.draw(canvas);</span><br><span class="line">    edge.setSize(getWidth(), getHeight());</span><br><span class="line">    <span class="keyword">if</span> (!edge.isFinished()) &#123;</span><br><span class="line">        <span class="keyword">final</span> <span class="keyword">int</span> restoreCount = canvas.save();</span><br><span class="line">        <span class="keyword">if</span>(edge.draw(canvas))&#123;</span><br><span class="line">            postInvalidate();</span><br><span class="line">        &#125;</span><br><span class="line">        canvas.restoreToCount(restoreCount);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>在实际的使用中，应该给每一个边设置一个 EdgeEffectCompat , 这需要移位，旋转等操作 。以右边为例</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">canvas.rotate(<span class="number">90</span>); <span class="comment">//画布旋转90度，意味着坐标轴也偏移了90度，</span></span><br><span class="line">canvas.translate(<span class="number">0</span>,-getWidth()); <span class="comment">//此时 y 轴实际是向左，故而反向回退一个宽度，矫正弧顶矩形</span></span><br><span class="line">edge.setSize(getHeight(), getWidth());</span><br></pre></td></tr></table></figure>
<p>左边</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">canvas.rotate(<span class="number">270</span>); <span class="comment">//画布旋转270度，此时y轴向右</span></span><br><span class="line">canvas.translate(-getHeight(), <span class="number">0</span>);<span class="comment">//弧顶矩形需要下移</span></span><br><span class="line">edge.setSize(getHeight(), getWidth());</span><br></pre></td></tr></table></figure>
<p>下边</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">canvas.rotate(<span class="number">180</span>);</span><br><span class="line">canvas.translate(-getWidth(), -getHeight());</span><br><span class="line">edge.setSize(getWidth(), getHeight());</span><br></pre></td></tr></table></figure>
<h3 id="SurfaceView"><a href="#SurfaceView" class="headerlink" title="SurfaceView"></a><a href="http://blog.csdn.net/luoshengyang/article/details/8661317" target="_blank" rel="noopener">SurfaceView</a></h3><p>SurfaceView 在一个独立的线程中进行绘制，不在主线程中不会占用主线程资源，一方面可以实现复杂而高效的UI，另一方面又不会导致用户输入得不到及时响应。由于应用程序的主线程除了要绘制UI之外，还需要及时地响应用户输入，否则的话，系统就会认为应用程序没有响应了，因此就会弹出一个ANR对话框出来。对于一些游戏画面就不适合在应用程序的主线程中进行绘制。这时候就可以使用 SurfaceView 。一个Surface绘图示例如下</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">SurfaceView surfaceView = (SurfaceView) findViewById(R.id.surfaceview);</span><br><span class="line"><span class="comment">//1. 获取 SurfaceView 对象内部类SurfaceHolder</span></span><br><span class="line">SurfaceHolder holder = surfaceView.getHolder();</span><br><span class="line"><span class="comment">//2. SurfaceHolder对象添加Callback接口，执行在UI线程</span></span><br><span class="line">holder.addCallback(<span class="keyword">new</span> SurfaceHolder.Callback() &#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">surfaceCreated</span><span class="params">(SurfaceHolder holder)</span></span></span><br><span class="line"><span class="function">    </span></span><br><span class="line"><span class="function">    <span class="comment">//4.Surface设置参数被改变将调用此回调方法，实现主要绘制逻辑</span></span></span><br><span class="line"><span class="function">    @Override</span></span><br><span class="line"><span class="function">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title">surfaceChanged</span><span class="params">(SurfaceHolder holder, <span class="keyword">int</span> format, <span class="keyword">int</span> width, <span class="keyword">int</span> height)</span> </span>&#123;</span><br><span class="line">        <span class="comment">//1. 通过锁定获取canvas对象，开始编辑底层像素</span></span><br><span class="line">        Canvas canvas = holder.lockCanvas();</span><br><span class="line">        canvas.drawColor(<span class="number">0x4398ff</span>);</span><br><span class="line">        <span class="comment">//2. 消除canvas对象，结束像素编辑</span></span><br><span class="line">        holder.unlockCanvasAndPost(canvas);</span><br><span class="line">        <span class="comment">//3. 再次锁定并取消锁定</span></span><br><span class="line">        canvas = holder.lockCanvas(<span class="keyword">new</span> Rect(<span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>));</span><br><span class="line">        holder.unlockCanvasAndPost(canvas);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">surfaceDestroyed</span><span class="params">(SurfaceHolder holder)</span></span></span><br><span class="line"><span class="function">&#125;)</span>;</span><br></pre></td></tr></table></figure>
<p>SurfaceView 有两个子类<code>GLSurfaceView</code>和<code>VideoView</code>，可见视频图像亦是靠<code>Surface</code>机制来渲染。<code>SurfaceView</code>是一个专门负责绘制<code>Surface</code>内容的<code>View</code>对象，它最大的优点是使用单独线程完成绘制工作。</p>
<p>通常每个窗口背后对应一个<code>Surface</code>，不同<code>Surface</code>的Z序列不同，在底层将这些<code>Surface</code>的内容合成；<code>Surface</code>可以理解成绘制内容数据。</p>
<p>绘制工作主要是由SurfaceHolder来完成的。SurfaceHolder负责与 Surface 内容数据打交道，可以控制比如<code>Surface</code>尺寸，格式，像素并监听<code>Surface</code>的变化。</p>
<p>一般而言，SurfaceView 进入前台时 Surface 内容被创建，转入后台则被销毁；这是Android系统内存管理的特征；在 Surface 内容被创建后可以通过 holder.lockCanvas(Rect dirty); 获得一个 canvas 对象，对 dirty 矩形区域内进行绘制；此时脏区内的 Surface 内容被锁定是线程安全的;使用 unlockCanvasAndPost(canvas) 方法释放锁定后，脏区内容将被系统渲染展示到屏幕上。<strong>但数据内容没有被清除；因此如果更改了绘制区域后，将绘制先前内容。因此使用holder.lockCanvas(new Rect(0, 0, 0, 0)) 锁定并取消锁定的方法清除内容。</strong></p>
<h3 id="ViewTreeObserver"><a href="#ViewTreeObserver" class="headerlink" title="ViewTreeObserver"></a>ViewTreeObserver</h3><p>ViewTreeObserver 接口可以响应视图树的变化，其中最重要的一个接口就是 OnPreDrawListener</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">OnPreDrawListener</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">onPreDraw</span><span class="params">()</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><strong>这个接口之所以重要在于它的执行时机非常好，处在布局之后，绘制之前，各项参数(如尺寸和位置)均已确定，正是使用各种 trick 的方法。</strong></p>
<p>此外一个使用较多的接口是 OnGlobalLayoutListener ，执行时间在控件发生 visibility 的变化。</p>
<h2 id="各种子控件"><a href="#各种子控件" class="headerlink" title="各种子控件"></a>各种子控件</h2><h3 id="Space-与-ViewStub"><a href="#Space-与-ViewStub" class="headerlink" title="Space 与 ViewStub"></a>Space 与 ViewStub</h3><p>Space 是一个典型的占位控件，它始终处于 INVISIBLE 状态，参与测量和布局，但 draw 方法为空。</p>
<p>ViewStub 则处于 GONE 状态，这意味着它没有尺寸， draw 方法也为空。 直到执行 inflate() 方法载入其它控件</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">ViewStub stub = (ViewStub) findViewById(R.id.stub);</span><br><span class="line">View inflated = stub.inflate();</span><br></pre></td></tr></table></figure>
<p>ViewStub 会将子布局加载到它的父布局中去，新的子布局将继承原 ID，同时让父布局移除自己。</p>
<h3 id="FrameLayout"><a href="#FrameLayout" class="headerlink" title="FrameLayout"></a>FrameLayout</h3><p>FrameLayout 测量时以子控件的最大高度/宽度作为自己的尺寸。它的 LayoutParams 多了一个参数，并利用这个参数来对齐</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">int</span> gravity = UNSPECIFIED_GRAVITY;</span><br></pre></td></tr></table></figure>
<p>在布局方法中根据子控件的 gravity 参数来对齐子控件</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">final</span> <span class="keyword">int</span> layoutDirection = getLayoutDirection();</span><br><span class="line"><span class="keyword">final</span> <span class="keyword">int</span> absoluteGravity = Gravity.getAbsoluteGravity(gravity, layoutDirection);</span><br><span class="line"><span class="keyword">final</span> <span class="keyword">int</span> verticalGravity = gravity &amp; Gravity.VERTICAL_GRAVITY_MASK;</span><br></pre></td></tr></table></figure>
<p>absoluteGravity 决定了子控件的 left 位置，verticalGravity 决定了子控件的 top 位置，计算如下</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">switch</span> (absoluteGravity &amp; Gravity.HORIZONTAL_GRAVITY_MASK) &#123;</span><br><span class="line">    <span class="keyword">case</span> Gravity.CENTER_HORIZONTAL:</span><br><span class="line">        childLeft = parentLeft + (parentRight - parentLeft - width) / <span class="number">2</span> +</span><br><span class="line">        lp.leftMargin - lp.rightMargin;</span><br><span class="line">    <span class="keyword">case</span> Gravity.RIGHT:</span><br><span class="line">        childLeft = parentRight - width - lp.rightMargin;</span><br><span class="line">    <span class="keyword">case</span> Gravity.LEFT:</span><br><span class="line">        childLeft = parentLeft + lp.leftMargin;</span><br><span class="line">&#125;</span><br><span class="line">child.layout(childLeft, childTop, childLeft + width, childTop + height);</span><br></pre></td></tr></table></figure>
<h4 id="ViewAnimator"><a href="#ViewAnimator" class="headerlink" title="ViewAnimator"></a>ViewAnimator</h4><p>ViewAnimator 是 FrameLayout 的子类，在切换布局时能够执行动画。这种效果是重写 addView 和 removeView 方法来实现的，其子类有 TextSwitcher，ImageSwitcher 和 ViewFlipper。</p>
<p>ViewFlipper 能够自动播放，这是通过在 onAttachedToWindow 方法中启动线程循环达成的，有意思的是它还使用广播接收器处理了屏幕熄灭和用户划开屏幕保护锁的广播</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">onAttachedToWindow</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">super</span>.onAttachedToWindow();</span><br><span class="line">    <span class="keyword">final</span> IntentFilter filter = <span class="keyword">new</span> IntentFilter();</span><br><span class="line">    filter.addAction(Intent.ACTION_SCREEN_OFF);</span><br><span class="line">    filter.addAction(Intent.ACTION_USER_PRESENT);</span><br><span class="line">    getContext().registerReceiverAsUser(mReceiver, android.os.Process.myUserHandle(),</span><br><span class="line">            filter, <span class="keyword">null</span>, getHandler());</span><br><span class="line">    <span class="keyword">if</span> (mAutoStart) &#123;</span><br><span class="line">        startFlipping();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">onDetachedFromWindow</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">super</span>.onDetachedFromWindow();</span><br><span class="line">    mVisible = <span class="keyword">false</span>;</span><br><span class="line">    getContext().unregisterReceiver(mReceiver);</span><br><span class="line">    updateRunning();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="HorizontalScrollView"><a href="#HorizontalScrollView" class="headerlink" title="HorizontalScrollView"></a>HorizontalScrollView</h3><p>HorizontalScrollView 是一个继承 FrameLayout 的水平滚动控件，只应有一个子控件，它的滚动被称之为覆盖滚动(<code>OverScroll</code>)，需要处理<strong>容器自身的尺寸小于它所容纳的子控件的尺寸</strong>的情况。</p>
<p>覆盖滚动有三种类型</p>
<ul>
<li>OVER_SCROLL_NEVER 子控件永远被束缚在容器内</li>
<li>OVER_SCROLL_ALWAYS 子控件永远能够滚动出容器外</li>
<li>OVER_SCROLL_IF_CONTENT_SCROLLS 只有子控件大于容器才能发生</li>
</ul>
<p>1.测量方法：容器只处理水平滚动，在垂直方向上倾向于将子控件完全扩展，且以自身容器宽度作为子控件宽度。如果不想这么做，可以设置参数 FillViewport 为 false。</p>
<p>2.拦截方法： 容器根据控件是否处于拖动状态决定是否拦截，只有处在MotionEvent.ACTION_MOVE 状态，滑动距离足够且触摸点在子控件内可以拦截此事件。发生拦截后，在事件处理方法中完成覆盖滑动。这一过程本质上是通过改变 mScrollX/mScrollY 的位置来实现的。</p>
<p>a.是否能够进行覆盖滑动，由滑动方式和滑动范围决定。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> range = getScrollRange();<span class="comment">//计算滑动范围int </span></span><br><span class="line">overscrollMode = getOverScrollMode();<span class="comment">//计算覆盖滑动方式</span></span><br><span class="line"><span class="keyword">boolean</span> canOverscroll = overscrollMode == OVER_SCROLL_ALWAYS ||(overscrollMode == OVER_SCROLL_IF_CONTENT_SCROLLS &amp;&amp; range &gt; <span class="number">0</span>);</span><br></pre></td></tr></table></figure>
<p>b.覆盖滑动范围为子控件宽度与容器宽度的差值，计算如下</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Math.max(<span class="number">0</span>,child.getWidth() - (getWidth() - mPaddingLeft - mPaddingRight);</span><br></pre></td></tr></table></figure>
<p>滑动范围为<strong>子控件的宽度-容器的内容宽度</strong>，而且如果此值为负，就无法滑动。因此<strong>只有子控件的宽度大于容器宽度才能产生滑动</strong>，这也是判断子控件能否滚动的依据。</p>
<p>c.覆盖滑动的行为由 overScrollBy 完成</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//mOverscrollDistance 指的是触发边界效应的距离</span></span><br><span class="line">overScrollBy(deltaX, <span class="number">0</span>, mScrollX, <span class="number">0</span>, range, <span class="number">0</span>, mOverscrollDistance, <span class="number">0</span>, <span class="keyword">true</span>)</span><br></pre></td></tr></table></figure>
<p>该方法采用 Scroller 来进行滑动，会修正新的 ScrollX 和 ScrollY 值，。</p>
<p>4.<strong>翻页滑动</strong>和<strong>全页滑动</strong></p>
<p><strong>翻页滑动(pageScroll)，点击 (shift+)space可以调用</strong>，这里的页宽就是容器的宽度，如果向左翻页<br>则左边界为<code>Math.max(0,getScrollX() - width)</code>，右边界为<code>right = mTempRect.left + width</code>。</p>
<p><strong>全页滑动(fullScroll 包括 arrowScroll)，点击 (alt+)Pad key可以调用</strong>，如果向左翻页，左边界为0，右边界为<code>width</code>，即容器宽度。如果向右翻页，左右边界确定如下</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">View view = getChildAt(<span class="number">0</span>);</span><br><span class="line">mTempRect.right = view.getRight();</span><br><span class="line">mTempRect.left = mTempRect.right - width;</span><br></pre></td></tr></table></figure>

        
      
    </div>

    
    
    
      <footer class="post-footer">
          <div class="post-eof"></div>
        
      </footer>
  </div>
  
  
  
  </article>

    
        <article itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block home">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2017/08/06/android/View/动画二：布局容器动画(Transition)/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="xiang">
      <meta itemprop="description" content="谨守而勿失，是谓反其真">
      <meta itemprop="image" content="/images/1.jpg">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="lxt">
    </span>
      <header class="post-header">
        <h1 class="post-title" itemprop="name headline">
            
            <a href="/2017/08/06/android/View/动画二：布局容器动画(Transition)/" class="post-title-link" itemprop="url">动画二：布局容器动画(Transition)</a>
          
        </h1>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              
                
              

              <time title="创建时间：2017-08-06 21:26:26" itemprop="dateCreated datePublished" datetime="2017-08-06T21:26:26+08:00">2017-08-06</time>
            </span>
          
            

            
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="fa fa-calendar-check-o"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2019-09-18 16:03:36" itemprop="dateModified" datetime="2019-09-18T16:03:36+08:00">2019-09-18</time>
              </span>
            
          
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing"><a href="/categories/android/" itemprop="url" rel="index"><span itemprop="name">android</span></a></span>

                
                
                  ，
                
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing"><a href="/categories/android/View/" itemprop="url" rel="index"><span itemprop="name">View</span></a></span>

                
                
              
            </span>
          

          
          <br>
            <span class="post-meta-item" title="本文字数">
              <span class="post-meta-item-icon">
                <i class="fa fa-file-word-o"></i>
              </span>
              
                <span class="post-meta-item-text">本文字数：</span>
              
              <span>10k</span>
            </span>
          
            <span class="post-meta-item" title="阅读时长">
              <span class="post-meta-item-icon">
                <i class="fa fa-clock-o"></i>
              </span>
              
                <span class="post-meta-item-text">阅读时长 &asymp;</span>
              
              <span>9 分钟</span>
            </span>
          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h2 id="布局容器动画：android-transition"><a href="#布局容器动画：android-transition" class="headerlink" title=" 布局容器动画：android.transition"></a><a href="https://github.com/andkulikov/Transitions-Everywhere" target="_blank" rel="noopener"> 布局容器动画：android.transition</a></h2><p>Transition 是布局容器发生变化(包括其内部的控件发生变化：如添加控件，某个控件改变颜色)时应用的一种动画。</p>
<p>Transition 的简单调用如下</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">TransitionManager.beginDelayedTransition(sceneRoot);<span class="comment">//默认采用A utoTransition</span></span><br></pre></td></tr></table></figure>
<p>也可以使用 Scene</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Scene scene = <span class="keyword">new</span> Scene(sceneRoot, textView);</span><br><span class="line">TransitionManager.go(scene, <span class="keyword">new</span> Fade(Fade.IN));</span><br></pre></td></tr></table></figure>
<p><strong>此时实际并不能执行动画，只有当布局发生变化时才会执行，且一次设置只能执行一次</strong>。<strong>动画发生的准确时间是在onPreDraw方法中。</strong></p>
<h3 id="Scene"><a href="#Scene" class="headerlink" title="Scene"></a>Scene</h3><p>首先来看Scene类，Scene 定义如下，它需要一个已经存在的容器(mSceneRoot)，和一个新的控件或布局(mLayoutId或mLayout)。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">final</span> <span class="class"><span class="keyword">class</span> <span class="title">Scene</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> Context mContext;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> mLayoutId = -<span class="number">1</span>; <span class="comment">//待加入到根布局中的布局，必须没有父控件</span></span><br><span class="line">    <span class="keyword">private</span> ViewGroup mSceneRoot; <span class="comment">//根布局，必须已经存在</span></span><br><span class="line">    <span class="keyword">private</span> View mLayout; <span class="comment">// alternative to layoutId</span></span><br><span class="line">    Runnable mEnterAction, mExitAction;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><strong>进入场景(Scene )的执行方法 enter 如下，实际是将容器的控件清空，添加新控件并将Scene对象自身存储进容器中。</strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">enter</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    getSceneRoot().removeAllViews();</span><br><span class="line">  </span><br><span class="line">    mSceneRoot.addView(mLayout);</span><br><span class="line">    LayoutInflater.from(mContext).inflate(mLayoutId, mSceneRoot);</span><br><span class="line">    mEnterAction.run();</span><br><span class="line">  </span><br><span class="line">    setCurrentScene(mSceneRoot, <span class="keyword">this</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><strong>根布局对象 sceneRoot 中的 Tag 对象是一个SparseArray<scene>集合，用 layoutId 作为键 新创建的 Scene 对象存储进去，反过来也能从中获取Scene对象。</scene></strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">static</span> Scene <span class="title">getCurrentScene</span><span class="params">(View view)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> (Scene) view.getTag(com.android.internal.R.id.current_scene);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><strong>这样原本的根布局就埋下了所需的条件，当时机成熟时将被调用，当Transition动画播放完成后将被清除</strong></p>
<h3 id="TransitionManager"><a href="#TransitionManager" class="headerlink" title="TransitionManager"></a>TransitionManager</h3><p>TransitionManager 是使用 Transition 的调度器，它将 Scene 和 Transition 匹配到一起，这样当某个 Scene 进入时，可以执行对应的 Transition。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">TransitionManager</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> Transition sDefaultTransition = <span class="keyword">new</span> AutoTransition();</span><br><span class="line">    ArrayMap&lt;Scene, Transition&gt; mSceneTransitions = <span class="keyword">new</span> ArrayMap&lt;Scene, Transition&gt;();</span><br><span class="line">    ArrayMap&lt;Scene, ArrayMap&lt;Scene, Transition&gt;&gt; mScenePairTransitions =</span><br><span class="line">            <span class="keyword">new</span> ArrayMap&lt;Scene, ArrayMap&lt;Scene, Transition&gt;&gt;();</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> ArrayList&lt;ViewGroup&gt; sPendingTransitions = <span class="keyword">new</span> ArrayList&lt;ViewGroup&gt;();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>也可以指定离开某Scene时的 Transition 集合，由集合mScenePairTransitions保存，其 key 是进入场景 toScene。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setTransition</span><span class="params">(Scene fromScene, Scene toScene, Transition transition)</span> </span>&#123;</span><br><span class="line">    ArrayMap&lt;Scene, Transition&gt; sceneTransitionMap = mScenePairTransitions.get(toScene);</span><br><span class="line">    sceneTransitionMap.put(fromScene, transition);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><strong>虽然 TransitionManager 保存了 Scene 和 Transition 的对应关系，但如何根据Scene获取Transition 还与所配置的 ViewGroup有关。</strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//这里Scene表示进入场景，而 sceneRoot 中存储的是当前场景，即将要离开的场景，在播放完成后要被删除；</span></span><br><span class="line"><span class="comment">//因此先获取的是离开场景，离开Transition播放完成后将获取进入场景。</span></span><br><span class="line"><span class="function"><span class="keyword">private</span> Transition <span class="title">getTransition</span><span class="params">(Scene scene)</span> </span>&#123;</span><br><span class="line">    Transition transition = <span class="keyword">null</span>;</span><br><span class="line">    ViewGroup sceneRoot = scene.getSceneRoot();</span><br><span class="line">    <span class="keyword">if</span> (sceneRoot != <span class="keyword">null</span>) &#123;</span><br><span class="line">        Scene currScene = Scene.getCurrentScene(sceneRoot);</span><br><span class="line">        <span class="keyword">if</span> (currScene != <span class="keyword">null</span>) &#123;</span><br><span class="line">            ArrayMap&lt;Scene, Transition&gt; sceneTransitionMap = mScenePairTransitions.get(scene);</span><br><span class="line">            <span class="keyword">if</span> (sceneTransitionMap != <span class="keyword">null</span>) &#123;</span><br><span class="line">                transition = sceneTransitionMap.get(currScene);</span><br><span class="line">                <span class="keyword">if</span> (transition != <span class="keyword">null</span>) &#123;</span><br><span class="line">                    <span class="keyword">return</span> transition;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    transition = mSceneTransitions.get(scene);</span><br><span class="line">    <span class="keyword">return</span> (transition != <span class="keyword">null</span>) ? transition : sDefaultTransition;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>TransitionManager 调用动画的执行过程如下</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//1.准备工作1：清理先前的 Transition，包括 TransitionManager 和 sceneRoot 内部存储的两部分</span></span><br><span class="line">ArrayList&lt;Transition&gt; runningTransitions = getRunningTransitions().get(sceneRoot);</span><br><span class="line"><span class="keyword">for</span> (Transition runningTransition : runningTransitions) &#123;</span><br><span class="line">    runningTransition.pause(sceneRoot);</span><br><span class="line">&#125;</span><br><span class="line">Scene previousScene = Scene.getCurrentScene(sceneRoot);</span><br><span class="line">previousScene.exit();</span><br><span class="line"><span class="comment">//2.准备工作2：新的 Transition 获取初始值，并清理掉 sceneRoot内部存储的 Scene 对象</span></span><br><span class="line">transition.captureValues(sceneRoot, <span class="keyword">true</span>);</span><br><span class="line">Scene.setCurrentScene(sceneRoot, <span class="keyword">null</span>);</span><br><span class="line"><span class="comment">//3.在视图树中埋点</span></span><br><span class="line">sceneRoot.getViewTreeObserver().addOnPreDrawListener(listener);</span><br><span class="line">mTransition.captureValues(mSceneRoot, <span class="keyword">false</span>);</span><br><span class="line">mTransition.playTransition(mSceneRoot);</span><br></pre></td></tr></table></figure>
<p>当视图树发生变化时将执行 OnPreDraw 方法，此时就是执行动画的时机</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//1.清理监听器和 Transition 集合</span></span><br><span class="line">removeListeners();</span><br><span class="line">sPendingTransitions.remove(mSceneRoot);</span><br><span class="line"><span class="comment">//2.此时布局过程已经完成，绘制还没有开始，是 Transition 获取终止值的绝佳时机。</span></span><br><span class="line">mTransition.captureValues(mSceneRoot, <span class="keyword">false</span>);</span><br><span class="line"><span class="comment">//3.起始值均已捕获，执行动画的条件已经成熟。</span></span><br><span class="line">mTransition.playTransition(mSceneRoot);</span><br></pre></td></tr></table></figure>
<p><strong>这里 Transition 的执行实际是放在ViewTreeObserver.OnPreDrawListener接口中进行的，以便容器 mSceneRoot 重绘前调用</strong>，在播放完成后还要进行对应清理工作。</p>
<h3 id="Transition"><a href="#Transition" class="headerlink" title="Transition"></a>Transition</h3><p>Transition 动画的数据结构是 TransitionValues，包含了待变化的属性字典</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">TransitionValues</span> </span>&#123;</span><br><span class="line">    <span class="keyword">public</span> View view;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">final</span> Map&lt;String, Object&gt; values = <span class="keyword">new</span> ArrayMap&lt;String, Object&gt;();</span><br><span class="line">    <span class="keyword">final</span> ArrayList&lt;Transition&gt; targetedTransitions = <span class="keyword">new</span> ArrayList&lt;Transition&gt;();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>Transition 中的核心就是两个 TransitionValues 集合，表示动画的起始值。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">ArrayList&lt;TransitionValues&gt; mStartValuesList; <span class="comment">// only valid after playTransition starts</span></span><br><span class="line">ArrayList&lt;TransitionValues&gt; mEndValuesList; <span class="comment">// only valid after playTransitions starts</span></span><br></pre></td></tr></table></figure>
<p>在 playTransition 方法中，首先要构建这两个集合</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="keyword">void</span> <span class="title">captureStartValues</span><span class="params">(TransitionValues transitionValues)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="keyword">void</span> <span class="title">captureEndValues</span><span class="params">(TransitionValues transitionValues)</span></span>;</span><br></pre></td></tr></table></figure>
<p><strong>而后是遍历 sceneRoot，为每个 TransitionValues 对创建属性动画。</strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> Animator <span class="title">createAnimator</span><span class="params">(ViewGroup sceneRoot, TransitionValues startValues,TransitionValues endValues)</span></span></span><br></pre></td></tr></table></figure>
<p><strong>Transition 的子类要定义如何获取起始值以及如何创建属性动画上，这都与具体的属性有关。</strong></p>
<p>下面通过子类实例说说如何定义 Transition。</p>
<h4 id="Visibility"><a href="#Visibility" class="headerlink" title="Visibility"></a>Visibility</h4><p><strong>Visibility 类能够响应控件可见性的变化， 这与他定义的三个属性有关</strong>，这些属性的数值完全由 View 提供，其名称和类型为</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//1.表示 View 的可见性，int类型</span></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">final</span> String PROPNAME_VISIBILITY = <span class="string">"android:visibility:visibility"</span>;</span><br><span class="line"><span class="comment">//2.表示 View 的 Parent，View类型</span></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">final</span> String PROPNAME_PARENT = <span class="string">"android:visibility:parent"</span>;</span><br><span class="line"><span class="comment">//3.表示 View 的屏幕位置，int[]类型</span></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">final</span> String PROPNAME_SCREEN_LOCATION = <span class="string">"android:visibility:screenLocation"</span>;</span><br></pre></td></tr></table></figure>
<p>这样在获取属性时，就可以将这些属性值写入属性字典中去</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">captureValues</span><span class="params">(TransitionValues transitionValues, <span class="keyword">int</span> forcedVisibility)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> visibility = transitionValues.view.getVisibility();</span><br><span class="line">    transitionValues.values.put(PROPNAME_VISIBILITY, visibility);</span><br><span class="line">    transitionValues.values.put(PROPNAME_PARENT, transitionValues.view.getParent());</span><br><span class="line">    <span class="keyword">int</span>[] loc = <span class="keyword">new</span> <span class="keyword">int</span>[<span class="number">2</span>];</span><br><span class="line">    transitionValues.view.getLocationOnScreen(loc);</span><br><span class="line">    transitionValues.values.put(PROPNAME_SCREEN_LOCATION, loc);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>创建动画的方法委托给了子类，以 Fade 为例，它添加了一个透明度属性(由view.getAlpha()提供)</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">static</span> <span class="keyword">final</span> String PROPNAME_ALPHA = <span class="string">"fade:alpha"</span>;</span><br></pre></td></tr></table></figure>
<p>创建关于 View透明度的属性动画，变化区间从当前透明度到 1。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> Animator <span class="title">onAppear</span><span class="params">(ViewGroup sceneRoot, View view, TransitionValues startValues,</span></span></span><br><span class="line"><span class="function"><span class="params">        TransitionValues endValues)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">float</span> startAlpha = getStartAlpha(startValues, <span class="number">0</span>);</span><br><span class="line">    <span class="keyword">return</span> ObjectAnimator.ofFloat(view, View.ALPHA, startAlpha, <span class="number">1</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>同理子类 Scale 创建了关于 scaleX 和 scaleY 的属性动画，子类 Slide 创建了关于 TRANSLATION_X 和 TRANSLATION_Y的属性动画，在确立起始点时要考虑屏幕位置，<strong>它使用的属性动画要建立 Path，通过改变Path可以改变滑动的轨迹</strong>。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ObjectAnimator.ofFloat(view, View.TRANSLATION_X, View.TRANSLATION_Y, path);</span><br></pre></td></tr></table></figure>
<h4 id="其他Transition"><a href="#其他Transition" class="headerlink" title="其他Transition"></a>其他Transition</h4><p>类 ChangeBounds 将改变 View 的 Bound 属性，同时也要处理父容器的 Bound 改变。它有如下属性</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> String PROPNAME_BOUNDS = <span class="string">"android:changeBounds:bounds"</span>;</span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> String PROPNAME_CLIP = <span class="string">"android:changeBounds:clip"</span>;</span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> String PROPNAME_PARENT = <span class="string">"android:changeBounds:parent"</span>; <span class="comment">//父容器是否响应</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> String PROPNAME_WINDOW_X = <span class="string">"android:changeBounds:windowX"</span>; <span class="comment">//屏幕位置</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> String PROPNAME_WINDOW_Y = <span class="string">"android:changeBounds:windowY"</span>;</span><br></pre></td></tr></table></figure>
<ul>
<li>ChangeScroll ： scrollX/scrollY 属性</li>
<li>ChangeTransform ： AnimationMatrix 属性</li>
<li>ChangeClipBounds ： clipBounds 属性</li>
<li>ChangeImageTransform ：ImageView 的 animateTransform 属性</li>
</ul>
<h4 id="TransitionSet"><a href="#TransitionSet" class="headerlink" title="TransitionSet"></a>TransitionSet</h4><p>装饰器 TransitionSet 代表着 Transition 集合，并能够为其指定播放顺序。默认实现 AutoTransition 采用顺序播放，包括三个 Transition，即 Fade.OUT，ChangeBounds，Fade.IN。</p>
<p><strong>单个 Transition 可以添加或排除某个 View，排除的规则可以使用 id，transitionname字符串，class等手段。</strong></p>
<h3 id="二维路径插值器-PathMotion"><a href="#二维路径插值器-PathMotion" class="headerlink" title="二维路径插值器(PathMotion)"></a>二维路径插值器(PathMotion)</h3><p>PathMotion 负责在起始点之间进行插值，它返回的是一个路径。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">abstract</span> Path <span class="title">getPath</span><span class="params">(<span class="keyword">float</span> startX, <span class="keyword">float</span> startY, <span class="keyword">float</span> endX, <span class="keyword">float</span> endY)</span></span>;</span><br></pre></td></tr></table></figure>
<p>某些改变位置的 Transition 可以使用，如ChangeBounds</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">new</span> ChangeBounds().setPathMotion(<span class="keyword">new</span> ArcMotion())</span><br></pre></td></tr></table></figure>
<h2 id="Transition-的实践"><a href="#Transition-的实践" class="headerlink" title="Transition 的实践"></a>Transition 的实践</h2><h3 id="活动间的转场动画"><a href="#活动间的转场动画" class="headerlink" title="活动间的转场动画"></a>活动间的转场动画</h3><p>使用 ActivityOptions可以得到活动间的转场动画，这里要通过 transitionName 属性来指定采用动画的View。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">String transitionName = context.getResources().getString(R.string.transition_app_icon);</span><br><span class="line">ActivityOptions transitionActivityOptions = ActivityOptions.makeSceneTransitionAnimation(activity, appIcon, transitionName);</span><br><span class="line">context.startActivity(intent, transitionActivityOptions.toBundle());</span><br></pre></td></tr></table></figure>
<p><strong>1.执行这个动画需要设置 Window.FEATURE_ACTIVITY_TRANSITIONS。</strong></p>
<p>ActivityOptions 创建的各种动画只是记录参数到 Bundle 中去，对于 SceneTransition 主要记录 View 和 String(transitionName) 的对应关系，以便于选取 Transition。</p>
<p><strong>2.使用转场动画时，可以使用下列的一对方法来控制转场动画。</strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">postponeEnterTransition</span><span class="params">()</span></span>; <span class="comment">//使得动画阻塞</span></span><br><span class="line"><span class="comment">//Thread.sleep(3000); //可以利用这段时间做准备工作，进行数据的加载</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">startPostponedEnterTransition</span><span class="params">()</span></span>; <span class="comment">//启动动画，否则动画将一直阻塞下去，新Activit无法启动</span></span><br></pre></td></tr></table></figure>
<p><strong>3.更简单的使用场景动画的方式是</strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">startActivity(intent);</span><br><span class="line">overridePendingTransition(R.anim.slide_in_left, R.anim.slide_out_right);</span><br></pre></td></tr></table></figure>
<p>overridePendingTransition 分别决定了起始页和跳转页使用的属性动画。</p>
<p>这一点同样可以用在离开时</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onBackPressed</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">super</span>.onBackPressed();</span><br><span class="line">    overridePendingTransition(R.anim.slide_out_right, R.anim.slide_in_left);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><strong>4.使用 Transition 监听器</strong></p>
<p>活动的 Transition 是设置在 Window 上的，采用转场动画应该尽量在动画播放完成后再加载数据，避免处理控件(如RecyclerView)的滑动等。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">getWindow().getEnterTransition().addListener(<span class="keyword">this</span>);</span><br></pre></td></tr></table></figure>
<h3 id="自定义Transition"><a href="#自定义Transition" class="headerlink" title="自定义Transition"></a>自定义Transition</h3><p><strong>自定义Transition的核心是要改变容器布局中哪些 View 的哪些属性</strong>，为此需要以下步骤来确定(以改变TextView的字体大小为例)</p>
<p><strong>1.确定属性名称</strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> String PRO_NAME_TEXT_SIZE = <span class="string">"text:size"</span>;</span><br></pre></td></tr></table></figure>
<p><strong>2.如何获取起始值</strong>TransitionValues</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">captureStartValues</span><span class="params">(TransitionValues transitionValues)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(transitionValues.view <span class="keyword">instanceof</span> TextView)&#123;</span><br><span class="line">        TextView tv = (TextView) transitionValues.view;</span><br><span class="line">        transitionValues.values.put(PRO_NAME_TEXT_SIZE, tv.getTextSize());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><strong>3.创建关于字体大小的动画</strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> Animator <span class="title">createAnimator</span><span class="params">(ViewGroup sceneRoot, TransitionValues startValues, TransitionValues endValues)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(endValues.view <span class="keyword">instanceof</span> TextView)&#123;</span><br><span class="line">        TextView tv = (TextView) endValues.view;</span><br><span class="line">        <span class="keyword">float</span> start = ((TextView) startValues.view).getTextSize(); <span class="comment">//初始值</span></span><br><span class="line">        <span class="keyword">float</span> end = ((TextView) endValues.view).getTextSize();     <span class="comment">//终止值</span></span><br><span class="line">        PropertyValuesHolder holder = PropertyValuesHolder.ofFloat(PROPERTY_TEXT_SIZE, start, end);</span><br><span class="line">        <span class="keyword">return</span> ObjectAnimator.ofPropertyValuesHolder(tv, holder);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这样当设置字体时就会播放动画。</p>
<h3 id="TransitionPlayer"><a href="#TransitionPlayer" class="headerlink" title="TransitionPlayer"></a><a href="https://github.com/linfaxin/TransitionPlayer" target="_blank" rel="noopener">TransitionPlayer</a></h3><p>TransitionPlayer 中有一个精彩的引导页示例， 也是 Transition 动画的使用范例。</p>
<h2 id="Material-Animations"><a href="#Material-Animations" class="headerlink" title="Material-Animations"></a><a href="https://github.com/lgvalle/Material-Animations" target="_blank" rel="noopener">Material-Animations</a></h2><h2 id="StarWars-Android"><a href="#StarWars-Android" class="headerlink" title="StarWars.Android"></a><a href="https://github.com/Yalantis/StarWars.Android" target="_blank" rel="noopener">StarWars.Android</a></h2><p><img src="https://github.com/Yalantis/StarWars.Android/raw/master/star_wars-concept.gif" alt="img"></p>

        
      
    </div>

    
    
    
      <footer class="post-footer">
          <div class="post-eof"></div>
        
      </footer>
  </div>
  
  
  
  </article>

    
  </div>

  
  <nav class="pagination">
    <a class="extend prev" rel="prev" href="/"><i class="fa fa-angle-left" aria-label="上一页"></i></a><a class="page-number" href="/">1</a><span class="page-number current">2</span><a class="page-number" href="/page/3/">3</a><a class="extend next" rel="next" href="/page/3/"><i class="fa fa-angle-right" aria-label="下一页"></i></a>
  </nav>


          </div>
          

        </div>
          
  
  <div class="sidebar-toggle">
    <div class="sidebar-toggle-line-wrap">
      <span class="sidebar-toggle-line sidebar-toggle-line-first"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-middle"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-last"></span>
    </div>
  </div>

  <aside class="sidebar">
    <div class="sidebar-inner">

      <ul class="sidebar-nav motion-element">
        <li class="sidebar-nav-toc">
          文章目录
        </li>
        <li class="sidebar-nav-overview">
          站点概览
        </li>
      </ul>

      <!--noindex-->
      <div class="post-toc-wrap sidebar-panel">
      </div>
      <!--/noindex-->

      <div class="site-overview-wrap sidebar-panel">
        <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
    <img class="site-author-image" itemprop="image"
      src="/images/1.jpg"
      alt="xiang">
  <p class="site-author-name" itemprop="name">xiang</p>
  <div class="site-description" itemprop="description">谨守而勿失，是谓反其真</div>
</div>
  <nav class="site-state motion-element">
      <div class="site-state-item site-state-posts">
        
          <a href="/archives/">
        
          <span class="site-state-item-count">30</span>
          <span class="site-state-item-name">日志</span>
        </a>
      </div>
    
      
      
      <div class="site-state-item site-state-categories">
        
          
            <a href="/categories/">
          
        
        <span class="site-state-item-count">11</span>
        <span class="site-state-item-name">分类</span>
        </a>
      </div>
    
  </nav>
  <div class="links-of-author motion-element">
      <span class="links-of-author-item">
      
      
        
      
      
        
      
        <a href="https://github.com/liuxiangtian" title="GitHub &rarr; https://github.com/liuxiangtian" rel="noopener" target="_blank"><i class="fa fa-fw fa-github"></i>GitHub</a>
      </span>
    
      <span class="links-of-author-item">
      
      
        
      
      
        
      
        <a href="http://www.zhihu.com/people/liu-xiang-tian-74" title="zhihu &rarr; http://www.zhihu.com/people/liu-xiang-tian-74" rel="noopener" target="_blank"><i class="fa fa-fw fa-globe"></i>zhihu</a>
      </span>
    
  </div>



      </div>

    </div>
  </aside>
  <div id="sidebar-dimmer"></div>


      </div>
    </main>

    <footer id="footer" class="footer">
      <div class="footer-inner">
        <div class="copyright">&copy; <span itemprop="copyrightYear">2019</span>
  <span class="with-love" id="animate">
    <i class="fa fa-user"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">刘祥</span>
    <span class="post-meta-divider">|</span>
    <span class="post-meta-item-icon">
      <i class="fa fa-area-chart"></i>
    </span>
    <span title="站点总字数">214k</span>
    <span class="post-meta-divider">|</span>
    <span class="post-meta-item-icon">
      <i class="fa fa-coffee"></i>
    </span>
    <span title="站点阅读时长">3:15</span>
</div>



        












        
      </div>
    </footer>
  </div>

  


  <script src="/lib/anime.min.js?v=3.1.0"></script>
  <script src="/lib/velocity/velocity.min.js?v=1.2.1"></script>
  <script src="/lib/velocity/velocity.ui.min.js?v=1.2.1"></script>
<script src="/js/utils.js?v=7.4.0"></script><script src="/js/motion.js?v=7.4.0"></script>
<script src="/js/schemes/pisces.js?v=7.4.0"></script>

<script src="/js/next-boot.js?v=7.4.0"></script><script src="/js/bookmark.js?v=7.4.0"></script><!-- hexo-inject:begin --><!-- hexo-inject:end -->



  





















  

  
    
      
    
      
    
      
    
      
    
      
    
      
    
      
    
      
    
      
    
      
    
  

  

  

</body>
</html>
