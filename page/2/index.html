<!DOCTYPE html>





<html lang="zh-CN,ja,en,default">
<head>
  <!-- hexo-inject:begin --><!-- hexo-inject:end --><meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=2">
<meta name="theme-color" content="#222">
<meta name="generator" content="Hexo 3.9.0">
  <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon-next.png?v=7.4.0">
  <link rel="icon" type="image/png" sizes="32x32" href="/images/favicon-32x32-next.png?v=7.4.0">
  <link rel="icon" type="image/png" sizes="16x16" href="/images/favicon-16x16-next.png?v=7.4.0">
  <link rel="mask-icon" href="/images/logo.svg?v=7.4.0" color="#222">

<link rel="stylesheet" href="/css/main.css?v=7.4.0">


<link rel="stylesheet" href="/lib/font-awesome/css/font-awesome.min.css?v=4.7.0">


<script id="hexo-configurations">
  var NexT = window.NexT || {};
  var CONFIG = {
    root: '/',
    scheme: 'Gemini',
    version: '7.4.0',
    exturl: false,
    sidebar: {"position":"left","display":"hide","offset":12,"onmobile":false},
    copycode: {"enable":false,"show_result":false,"style":null},
    back2top: {"enable":true,"sidebar":false,"scrollpercent":false},
    bookmark: {"enable":true,"color":"#222","save":"auto"},
    fancybox: false,
    mediumzoom: false,
    lazyload: false,
    pangu: false,
    algolia: {
      appID: '',
      apiKey: '',
      indexName: '',
      hits: {"per_page":10},
      labels: {"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}
    },
    localsearch: {"enable":false,"trigger":"auto","top_n_per_article":1,"unescape":false,"preload":false},
    path: '',
    motion: {"enable":true,"async":false,"transition":{"post_block":"fadeIn","post_header":"slideDownIn","post_body":"slideDownIn","coll_header":"slideLeftIn","sidebar":"slideUpIn"}},
    translation: {
      copy_button: '复制',
      copy_success: '复制成功',
      copy_failure: '复制失败'
    },
    sidebarPadding: 40
  };
</script>

  <meta name="description" content="谨守而勿失，是谓反其真">
<meta property="og:type" content="website">
<meta property="og:title" content="lxt">
<meta property="og:url" content="http://yoursite.com/page/2/index.html">
<meta property="og:site_name" content="lxt">
<meta property="og:description" content="谨守而勿失，是谓反其真">
<meta property="og:locale" content="zh-CN">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="lxt">
<meta name="twitter:description" content="谨守而勿失，是谓反其真">
  <link rel="canonical" href="http://yoursite.com/page/2/">


<script id="page-configurations">
  // https://hexo.io/docs/variables.html
  CONFIG.page = {
    sidebar: "",
    isHome: true,
    isPost: false,
    isPage: false,
    isArchive: false
  };
</script>

  <title>lxt</title>
  








  <noscript>
  <style>
  .use-motion .brand,
  .use-motion .menu-item,
  .sidebar-inner,
  .use-motion .post-block,
  .use-motion .pagination,
  .use-motion .comments,
  .use-motion .post-header,
  .use-motion .post-body,
  .use-motion .collection-header { opacity: initial; }

  .use-motion .logo,
  .use-motion .site-title,
  .use-motion .site-subtitle {
    opacity: initial;
    top: initial;
  }

  .use-motion .logo-line-before i { left: initial; }
  .use-motion .logo-line-after i { right: initial; }
  </style>
</noscript><!-- hexo-inject:begin --><!-- hexo-inject:end -->

</head>

<body itemscope itemtype="http://schema.org/WebPage" lang="zh-CN">
  <!-- hexo-inject:begin --><!-- hexo-inject:end --><div class="container use-motion">
    <div class="headband"></div>

    <header id="header" class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-container">
  <div class="site-meta">

    <div>
      <a href="/" class="brand" rel="start">
        <span class="logo-line-before"><i></i></span>
        <span class="site-title">lxt</span>
        <span class="logo-line-after"><i></i></span>
      </a>
    </div>
  </div>

  <div class="site-nav-toggle">
    <button aria-label="切换导航栏">
      <span class="btn-bar"></span>
      <span class="btn-bar"></span>
      <span class="btn-bar"></span>
    </button>
  </div>
</div>


<nav class="site-nav">
  
  <ul id="menu" class="menu">
      
      
      
        
        <li class="menu-item menu-item-home">
      
    

    <a href="/" rel="section"><i class="menu-item-icon fa fa-fw fa-home"></i> <br>首页</a>

  </li>
      
      
      
        
        <li class="menu-item menu-item-tags">
      
    

    <a href="/tags/" rel="section"><i class="menu-item-icon fa fa-fw fa-tags"></i> <br>标签</a>

  </li>
      
      
      
        
        <li class="menu-item menu-item-categories">
      
    

    <a href="/categories/" rel="section"><i class="menu-item-icon fa fa-fw fa-th"></i> <br>分类</a>

  </li>
      
      
      
        
        <li class="menu-item menu-item-archives">
      
    

    <a href="/archives/" rel="section"><i class="menu-item-icon fa fa-fw fa-archive"></i> <br>归档</a>

  </li>
  </ul>

</nav>
</div>
    </header>

    
  <div class="back-to-top">
    <i class="fa fa-arrow-up"></i>
    <span>0%</span>
  </div>
  <div class="reading-progress-bar"></div>
  <a class="book-mark-link book-mark-link-fixed" href="#"></a>


    <main id="main" class="main">
      <div class="main-inner">
        <div class="content-wrap">
            

          <div id="content" class="content">
            
  <div id="posts" class="posts-expand">
        <article itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block home">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2017/08/16/android/View/View和ViewGroup/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="xiang">
      <meta itemprop="description" content="谨守而勿失，是谓反其真">
      <meta itemprop="image" content="/images/1.jpg">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="lxt">
    </span>
      <header class="post-header">
        <h1 class="post-title" itemprop="name headline">
            
            <a href="/2017/08/16/android/View/View和ViewGroup/" class="post-title-link" itemprop="url">View和ViewGroup</a>
          
        </h1>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              
                
              

              <time title="创建时间：2017-08-16 21:26:26" itemprop="dateCreated datePublished" datetime="2017-08-16T21:26:26+08:00">2017-08-16</time>
            </span>
          
            

            
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="fa fa-calendar-check-o"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2019-09-18 14:06:39" itemprop="dateModified" datetime="2019-09-18T14:06:39+08:00">2019-09-18</time>
              </span>
            
          
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing"><a href="/categories/android/" itemprop="url" rel="index"><span itemprop="name">android</span></a></span>

                
                
                  ，
                
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing"><a href="/categories/android/View/" itemprop="url" rel="index"><span itemprop="name">View</span></a></span>

                
                
              
            </span>
          

          
          <br>
            <span class="post-meta-item" title="本文字数">
              <span class="post-meta-item-icon">
                <i class="fa fa-file-word-o"></i>
              </span>
              
                <span class="post-meta-item-text">本文字数：</span>
              
              <span>21k</span>
            </span>
          
            <span class="post-meta-item" title="阅读时长">
              <span class="post-meta-item-icon">
                <i class="fa fa-clock-o"></i>
              </span>
              
                <span class="post-meta-item-text">阅读时长 &asymp;</span>
              
              <span>19 分钟</span>
            </span>
          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h2 id="位置与尺寸"><a href="#位置与尺寸" class="headerlink" title="位置与尺寸"></a>位置与尺寸</h2><p>1.关于控件的位置，有left，translationX 和 X三种，他们都和 RenderNode 有关，计算公式为</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">float</span> <span class="title">getX</span><span class="params">()</span> </span>&#123;    </span><br><span class="line">    <span class="keyword">return</span> mLeft + getTranslationX();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>为什么要在View中搞出这么多变量呢？</p>
<p>如果只变更 left，则只是左边界的变化，View 的视觉宽度将发生变化；TranslationX 则能够产生平移的效果，它同时附加在 left 和 right 上。</p>
<p>实际上同时移动 left 和right 相同的距离，也能达到平移的效果，类似于ViewCompat.offsetLeftAndRight 造成的效果，但这个与 TranslationX 实现的平移效果有所区别。</p>
<p>实际上同时移动 left 和right 相同的距离，也能达到平移的效果，类似于 ViewCompat.offsetLeftAndRight 造成的效果，但这个与 TranslationX 实现的平移效果有所区别。</p>
<p>前者只是非常机械的渲染效果，只要碰上 requestLayout 方法就复原了，后者的平移在重新布局后仍然有效。而且只变更left不会考虑一些类似于居中的要求，控件在变化过程中往往就“失真’’了。</p>
<p>如果确实要改变控件的宽度，应该从 LayoutParams.width 入手，修改此值，并调用方法，控件会重新进行测量。</p>
<p>2.再来说说 mScrollX/mScrollY ，它们只影响内容的绘制，不会影响背景 Drawable 的绘制，实际是通过对内容区域加偏移造成，最终的绘制效果是偏移后的内容区域与原本区域的。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">invalidate</span><span class="params">(Rect dirty)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">final</span> <span class="keyword">int</span> scrollX = mScrollX;</span><br><span class="line">    <span class="keyword">final</span> <span class="keyword">int</span> scrollY = mScrollY;</span><br><span class="line">    invalidateInternal(dirty.left - scrollX, dirty.top - scrollY,</span><br><span class="line">            dirty.right - scrollX, dirty.bottom - scrollY, <span class="keyword">true</span>, <span class="keyword">false</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>3.此外还可以使用动画来改变控件位置，属性动画就不提了，值得一提的是补间动画，默认的四种补间动画采用Transformation里的矩阵来操作渲染结果，但并不真的改变属性，如果要达成属性动画的效果，可以利用下面的方法</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setFillBefore</span><span class="params">(<span class="keyword">boolean</span> fillBefore)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setFillAfter</span><span class="params">(<span class="keyword">boolean</span> fillAfter)</span></span>;</span><br></pre></td></tr></table></figure>
<p>最后评价下各种操作的性能</p>
<ul>
<li>left 虽然是RenderNode实现，但需要 CPU 更新 displayList，调用和递归多(56/1022)，GPU监视上蓝色部分长</li>
<li>translationX 基本无更新 displayList 的调用和递归存在，蓝线几乎没有，耗时极少</li>
<li>LayoutParams 除非测量事件，耗时验证</li>
<li>offset ，耗时极少</li>
<li>animation 更新 displayList极多</li>
<li>animtor 不更新 displayList，快</li>
</ul>
<h3 id="layout-机制与-LayoutParams"><a href="#layout-机制与-LayoutParams" class="headerlink" title="layout_* 机制与 LayoutParams"></a>layout_* 机制与 LayoutParams</h3><p>layout<em>*机制通过内部类 LayoutParams 中定义以 layout</em>为前缀的属性供子控件使用，从而控制子控件的行为，这些属性并不为布局类自己所使用。以AppBarLayout为例</p>
<figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">android.support.design.widget.AppBarLayout</span>&gt;</span></span><br><span class="line">  </span><br><span class="line">  <span class="tag">&lt;<span class="name">android.support.v7.widget.Toolbar</span></span></span><br><span class="line"><span class="tag">    <span class="attr">app:layout_scrollFlags</span>=<span class="string">"scroll|enterAlways"</span> /&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">android.support.design.widget.AppBarLayout</span> &gt;</span></span><br></pre></td></tr></table></figure>
<p>Toolbar 本身并没有 layout<em>scrollFlags 属性，该属性定义在类 AppBarLayout.LayoutParams 中，加前缀 layout</em>表示这是一个父布局定义而子控件使用的属性。虽然这个属性是由容器来读取 XML文件进行解析和实例化的。</p>
<p>最广泛最著名的属性来自于 ViewGroup.LayoutParams 中的属性：layout_width 与 layout_height， 是容器用来约束子控件的宽度和高度的，ViewGroup.MarginLayoutParams 增加了6个margin属性，如果采用这种 LayoutParams，就能够给子控件设置 layout__margin属性，容器会在布局时利用这个属性。</p>
<p>自定义 LayoutParams 需要覆盖以下4个方法，这些方法是为子控件生成 LayoutParams 对象所必须的</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">boolean</span> <span class="title">checkLayoutParams</span><span class="params">(ViewGroup.LayoutParams p)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> p <span class="keyword">instanceof</span> LayoutParams;</span><br><span class="line">&#125;</span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> LayoutParams <span class="title">generateLayoutParams</span><span class="params">(AttributeSet attrs)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> LayoutParams(getContext(), attrs);</span><br><span class="line">&#125;</span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">protected</span> LayoutParams <span class="title">generateDefaultLayoutParams</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> LayoutParams(LayoutParams.MATCH_PARENT, LayoutParams.WRAP_CONTENT);</span><br><span class="line">&#125;</span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">protected</span> LayoutParams <span class="title">generateLayoutParams</span><span class="params">(ViewGroup.LayoutParams p)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> LayoutParams(p);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>实际上布局每添加一个控件，都会采用 generateDefaultLayoutParams() 方法来生成一个 LayoutParams 对象应用在子控件上(见addView方法)。</p>
<p>如果默认产生的 LayoutParams 对象不能通过 checkLayoutParams 方法的检查，则使用 generateLayoutParams 方法来产生 LayoutParams 对象。</p>
<p><strong>因此自定义LayoutParams 时要故意使得 generateDefaultLayoutParams 产生的对象通不过检查，而使用 generateLayoutParams(AttributeSet attrs)产生的 LayoutParams 对象。</strong></p>
<blockquote>
<p>约定 LayoutParams 中解析的属性值均要以 layout_ 开头。</p>
</blockquote>
<h3 id="尺寸测量"><a href="#尺寸测量" class="headerlink" title="尺寸测量"></a>尺寸测量</h3><p>控件的尺寸测量实际比想象的复杂，我们先看系统的默认实现。对于容器而言，除了测量自身，还要考虑测量子控件，这一步往往是调用 measureChild 方法来完成的</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">measureChild</span><span class="params">(View child, <span class="keyword">int</span> parentWidthMeasureSpec,</span></span></span><br><span class="line"><span class="function"><span class="params">        <span class="keyword">int</span> parentHeightMeasureSpec)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">final</span> LayoutParams lp = child.getLayoutParams();</span><br><span class="line">    <span class="keyword">final</span> <span class="keyword">int</span> childWidthMeasureSpec = getChildMeasureSpec(parentWidthMeasureSpec,</span><br><span class="line">            mPaddingLeft + mPaddingRight, lp.width);</span><br><span class="line">    <span class="keyword">final</span> <span class="keyword">int</span> childHeightMeasureSpec = getChildMeasureSpec(parentHeightMeasureSpec,</span><br><span class="line">            mPaddingTop + mPaddingBottom, lp.height);</span><br><span class="line">    child.measure(childWidthMeasureSpec, childHeightMeasureSpec);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><strong>在真正的测量方法前，将对复合尺寸进行重新计算，以求得实际的控件尺寸。</strong>其方法如下</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//spec 的复合尺寸，padding 是控件的留白</span></span><br><span class="line"><span class="comment">//childDimension 是赋给LayoutParams的尺寸，是控件想达到的尺寸，可能是 -1 -2 或 具体数值</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">int</span> <span class="title">getChildMeasureSpec</span><span class="params">(<span class="keyword">int</span> spec, <span class="keyword">int</span> padding, <span class="keyword">int</span> childDimension)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> specMode = MeasureSpec.getMode(spec); <span class="comment">// 容器的尺寸模式</span></span><br><span class="line">    <span class="keyword">int</span> specSize = MeasureSpec.getSize(spec); <span class="comment">// 容器的尺寸大小</span></span><br><span class="line">    <span class="keyword">int</span> size = Math.max(<span class="number">0</span>, specSize - padding); <span class="comment">// 容器的尺寸大小 - 控件的留白 == 控件在容器中的最大尺寸</span></span><br><span class="line">    <span class="keyword">int</span> resultSize = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">int</span> resultMode = <span class="number">0</span>;</span><br><span class="line">	<span class="comment">// 根据 LayoutParams 和 MeasureSpec 确定最终的复合尺寸</span></span><br><span class="line">    <span class="keyword">return</span> MeasureSpec.makeMeasureSpec(resultSize, resultMode);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>控件最终的复合尺寸受到两个因素的影响，即控件自定义的 LayoutParams 和容器的 MeasureSpec。其结果如下表所示</p>
<div class="table-container">
<table>
<thead>
<tr>
<th style="text-align:left">Spec\Params</th>
<th style="text-align:center">MATCH_PARENT</th>
<th style="text-align:center">WRAP_CONTENT</th>
<th style="text-align:center">具体数值(NUM)</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:left"><strong>EXACTLY</strong></td>
<td style="text-align:center"><strong>EXACTLY + size</strong></td>
<td style="text-align:center"><strong>AT_MOST + size</strong></td>
<td style="text-align:center"><strong>EXACTLY+ NUM</strong></td>
</tr>
<tr>
<td style="text-align:left">AT_MOST</td>
<td style="text-align:center">AT_MOST + size</td>
<td style="text-align:center">AT_MOST + size</td>
<td style="text-align:center">EXACTLY + NUM</td>
</tr>
<tr>
<td style="text-align:left">UNSPECIFIED</td>
<td style="text-align:center">UNSPECIFIED + size</td>
<td style="text-align:center">UNSPECIFIED + size</td>
<td style="text-align:center">EXACTLY + NUM</td>
</tr>
</tbody>
</table>
</div>
<blockquote>
<p><strong>实际默认的容器 SpecMode 往往是 EXACTLY，因此关注第一行。子控件设置为 match_parent 和 具体数值时，都将获得 exactly模式，不过尺寸有所差别而已，而 warp_content 的情况较为复杂，其模式为 at_most，尺寸想达到容器尺寸，需要进一步处理。</strong></p>
</blockquote>
<p>而后就是控件自身的测量方法</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">onMeasure</span><span class="params">(<span class="keyword">int</span> widthMeasureSpec, <span class="keyword">int</span> heightMeasureSpec)</span> </span>&#123;</span><br><span class="line">    setMeasuredDimension(getDefaultSize(getSuggestedMinimumWidth(), widthMeasureSpec),</span><br><span class="line">            getDefaultSize(getSuggestedMinimumHeight(), heightMeasureSpec));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>默认情况下的最小尺寸为背景 drawable 的尺寸 ，要在所得的尺寸和这个最小尺寸间做出决定，即 getDefaultSize 方法</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//size 是最小尺寸，measureSpec 是复合尺寸</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">int</span> <span class="title">getDefaultSize</span><span class="params">(<span class="keyword">int</span> size, <span class="keyword">int</span> measureSpec)</span> </span>&#123;&#125;</span><br></pre></td></tr></table></figure>
<p>getDefaultSize 方法将根据复合尺寸的模式得到最终在最小尺寸和复合尺寸间做出选择。</p>
<div class="table-container">
<table>
<thead>
<tr>
<th>specMode</th>
<th style="text-align:center">UNSPECIFIED</th>
<th style="text-align:center">AT_MOST</th>
<th style="text-align:center">EXACTLY</th>
</tr>
</thead>
<tbody>
<tr>
<td>最终尺寸</td>
<td style="text-align:center">size</td>
<td style="text-align:center"><strong>specSize</strong></td>
<td style="text-align:center">specSize</td>
</tr>
</tbody>
</table>
</div>
<p><strong>即仅在容器指定尺寸模式为 UNSPECIFIED 的情况下使用最小尺寸，其余情况可以默认这一步不存在。</strong></p>
<blockquote>
<p>这里有一个问题如果控件采用 warp_content，那么到这一步的 specSize 实际是容器的尺寸。<strong>这说明默认情况下处理 warp_content 是不合理，自定义控件直接继承View时要注意。</strong></p>
</blockquote>
<p>最后就是为测量尺寸 mMeasuredWidth 和 mMeasuredHeight 赋值。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">setMeasuredDimensionRaw</span><span class="params">(<span class="keyword">int</span> measuredWidth, <span class="keyword">int</span> measuredHeight)</span> </span>&#123;</span><br><span class="line">    mMeasuredWidth = measuredWidth;</span><br><span class="line">    mMeasuredHeight = measuredHeight;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="resolveSizeAndState"><a href="#resolveSizeAndState" class="headerlink" title="resolveSizeAndState"></a>resolveSizeAndState</h3><p>刚才说了默认的 measureChild 在碰到子控件设置了 warp_content 时会取容器尺寸的问题，除非子控件不采用默认的自测量方式。这个问题可以用 resolveSizeAndState 方法修复。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> size How big the view wants to be.</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> measureSpec Constraints imposed by the parent.</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> childMeasuredState Size information bit mask for the view's children.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">int</span> <span class="title">resolveSizeAndState</span><span class="params">(<span class="keyword">int</span> size, <span class="keyword">int</span> measureSpec, <span class="keyword">int</span> childMeasuredState)</span></span>;</span><br></pre></td></tr></table></figure>
<div class="table-container">
<table>
<thead>
<tr>
<th>specMode</th>
<th style="text-align:center">AT_MOST</th>
<th style="text-align:center">EXACTLY</th>
<th style="text-align:center">UNSPECIFIED</th>
</tr>
</thead>
<tbody>
<tr>
<td>最终尺寸</td>
<td style="text-align:center"><strong>Min(specSize, size)</strong></td>
<td style="text-align:center">specSize</td>
<td style="text-align:center">size</td>
</tr>
</tbody>
</table>
</div>
<p><strong>resolveSizeAndState 方法和 getDefaultSize 方法不同之处在于如何解析 AT_MOST，这是关键之处。</strong></p>
<p>即将默认的测量方法改为</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">onMeasure</span><span class="params">(<span class="keyword">int</span> widthMeasureSpec, <span class="keyword">int</span> heightMeasureSpec)</span> </span>&#123;</span><br><span class="line">    setMeasuredDimension(</span><br><span class="line">      resolveSizeAndState(getSuggestedMinimumWidth(), widthMeasureSpec, MEASURED_STATE_MASK),</span><br><span class="line">      resolveSizeAndState(getSuggestedMinimumHeight(), heightMeasureSpec, MEASURED_STATE_MASK));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="自定义测量方法"><a href="#自定义测量方法" class="headerlink" title="自定义测量方法"></a>自定义测量方法</h3><p>如果想达到一些其它效果，如在 DrawLayout 中要求内容控件占据容器，实际上在 LayoutParams 上的设置已无任何意义，测量时完全不予考虑，这时就要求抛弃默认的测量方法，去自定义测量方法。</p>
<p><strong>自定义测量方法y要依赖控件的自测量方法，其核心在于在合适的时机改造复合尺寸。</strong></p>
<p>例如要求一个控件占据容器是最容易的情况，此时完全不用考虑容器Spec模式和 LayoutParams 参数。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">mContent.measure(</span><br><span class="line">   MeasureSpec.makeMeasureSpec(</span><br><span class="line">        getMeasuredWidth() - getPaddingLeft() - getPaddingRight(), MeasureSpec.EXACTLY), </span><br><span class="line">   MeasureSpec.makeMeasureSpec(</span><br><span class="line">        getMeasuredHeight() - getPaddingTop() - getPaddingBottom(), MeasureSpec.EXACTLY)</span><br><span class="line">);</span><br></pre></td></tr></table></figure>
<p>在控件内部首先对传入的尺寸进行改造</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">onMeasure</span><span class="params">(<span class="keyword">int</span> widthSpec, <span class="keyword">int</span> heightSpec)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">switch</span> (MeasureSpec.getMode(widthSpec)) &#123;</span><br><span class="line">        <span class="keyword">case</span> MeasureSpec.EXACTLY:</span><br><span class="line">            <span class="comment">// Nothing to do</span></span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        <span class="keyword">case</span> MeasureSpec.AT_MOST:</span><br><span class="line">            widthSpec = MeasureSpec.makeMeasureSpec(</span><br><span class="line">                    Math.min(MeasureSpec.getSize(widthSpec), mMaxWidth), MeasureSpec.EXACTLY);</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        <span class="keyword">case</span> MeasureSpec.UNSPECIFIED:</span><br><span class="line">            widthSpec = MeasureSpec.makeMeasureSpec(mMaxWidth, MeasureSpec.EXACTLY);</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// Let super sort out the height</span></span><br><span class="line">    <span class="keyword">super</span>.onMeasure(widthSpec, heightSpec);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>最要命的情况是要同时处理容器Spec模式和 LayoutParams 参数共九种情况，不过好在遵循 getChildMeasureSpec 方法的套路就行。</p>
<h3 id="布局机制"><a href="#布局机制" class="headerlink" title="布局机制"></a>布局机制</h3><p>布局机制比测量机制要简单地多，但应该注意到布局时会掉用测量过程，此外有时子控件如何布局与 LayoutParams 参数有关，布局时要考虑 padding 和 margin 的影响，获取控件宽度不应该用 LayoutParams.width (可能为负值) 等等。</p>
<h3 id="触摸机制"><a href="#触摸机制" class="headerlink" title="触摸机制"></a>触摸机制</h3><p>触摸机制首先从 Activity 开始，而后有ViewRootImpl传递下去</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">dispatchTouchEvent</span><span class="params">(MotionEvent ev)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (getWindow().superDispatchTouchEvent(ev)) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> onTouchEvent(ev);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><strong>默认的处理流程是一个来回：一半是事件分发(dispatchTouchEvent方法)，一半是事件处理(onTouch 方法)。</strong>其中容器 ViewGroup 和控件 View 的分发方法是不一致的，前者会使用 onInterceptTouchEvent 方法拦截事件，且默认情况下不拦截，逐层交给子控件分发，直到根View；控件 View 的分发会调用事件处理，且会逐级上溯，直到返回 Activity 。</p>
<p>假设布局层级是 TopLayout，BottomLayout 和 CircleImage，则默认情况下流程是</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">//1.向下传递拦截事件</span><br><span class="line">TopLayout onInterceptTouchEvent: false 0</span><br><span class="line">BottomLayout onInterceptTouchEvent: false 0</span><br><span class="line">//2.向上传递处理事件</span><br><span class="line">CircleImage onTouchEvent: false 0</span><br><span class="line">CircleImage dispatchTouchEvent: false 0</span><br><span class="line">BottomLayout onTouchEvent: false 0</span><br><span class="line">BottomLayout dispatchTouchEvent: false 0</span><br><span class="line">TopLayout onTouchEvent: false 0</span><br><span class="line">TopLayout dispatchTouchEvent: false 0</span><br><span class="line">MainActivity onTouchEvent: false 0</span><br><span class="line">MainActivity dispatchTouchEvent: false 0</span><br><span class="line">//3.无人处理</span><br><span class="line">MainActivity onTouchEvent: false 2</span><br><span class="line">MainActivity dispatchTouchEvent: false 2</span><br></pre></td></tr></table></figure>
<p><strong>默认情况下整个流程是不进行拦截的处理的，所以流程会从顶到根走一个来回，但仅能处理 Action_down 的情况，后续的其它动作如Action_Move 等将停留在Activity 中。</strong></p>
<p>如果在 BottomLayout 中截断事件，这里有几种情况。只拦截不处理和默认情况一样。同时拦截和处理结果如下</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">TopLayout onInterceptTouchEvent: false ACTION_DOWNBottomLayout onInterceptTouchEvent: true ACTION_DOWN //拦截方法只能执行一次BottomLayout onTouchEvent: true ACTION_DOWNBottomLayout dispatchTouchEvent: true ACTION_DOWNTopLayout dispatchTouchEvent: true ACTION_DOWNMainActivity dispatchTouchEvent: true ACTION_DOWNTopLayout onInterceptTouchEvent: false ACTION_MOVE  //父布局的拦截方法倒是能多次执行BottomLayout onTouchEvent: true ACTION_MOVEBottomLayout dispatchTouchEvent: true ACTION_MOVETopLayout dispatchTouchEvent: true ACTION_MOVE //消灭这一行，禁止 TopLayout 拦截MainActivity dispatchTouchEvent: true ACTION_MOVETopLayout onInterceptTouchEvent: false ACTION_UPBottomLayout onTouchEvent: true ACTION_UPBottomLayout dispatchTouchEvent: true ACTION_UPTopLayout dispatchTouchEvent: true ACTION_UPMainActivity dispatchTouchEvent: true ACTION_UP</span><br></pre></td></tr></table></figure>
<p>即流程到 BottomLayout 这一层被截断了，如果要 TopLayout 不进行拦截，可以使用下列方法</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">getParent().requestDisallowInterceptTouchEvent(<span class="keyword">true</span>);</span><br></pre></td></tr></table></figure>
<p>如果不拦截，只处理结果如下</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">TopLayout onInterceptTouchEvent: false 0BottomLayout onInterceptTouchEvent: false 0CircleImage onTouchEvent: false 0CircleImage dispatchTouchEvent: false 0BottomLayout onTouchEvent: true 0BottomLayout dispatchTouchEvent: true 0TopLayout dispatchTouchEvent: true 0MainActivity dispatchTouchEvent: true 0TopLayout onInterceptTouchEvent: false 2BottomLayout onTouchEvent: true 2BottomLayout dispatchTouchEvent: true 2TopLayout dispatchTouchEvent: true 2MainActivity dispatchTouchEvent: true 2TopLayout onInterceptTouchEvent: false 1BottomLayout onTouchEvent: true 1BottomLayout dispatchTouchEvent: true 1TopLayout dispatchTouchEvent: true 1MainActivity dispatchTouchEvent: true 1</span><br></pre></td></tr></table></figure>
<p><strong>区别是下面的子控件还能得到一次处理的机会， 否则即便子控件设置了处理方法，也不会得到执行机会。当然如果子控件不处理，那么以后依然将会被屏蔽。</strong></p>
<blockquote>
<p>监听器是事件处理的特殊情况，如果配置了监听器，等同于设置了事件处理。如果容器和子控件都配置了监听器，那么按照事件处理的顺序是子控件优先截断控制权；容器如果想夺回控制权，只能使用拦截方法进行拦截。</p>
</blockquote>
<h3 id="修改触摸机制"><a href="#修改触摸机制" class="headerlink" title="修改触摸机制"></a>修改触摸机制</h3><p><strong>修改触摸机制的核心是确定那个控件在哪种情况下能够进行拦截和消费事件，这样使得不同的控件都有机会处理触摸事件。</strong></p>
<p>先说下可以着手的三个地方</p>
<ul>
<li><strong>onInterceptTouchEvent 方法：返回 true，则事件不再向下分发，即屏蔽了子控件，使得子控件设置的点击事件失效，因此要谨慎使用。此外如果容器消费了事件，该方法只执行一次。</strong></li>
<li>onTouchEvent 方法：返回 true，则此后的处理流程就到这一层。</li>
<li>dispatchTouchEvent 方法：返回 true，<strong>此时不管*onTouchEvent 方法如何，都能形成闭合流程。</strong></li>
</ul>
<p>例如我们要求在 TopLayout 中拦截左右滑动，在 BottomLayout 中拦截 上下滑动，同时也要保证 CircleImage 能够响应点击事件。</p>
<p>三个控件都要能拦截事件，这就要求它们各自精确拦截自己的那一部分。</p>
<p><strong>首先给 CircleImage 设置一个监听器，此时事件是到 CircleImage 这里得到处理的，但TopLayout 和 BottomLayout 还有拦截事件的机会。</strong></p>
<p><strong>再来改造 TopLayout ，前提是不能拦截 ACTION_DOWN 和 ACTION_UP，这样就屏蔽了子控件的点击监听，这两个动作里只能做一些初始化和清理的工作。而后在 ACTION_MOVE 中进行拦截</strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">onInterceptTouchEvent</span><span class="params">(MotionEvent ev)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">boolean</span> isIntercept = <span class="keyword">false</span>;</span><br><span class="line">    <span class="keyword">int</span> action = ev.getAction();</span><br><span class="line">    <span class="keyword">switch</span> (action) &#123;</span><br><span class="line">        <span class="keyword">case</span> MotionEvent.ACTION_DOWN:</span><br><span class="line">            isIntercept = <span class="keyword">false</span>;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        <span class="keyword">case</span> MotionEvent.ACTION_MOVE:</span><br><span class="line">            <span class="keyword">if</span> (<span class="string">"左右滑动"</span>) &#123;</span><br><span class="line">                isIntercept = <span class="keyword">true</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        <span class="keyword">case</span> MotionEvent.ACTION_UP:</span><br><span class="line">        <span class="keyword">default</span>:</span><br><span class="line">            isIntercept = <span class="keyword">false</span>;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> isIntercept;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>还有在 onTouchEvent 方法里也不能在 ACTION_DOWN 和 ACTION_UP 里进行事件的处理，这样也会导致子控件的点击事件失效。只能在 ACTION_MOVE 进行相同条件下的处理，这样才能构成闭环处理流程。</p>
<p>最后是 BottomLayout ，和TopLayout 类似，只需要改一下拦截和处理的条件。</p>
<blockquote>
<p>这里三个控件都要获得拦截事件的机会，底层的控件尤其重要，它要求响应点击事件的特性使得父控件无法拦截和处理 ACTION_DOWN 和 ACTION_UP。父控件之间更是不得不小心翼翼，避免彼此之间的冲突。</p>
</blockquote>
<h4 id="实践：点击控件带扩张效果"><a href="#实践：点击控件带扩张效果" class="headerlink" title="实践：点击控件带扩张效果"></a>实践：点击控件带扩张效果</h4><p><img src="https://cloud.githubusercontent.com/assets/24237865/22188970/cc138f6a-e15c-11e6-8a17-a8bccb3e6dcd.gif" alt="ElasticViews"></p>
<p>要达成这样的效果，且要求保留子控件的点击事件，实际上不需要进行事件的拦截，只需要在 dispatchTouchEvent 中添加一个动画即可。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">dispatchTouchEvent</span><span class="params">(MotionEvent event)</span> </span>&#123;</span><br><span class="line">    <span class="comment">//只处理 ACTION_UP，防止执行多个动画，造成View参数紊乱</span></span><br><span class="line">    <span class="keyword">if</span>(event.getAction() == MotionEvent.ACTION_UP) &#123; </span><br><span class="line">        ViewCompat.animate(view).setDuration(duration)</span><br><span class="line">          .scaleX(scale).scaleY(scale).setInterpolator(<span class="keyword">new</span> CycleInterpolator(<span class="number">0.5f</span>))</span><br><span class="line">          .withLayer()</span><br><span class="line">          .start();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">super</span>.dispatchTouchEvent(event);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<blockquote>
<p>这里要注意的是如果容器即其子控件不设置点击事件监听器，那么可以不加第一行，因为此时dispatchTouchEvent只执行一次，在ACTION_DOWN之后就被屏蔽了；</p>
<p>然而这过于理想了，一旦有一个子控件拦截的事件，将造成多个动画同时执行，View的scale参数将紊乱。因此为了安全，需要添加第一行。</p>
</blockquote>
<h4 id="MotionEvent和手势"><a href="#MotionEvent和手势" class="headerlink" title="MotionEvent和手势"></a>MotionEvent和手势</h4><p>动作包含动作码和坐标集合两个部分，前者表示是按下还是离开等；此外多触摸屏幕还可以响应多个手指，其中只能有一个起作用的，即常见的 mActivePointerId。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">final</span> <span class="keyword">int</span> action = MotionEventCompat.getActionMasked(event);</span><br><span class="line"><span class="keyword">final</span> <span class="keyword">int</span> actionIndex = MotionEventCompat.getActionIndex(event);</span><br><span class="line"><span class="keyword">int</span> pointerCount = event.getPointerCount();</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; pointerCount; i++) &#123;</span><br><span class="line">    <span class="keyword">int</span> pointerId = event.getPointerId(i);</span><br><span class="line">    <span class="keyword">float</span> x = event.getX(actionIndex);</span><br><span class="line">    <span class="keyword">float</span> y = event.getY(actionIndex);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<blockquote>
<p>手势库：<a href="https://github.com/nisrulz/sensey" target="_blank" rel="noopener">Sensey</a></p>
</blockquote>
<h3 id="滚动机制-Scroller"><a href="#滚动机制-Scroller" class="headerlink" title="滚动机制(Scroller)"></a>滚动机制(Scroller)</h3><p><strong>scrollTo 方法就能够使得控件内容移位，其原理是改变参数 mScrollX/mScrollY ，这两个数值会在绘制的时候移动绘制区域，这是滚动机制的基础。</strong></p>
<p><strong>scrollTo 方法的问题在于滚动花费的时间太短，Scroller 通过拉长这个时间带来平滑的视觉效果，具体做法是将整个过程拆分成若干的步进过程，逐步改变 mScrollX/mScrollY 的数值。</strong></p>
<p>Scroller 类本身是一个纯属性类，只需要传入滑动时间，起始值等描述一次滑动过程的必要参数。但它并不能直接滑动控件，想要滑动控件需要与具体控件配合驱动步进计算。Scroller类的手动更新方法是</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//1.启动滚动过程</span></span><br><span class="line">mScroller.startScroll(getScrollX(), getScrollY(), <span class="number">100</span>, <span class="number">100</span>);</span><br><span class="line">invalidate();</span><br><span class="line"><span class="comment">//2.自我驱动</span></span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">computeScroll</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (mScroller != <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="keyword">if</span> (mScroller.computeScrollOffset()) &#123;                    <span class="comment">//判断是否完成</span></span><br><span class="line">            scrollTo(mScroller.getCurrX(), mScroller.getCurrY()); <span class="comment">//实现滚动的一小步 </span></span><br><span class="line">            setAlpha(<span class="number">1f</span>*scroller.getCurrX()/scroller.getFinalX());<span class="comment">//附加效果</span></span><br><span class="line">            postInvalidate();                                     <span class="comment">//实现滚动循环</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>
<p><strong>这里达成真实的滚动效果是靠改变控件 mScrollX/mScrollY 位置来产生的，完全可以考改变其它属性来达成其它动画效果。</strong></p>
<p>为了兼容性，可以使用类ScrollerCompat代替实现，该类还提供了fling 和 springback 两种滑动方式。</p>
<h3 id="绘制机制与动画机制"><a href="#绘制机制与动画机制" class="headerlink" title="绘制机制与动画机制"></a>绘制机制与动画机制</h3><p>View 的实际绘制区域与布局区域是不一致的，它与 mScrollX/mScrollY 有关</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">getDrawingRect</span><span class="params">(Rect outRect)</span> </span>&#123;    </span><br><span class="line">    outRect.left = mScrollX;    </span><br><span class="line">    outRect.top = mScrollY;    </span><br><span class="line">    outRect.right = mScrollX + (mRight - mLeft);    </span><br><span class="line">    outRect.bottom = mScrollY + (mBottom - mTop);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><strong>在 onDraw 方法上添加附加效果是一种常用的手段。</strong></p>
<p>View 可以执行三种动画</p>
<p>1.补间动画</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">startAnimation</span><span class="params">(Animation animation)</span></span></span><br></pre></td></tr></table></figure>
<p>2.状态转移动画</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setStateListAnimator</span><span class="params">(StateListAnimator stateListAnimator)</span></span>;</span><br></pre></td></tr></table></figure>
<p>3.属性动画</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> ViewPropertyAnimator <span class="title">animate</span><span class="params">()</span></span>;</span><br></pre></td></tr></table></figure>
<h4 id="EdgeEffect"><a href="#EdgeEffect" class="headerlink" title="EdgeEffect"></a>EdgeEffect</h4><p>EdgeEffect 是用来绘制边界阴影的，它的实质是画一个弧顶过某边的圆，同时截取弧顶部分。默认情况下绘制的顶边。</p>
<p>通过 onPull, onAbsorb 方法，EdgeEffect 可以控制弧顶漏出的比例，这是纯属性设置的方法，必须刷新绘制才能生效。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onPull</span><span class="params">(<span class="keyword">float</span> deltaDistance, <span class="keyword">float</span> displacement)</span></span></span><br></pre></td></tr></table></figure>
<p>通过 onRelease 方法可以产生回弹，这与Scroll 自我驱动更新的原理是一样的</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">draw</span><span class="params">(Canvas canvas)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">super</span>.draw(canvas);</span><br><span class="line">    edge.setSize(getWidth(), getHeight());</span><br><span class="line">    <span class="keyword">if</span> (!edge.isFinished()) &#123;</span><br><span class="line">        <span class="keyword">final</span> <span class="keyword">int</span> restoreCount = canvas.save();</span><br><span class="line">        <span class="keyword">if</span>(edge.draw(canvas))&#123;</span><br><span class="line">            postInvalidate();</span><br><span class="line">        &#125;</span><br><span class="line">        canvas.restoreToCount(restoreCount);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>在实际的使用中，应该给每一个边设置一个 EdgeEffectCompat , 这需要移位，旋转等操作 。以右边为例</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">canvas.rotate(<span class="number">90</span>); <span class="comment">//画布旋转90度，意味着坐标轴也偏移了90度，</span></span><br><span class="line">canvas.translate(<span class="number">0</span>,-getWidth()); <span class="comment">//此时 y 轴实际是向左，故而反向回退一个宽度，矫正弧顶矩形</span></span><br><span class="line">edge.setSize(getHeight(), getWidth());</span><br></pre></td></tr></table></figure>
<p>左边</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">canvas.rotate(<span class="number">270</span>); <span class="comment">//画布旋转270度，此时y轴向右</span></span><br><span class="line">canvas.translate(-getHeight(), <span class="number">0</span>);<span class="comment">//弧顶矩形需要下移</span></span><br><span class="line">edge.setSize(getHeight(), getWidth());</span><br></pre></td></tr></table></figure>
<p>下边</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">canvas.rotate(<span class="number">180</span>);</span><br><span class="line">canvas.translate(-getWidth(), -getHeight());</span><br><span class="line">edge.setSize(getWidth(), getHeight());</span><br></pre></td></tr></table></figure>
<h3 id="SurfaceView"><a href="#SurfaceView" class="headerlink" title="SurfaceView"></a><a href="http://blog.csdn.net/luoshengyang/article/details/8661317" target="_blank" rel="noopener">SurfaceView</a></h3><p>SurfaceView 在一个独立的线程中进行绘制，不在主线程中不会占用主线程资源，一方面可以实现复杂而高效的UI，另一方面又不会导致用户输入得不到及时响应。由于应用程序的主线程除了要绘制UI之外，还需要及时地响应用户输入，否则的话，系统就会认为应用程序没有响应了，因此就会弹出一个ANR对话框出来。对于一些游戏画面就不适合在应用程序的主线程中进行绘制。这时候就可以使用 SurfaceView 。一个Surface绘图示例如下</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">SurfaceView surfaceView = (SurfaceView) findViewById(R.id.surfaceview);</span><br><span class="line"><span class="comment">//1. 获取 SurfaceView 对象内部类SurfaceHolder</span></span><br><span class="line">SurfaceHolder holder = surfaceView.getHolder();</span><br><span class="line"><span class="comment">//2. SurfaceHolder对象添加Callback接口，执行在UI线程</span></span><br><span class="line">holder.addCallback(<span class="keyword">new</span> SurfaceHolder.Callback() &#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">surfaceCreated</span><span class="params">(SurfaceHolder holder)</span></span></span><br><span class="line"><span class="function">    </span></span><br><span class="line"><span class="function">    <span class="comment">//4.Surface设置参数被改变将调用此回调方法，实现主要绘制逻辑</span></span></span><br><span class="line"><span class="function">    @Override</span></span><br><span class="line"><span class="function">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title">surfaceChanged</span><span class="params">(SurfaceHolder holder, <span class="keyword">int</span> format, <span class="keyword">int</span> width, <span class="keyword">int</span> height)</span> </span>&#123;</span><br><span class="line">        <span class="comment">//1. 通过锁定获取canvas对象，开始编辑底层像素</span></span><br><span class="line">        Canvas canvas = holder.lockCanvas();</span><br><span class="line">        canvas.drawColor(<span class="number">0x4398ff</span>);</span><br><span class="line">        <span class="comment">//2. 消除canvas对象，结束像素编辑</span></span><br><span class="line">        holder.unlockCanvasAndPost(canvas);</span><br><span class="line">        <span class="comment">//3. 再次锁定并取消锁定</span></span><br><span class="line">        canvas = holder.lockCanvas(<span class="keyword">new</span> Rect(<span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>));</span><br><span class="line">        holder.unlockCanvasAndPost(canvas);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">surfaceDestroyed</span><span class="params">(SurfaceHolder holder)</span></span></span><br><span class="line"><span class="function">&#125;)</span>;</span><br></pre></td></tr></table></figure>
<p>SurfaceView 有两个子类<code>GLSurfaceView</code>和<code>VideoView</code>，可见视频图像亦是靠<code>Surface</code>机制来渲染。<code>SurfaceView</code>是一个专门负责绘制<code>Surface</code>内容的<code>View</code>对象，它最大的优点是使用单独线程完成绘制工作。</p>
<p>通常每个窗口背后对应一个<code>Surface</code>，不同<code>Surface</code>的Z序列不同，在底层将这些<code>Surface</code>的内容合成；<code>Surface</code>可以理解成绘制内容数据。</p>
<p>绘制工作主要是由SurfaceHolder来完成的。SurfaceHolder负责与 Surface 内容数据打交道，可以控制比如<code>Surface</code>尺寸，格式，像素并监听<code>Surface</code>的变化。</p>
<p>一般而言，SurfaceView 进入前台时 Surface 内容被创建，转入后台则被销毁；这是Android系统内存管理的特征；在 Surface 内容被创建后可以通过 holder.lockCanvas(Rect dirty); 获得一个 canvas 对象，对 dirty 矩形区域内进行绘制；此时脏区内的 Surface 内容被锁定是线程安全的;使用 unlockCanvasAndPost(canvas) 方法释放锁定后，脏区内容将被系统渲染展示到屏幕上。<strong>但数据内容没有被清除；因此如果更改了绘制区域后，将绘制先前内容。因此使用holder.lockCanvas(new Rect(0, 0, 0, 0)) 锁定并取消锁定的方法清除内容。</strong></p>
<h3 id="ViewTreeObserver"><a href="#ViewTreeObserver" class="headerlink" title="ViewTreeObserver"></a>ViewTreeObserver</h3><p>ViewTreeObserver 接口可以响应视图树的变化，其中最重要的一个接口就是 OnPreDrawListener</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">OnPreDrawListener</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">onPreDraw</span><span class="params">()</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><strong>这个接口之所以重要在于它的执行时机非常好，处在布局之后，绘制之前，各项参数(如尺寸和位置)均已确定，正是使用各种 trick 的方法。</strong></p>
<p>此外一个使用较多的接口是 OnGlobalLayoutListener ，执行时间在控件发生 visibility 的变化。</p>
<h2 id="各种子控件"><a href="#各种子控件" class="headerlink" title="各种子控件"></a>各种子控件</h2><h3 id="Space-与-ViewStub"><a href="#Space-与-ViewStub" class="headerlink" title="Space 与 ViewStub"></a>Space 与 ViewStub</h3><p>Space 是一个典型的占位控件，它始终处于 INVISIBLE 状态，参与测量和布局，但 draw 方法为空。</p>
<p>ViewStub 则处于 GONE 状态，这意味着它没有尺寸， draw 方法也为空。 直到执行 inflate() 方法载入其它控件</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">ViewStub stub = (ViewStub) findViewById(R.id.stub);</span><br><span class="line">View inflated = stub.inflate();</span><br></pre></td></tr></table></figure>
<p>ViewStub 会将子布局加载到它的父布局中去，新的子布局将继承原 ID，同时让父布局移除自己。</p>
<h3 id="FrameLayout"><a href="#FrameLayout" class="headerlink" title="FrameLayout"></a>FrameLayout</h3><p>FrameLayout 测量时以子控件的最大高度/宽度作为自己的尺寸。它的 LayoutParams 多了一个参数，并利用这个参数来对齐</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">int</span> gravity = UNSPECIFIED_GRAVITY;</span><br></pre></td></tr></table></figure>
<p>在布局方法中根据子控件的 gravity 参数来对齐子控件</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">final</span> <span class="keyword">int</span> layoutDirection = getLayoutDirection();</span><br><span class="line"><span class="keyword">final</span> <span class="keyword">int</span> absoluteGravity = Gravity.getAbsoluteGravity(gravity, layoutDirection);</span><br><span class="line"><span class="keyword">final</span> <span class="keyword">int</span> verticalGravity = gravity &amp; Gravity.VERTICAL_GRAVITY_MASK;</span><br></pre></td></tr></table></figure>
<p>absoluteGravity 决定了子控件的 left 位置，verticalGravity 决定了子控件的 top 位置，计算如下</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">switch</span> (absoluteGravity &amp; Gravity.HORIZONTAL_GRAVITY_MASK) &#123;</span><br><span class="line">    <span class="keyword">case</span> Gravity.CENTER_HORIZONTAL:</span><br><span class="line">        childLeft = parentLeft + (parentRight - parentLeft - width) / <span class="number">2</span> +</span><br><span class="line">        lp.leftMargin - lp.rightMargin;</span><br><span class="line">    <span class="keyword">case</span> Gravity.RIGHT:</span><br><span class="line">        childLeft = parentRight - width - lp.rightMargin;</span><br><span class="line">    <span class="keyword">case</span> Gravity.LEFT:</span><br><span class="line">        childLeft = parentLeft + lp.leftMargin;</span><br><span class="line">&#125;</span><br><span class="line">child.layout(childLeft, childTop, childLeft + width, childTop + height);</span><br></pre></td></tr></table></figure>
<h4 id="ViewAnimator"><a href="#ViewAnimator" class="headerlink" title="ViewAnimator"></a>ViewAnimator</h4><p>ViewAnimator 是 FrameLayout 的子类，在切换布局时能够执行动画。这种效果是重写 addView 和 removeView 方法来实现的，其子类有 TextSwitcher，ImageSwitcher 和 ViewFlipper。</p>
<p>ViewFlipper 能够自动播放，这是通过在 onAttachedToWindow 方法中启动线程循环达成的，有意思的是它还使用广播接收器处理了屏幕熄灭和用户划开屏幕保护锁的广播</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">onAttachedToWindow</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">super</span>.onAttachedToWindow();</span><br><span class="line">    <span class="keyword">final</span> IntentFilter filter = <span class="keyword">new</span> IntentFilter();</span><br><span class="line">    filter.addAction(Intent.ACTION_SCREEN_OFF);</span><br><span class="line">    filter.addAction(Intent.ACTION_USER_PRESENT);</span><br><span class="line">    getContext().registerReceiverAsUser(mReceiver, android.os.Process.myUserHandle(),</span><br><span class="line">            filter, <span class="keyword">null</span>, getHandler());</span><br><span class="line">    <span class="keyword">if</span> (mAutoStart) &#123;</span><br><span class="line">        startFlipping();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">onDetachedFromWindow</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">super</span>.onDetachedFromWindow();</span><br><span class="line">    mVisible = <span class="keyword">false</span>;</span><br><span class="line">    getContext().unregisterReceiver(mReceiver);</span><br><span class="line">    updateRunning();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="HorizontalScrollView"><a href="#HorizontalScrollView" class="headerlink" title="HorizontalScrollView"></a>HorizontalScrollView</h3><p>HorizontalScrollView 是一个继承 FrameLayout 的水平滚动控件，只应有一个子控件，它的滚动被称之为覆盖滚动(<code>OverScroll</code>)，需要处理<strong>容器自身的尺寸小于它所容纳的子控件的尺寸</strong>的情况。</p>
<p>覆盖滚动有三种类型</p>
<ul>
<li>OVER_SCROLL_NEVER 子控件永远被束缚在容器内</li>
<li>OVER_SCROLL_ALWAYS 子控件永远能够滚动出容器外</li>
<li>OVER_SCROLL_IF_CONTENT_SCROLLS 只有子控件大于容器才能发生</li>
</ul>
<p>1.测量方法：容器只处理水平滚动，在垂直方向上倾向于将子控件完全扩展，且以自身容器宽度作为子控件宽度。如果不想这么做，可以设置参数 FillViewport 为 false。</p>
<p>2.拦截方法： 容器根据控件是否处于拖动状态决定是否拦截，只有处在MotionEvent.ACTION_MOVE 状态，滑动距离足够且触摸点在子控件内可以拦截此事件。发生拦截后，在事件处理方法中完成覆盖滑动。这一过程本质上是通过改变 mScrollX/mScrollY 的位置来实现的。</p>
<p>a.是否能够进行覆盖滑动，由滑动方式和滑动范围决定。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> range = getScrollRange();<span class="comment">//计算滑动范围int </span></span><br><span class="line">overscrollMode = getOverScrollMode();<span class="comment">//计算覆盖滑动方式</span></span><br><span class="line"><span class="keyword">boolean</span> canOverscroll = overscrollMode == OVER_SCROLL_ALWAYS ||(overscrollMode == OVER_SCROLL_IF_CONTENT_SCROLLS &amp;&amp; range &gt; <span class="number">0</span>);</span><br></pre></td></tr></table></figure>
<p>b.覆盖滑动范围为子控件宽度与容器宽度的差值，计算如下</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Math.max(<span class="number">0</span>,child.getWidth() - (getWidth() - mPaddingLeft - mPaddingRight);</span><br></pre></td></tr></table></figure>
<p>滑动范围为<strong>子控件的宽度-容器的内容宽度</strong>，而且如果此值为负，就无法滑动。因此<strong>只有子控件的宽度大于容器宽度才能产生滑动</strong>，这也是判断子控件能否滚动的依据。</p>
<p>c.覆盖滑动的行为由 overScrollBy 完成</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//mOverscrollDistance 指的是触发边界效应的距离</span></span><br><span class="line">overScrollBy(deltaX, <span class="number">0</span>, mScrollX, <span class="number">0</span>, range, <span class="number">0</span>, mOverscrollDistance, <span class="number">0</span>, <span class="keyword">true</span>)</span><br></pre></td></tr></table></figure>
<p>该方法采用 Scroller 来进行滑动，会修正新的 ScrollX 和 ScrollY 值，。</p>
<p>4.<strong>翻页滑动</strong>和<strong>全页滑动</strong></p>
<p><strong>翻页滑动(pageScroll)，点击 (shift+)space可以调用</strong>，这里的页宽就是容器的宽度，如果向左翻页<br>则左边界为<code>Math.max(0,getScrollX() - width)</code>，右边界为<code>right = mTempRect.left + width</code>。</p>
<p><strong>全页滑动(fullScroll 包括 arrowScroll)，点击 (alt+)Pad key可以调用</strong>，如果向左翻页，左边界为0，右边界为<code>width</code>，即容器宽度。如果向右翻页，左右边界确定如下</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">View view = getChildAt(<span class="number">0</span>);</span><br><span class="line">mTempRect.right = view.getRight();</span><br><span class="line">mTempRect.left = mTempRect.right - width;</span><br></pre></td></tr></table></figure>

        
      
    </div>

    
    
    
      <footer class="post-footer">
          <div class="post-eof"></div>
        
      </footer>
  </div>
  
  
  
  </article>

    
        <article itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block home">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2017/08/06/android/View/动画二：布局容器动画(Transition)/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="xiang">
      <meta itemprop="description" content="谨守而勿失，是谓反其真">
      <meta itemprop="image" content="/images/1.jpg">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="lxt">
    </span>
      <header class="post-header">
        <h1 class="post-title" itemprop="name headline">
            
            <a href="/2017/08/06/android/View/动画二：布局容器动画(Transition)/" class="post-title-link" itemprop="url">动画二：布局容器动画(Transition)</a>
          
        </h1>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              
                
              

              <time title="创建时间：2017-08-06 21:26:26" itemprop="dateCreated datePublished" datetime="2017-08-06T21:26:26+08:00">2017-08-06</time>
            </span>
          
            

            
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="fa fa-calendar-check-o"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2019-09-18 16:03:36" itemprop="dateModified" datetime="2019-09-18T16:03:36+08:00">2019-09-18</time>
              </span>
            
          
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing"><a href="/categories/android/" itemprop="url" rel="index"><span itemprop="name">android</span></a></span>

                
                
                  ，
                
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing"><a href="/categories/android/View/" itemprop="url" rel="index"><span itemprop="name">View</span></a></span>

                
                
              
            </span>
          

          
          <br>
            <span class="post-meta-item" title="本文字数">
              <span class="post-meta-item-icon">
                <i class="fa fa-file-word-o"></i>
              </span>
              
                <span class="post-meta-item-text">本文字数：</span>
              
              <span>10k</span>
            </span>
          
            <span class="post-meta-item" title="阅读时长">
              <span class="post-meta-item-icon">
                <i class="fa fa-clock-o"></i>
              </span>
              
                <span class="post-meta-item-text">阅读时长 &asymp;</span>
              
              <span>9 分钟</span>
            </span>
          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h2 id="布局容器动画：android-transition"><a href="#布局容器动画：android-transition" class="headerlink" title=" 布局容器动画：android.transition"></a><a href="https://github.com/andkulikov/Transitions-Everywhere" target="_blank" rel="noopener"> 布局容器动画：android.transition</a></h2><p>Transition 是布局容器发生变化(包括其内部的控件发生变化：如添加控件，某个控件改变颜色)时应用的一种动画。</p>
<p>Transition 的简单调用如下</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">TransitionManager.beginDelayedTransition(sceneRoot);<span class="comment">//默认采用A utoTransition</span></span><br></pre></td></tr></table></figure>
<p>也可以使用 Scene</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Scene scene = <span class="keyword">new</span> Scene(sceneRoot, textView);</span><br><span class="line">TransitionManager.go(scene, <span class="keyword">new</span> Fade(Fade.IN));</span><br></pre></td></tr></table></figure>
<p><strong>此时实际并不能执行动画，只有当布局发生变化时才会执行，且一次设置只能执行一次</strong>。<strong>动画发生的准确时间是在onPreDraw方法中。</strong></p>
<h3 id="Scene"><a href="#Scene" class="headerlink" title="Scene"></a>Scene</h3><p>首先来看Scene类，Scene 定义如下，它需要一个已经存在的容器(mSceneRoot)，和一个新的控件或布局(mLayoutId或mLayout)。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">final</span> <span class="class"><span class="keyword">class</span> <span class="title">Scene</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> Context mContext;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> mLayoutId = -<span class="number">1</span>; <span class="comment">//待加入到根布局中的布局，必须没有父控件</span></span><br><span class="line">    <span class="keyword">private</span> ViewGroup mSceneRoot; <span class="comment">//根布局，必须已经存在</span></span><br><span class="line">    <span class="keyword">private</span> View mLayout; <span class="comment">// alternative to layoutId</span></span><br><span class="line">    Runnable mEnterAction, mExitAction;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><strong>进入场景(Scene )的执行方法 enter 如下，实际是将容器的控件清空，添加新控件并将Scene对象自身存储进容器中。</strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">enter</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    getSceneRoot().removeAllViews();</span><br><span class="line">  </span><br><span class="line">    mSceneRoot.addView(mLayout);</span><br><span class="line">    LayoutInflater.from(mContext).inflate(mLayoutId, mSceneRoot);</span><br><span class="line">    mEnterAction.run();</span><br><span class="line">  </span><br><span class="line">    setCurrentScene(mSceneRoot, <span class="keyword">this</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><strong>根布局对象 sceneRoot 中的 Tag 对象是一个SparseArray<scene>集合，用 layoutId 作为键 新创建的 Scene 对象存储进去，反过来也能从中获取Scene对象。</scene></strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">static</span> Scene <span class="title">getCurrentScene</span><span class="params">(View view)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> (Scene) view.getTag(com.android.internal.R.id.current_scene);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><strong>这样原本的根布局就埋下了所需的条件，当时机成熟时将被调用，当Transition动画播放完成后将被清除</strong></p>
<h3 id="TransitionManager"><a href="#TransitionManager" class="headerlink" title="TransitionManager"></a>TransitionManager</h3><p>TransitionManager 是使用 Transition 的调度器，它将 Scene 和 Transition 匹配到一起，这样当某个 Scene 进入时，可以执行对应的 Transition。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">TransitionManager</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> Transition sDefaultTransition = <span class="keyword">new</span> AutoTransition();</span><br><span class="line">    ArrayMap&lt;Scene, Transition&gt; mSceneTransitions = <span class="keyword">new</span> ArrayMap&lt;Scene, Transition&gt;();</span><br><span class="line">    ArrayMap&lt;Scene, ArrayMap&lt;Scene, Transition&gt;&gt; mScenePairTransitions =</span><br><span class="line">            <span class="keyword">new</span> ArrayMap&lt;Scene, ArrayMap&lt;Scene, Transition&gt;&gt;();</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> ArrayList&lt;ViewGroup&gt; sPendingTransitions = <span class="keyword">new</span> ArrayList&lt;ViewGroup&gt;();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>也可以指定离开某Scene时的 Transition 集合，由集合mScenePairTransitions保存，其 key 是进入场景 toScene。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setTransition</span><span class="params">(Scene fromScene, Scene toScene, Transition transition)</span> </span>&#123;</span><br><span class="line">    ArrayMap&lt;Scene, Transition&gt; sceneTransitionMap = mScenePairTransitions.get(toScene);</span><br><span class="line">    sceneTransitionMap.put(fromScene, transition);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><strong>虽然 TransitionManager 保存了 Scene 和 Transition 的对应关系，但如何根据Scene获取Transition 还与所配置的 ViewGroup有关。</strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//这里Scene表示进入场景，而 sceneRoot 中存储的是当前场景，即将要离开的场景，在播放完成后要被删除；</span></span><br><span class="line"><span class="comment">//因此先获取的是离开场景，离开Transition播放完成后将获取进入场景。</span></span><br><span class="line"><span class="function"><span class="keyword">private</span> Transition <span class="title">getTransition</span><span class="params">(Scene scene)</span> </span>&#123;</span><br><span class="line">    Transition transition = <span class="keyword">null</span>;</span><br><span class="line">    ViewGroup sceneRoot = scene.getSceneRoot();</span><br><span class="line">    <span class="keyword">if</span> (sceneRoot != <span class="keyword">null</span>) &#123;</span><br><span class="line">        Scene currScene = Scene.getCurrentScene(sceneRoot);</span><br><span class="line">        <span class="keyword">if</span> (currScene != <span class="keyword">null</span>) &#123;</span><br><span class="line">            ArrayMap&lt;Scene, Transition&gt; sceneTransitionMap = mScenePairTransitions.get(scene);</span><br><span class="line">            <span class="keyword">if</span> (sceneTransitionMap != <span class="keyword">null</span>) &#123;</span><br><span class="line">                transition = sceneTransitionMap.get(currScene);</span><br><span class="line">                <span class="keyword">if</span> (transition != <span class="keyword">null</span>) &#123;</span><br><span class="line">                    <span class="keyword">return</span> transition;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    transition = mSceneTransitions.get(scene);</span><br><span class="line">    <span class="keyword">return</span> (transition != <span class="keyword">null</span>) ? transition : sDefaultTransition;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>TransitionManager 调用动画的执行过程如下</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//1.准备工作1：清理先前的 Transition，包括 TransitionManager 和 sceneRoot 内部存储的两部分</span></span><br><span class="line">ArrayList&lt;Transition&gt; runningTransitions = getRunningTransitions().get(sceneRoot);</span><br><span class="line"><span class="keyword">for</span> (Transition runningTransition : runningTransitions) &#123;</span><br><span class="line">    runningTransition.pause(sceneRoot);</span><br><span class="line">&#125;</span><br><span class="line">Scene previousScene = Scene.getCurrentScene(sceneRoot);</span><br><span class="line">previousScene.exit();</span><br><span class="line"><span class="comment">//2.准备工作2：新的 Transition 获取初始值，并清理掉 sceneRoot内部存储的 Scene 对象</span></span><br><span class="line">transition.captureValues(sceneRoot, <span class="keyword">true</span>);</span><br><span class="line">Scene.setCurrentScene(sceneRoot, <span class="keyword">null</span>);</span><br><span class="line"><span class="comment">//3.在视图树中埋点</span></span><br><span class="line">sceneRoot.getViewTreeObserver().addOnPreDrawListener(listener);</span><br><span class="line">mTransition.captureValues(mSceneRoot, <span class="keyword">false</span>);</span><br><span class="line">mTransition.playTransition(mSceneRoot);</span><br></pre></td></tr></table></figure>
<p>当视图树发生变化时将执行 OnPreDraw 方法，此时就是执行动画的时机</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//1.清理监听器和 Transition 集合</span></span><br><span class="line">removeListeners();</span><br><span class="line">sPendingTransitions.remove(mSceneRoot);</span><br><span class="line"><span class="comment">//2.此时布局过程已经完成，绘制还没有开始，是 Transition 获取终止值的绝佳时机。</span></span><br><span class="line">mTransition.captureValues(mSceneRoot, <span class="keyword">false</span>);</span><br><span class="line"><span class="comment">//3.起始值均已捕获，执行动画的条件已经成熟。</span></span><br><span class="line">mTransition.playTransition(mSceneRoot);</span><br></pre></td></tr></table></figure>
<p><strong>这里 Transition 的执行实际是放在ViewTreeObserver.OnPreDrawListener接口中进行的，以便容器 mSceneRoot 重绘前调用</strong>，在播放完成后还要进行对应清理工作。</p>
<h3 id="Transition"><a href="#Transition" class="headerlink" title="Transition"></a>Transition</h3><p>Transition 动画的数据结构是 TransitionValues，包含了待变化的属性字典</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">TransitionValues</span> </span>&#123;</span><br><span class="line">    <span class="keyword">public</span> View view;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">final</span> Map&lt;String, Object&gt; values = <span class="keyword">new</span> ArrayMap&lt;String, Object&gt;();</span><br><span class="line">    <span class="keyword">final</span> ArrayList&lt;Transition&gt; targetedTransitions = <span class="keyword">new</span> ArrayList&lt;Transition&gt;();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>Transition 中的核心就是两个 TransitionValues 集合，表示动画的起始值。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">ArrayList&lt;TransitionValues&gt; mStartValuesList; <span class="comment">// only valid after playTransition starts</span></span><br><span class="line">ArrayList&lt;TransitionValues&gt; mEndValuesList; <span class="comment">// only valid after playTransitions starts</span></span><br></pre></td></tr></table></figure>
<p>在 playTransition 方法中，首先要构建这两个集合</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="keyword">void</span> <span class="title">captureStartValues</span><span class="params">(TransitionValues transitionValues)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="keyword">void</span> <span class="title">captureEndValues</span><span class="params">(TransitionValues transitionValues)</span></span>;</span><br></pre></td></tr></table></figure>
<p><strong>而后是遍历 sceneRoot，为每个 TransitionValues 对创建属性动画。</strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> Animator <span class="title">createAnimator</span><span class="params">(ViewGroup sceneRoot, TransitionValues startValues,TransitionValues endValues)</span></span></span><br></pre></td></tr></table></figure>
<p><strong>Transition 的子类要定义如何获取起始值以及如何创建属性动画上，这都与具体的属性有关。</strong></p>
<p>下面通过子类实例说说如何定义 Transition。</p>
<h4 id="Visibility"><a href="#Visibility" class="headerlink" title="Visibility"></a>Visibility</h4><p><strong>Visibility 类能够响应控件可见性的变化， 这与他定义的三个属性有关</strong>，这些属性的数值完全由 View 提供，其名称和类型为</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//1.表示 View 的可见性，int类型</span></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">final</span> String PROPNAME_VISIBILITY = <span class="string">"android:visibility:visibility"</span>;</span><br><span class="line"><span class="comment">//2.表示 View 的 Parent，View类型</span></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">final</span> String PROPNAME_PARENT = <span class="string">"android:visibility:parent"</span>;</span><br><span class="line"><span class="comment">//3.表示 View 的屏幕位置，int[]类型</span></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">final</span> String PROPNAME_SCREEN_LOCATION = <span class="string">"android:visibility:screenLocation"</span>;</span><br></pre></td></tr></table></figure>
<p>这样在获取属性时，就可以将这些属性值写入属性字典中去</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">captureValues</span><span class="params">(TransitionValues transitionValues, <span class="keyword">int</span> forcedVisibility)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> visibility = transitionValues.view.getVisibility();</span><br><span class="line">    transitionValues.values.put(PROPNAME_VISIBILITY, visibility);</span><br><span class="line">    transitionValues.values.put(PROPNAME_PARENT, transitionValues.view.getParent());</span><br><span class="line">    <span class="keyword">int</span>[] loc = <span class="keyword">new</span> <span class="keyword">int</span>[<span class="number">2</span>];</span><br><span class="line">    transitionValues.view.getLocationOnScreen(loc);</span><br><span class="line">    transitionValues.values.put(PROPNAME_SCREEN_LOCATION, loc);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>创建动画的方法委托给了子类，以 Fade 为例，它添加了一个透明度属性(由view.getAlpha()提供)</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">static</span> <span class="keyword">final</span> String PROPNAME_ALPHA = <span class="string">"fade:alpha"</span>;</span><br></pre></td></tr></table></figure>
<p>创建关于 View透明度的属性动画，变化区间从当前透明度到 1。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> Animator <span class="title">onAppear</span><span class="params">(ViewGroup sceneRoot, View view, TransitionValues startValues,</span></span></span><br><span class="line"><span class="function"><span class="params">        TransitionValues endValues)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">float</span> startAlpha = getStartAlpha(startValues, <span class="number">0</span>);</span><br><span class="line">    <span class="keyword">return</span> ObjectAnimator.ofFloat(view, View.ALPHA, startAlpha, <span class="number">1</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>同理子类 Scale 创建了关于 scaleX 和 scaleY 的属性动画，子类 Slide 创建了关于 TRANSLATION_X 和 TRANSLATION_Y的属性动画，在确立起始点时要考虑屏幕位置，<strong>它使用的属性动画要建立 Path，通过改变Path可以改变滑动的轨迹</strong>。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ObjectAnimator.ofFloat(view, View.TRANSLATION_X, View.TRANSLATION_Y, path);</span><br></pre></td></tr></table></figure>
<h4 id="其他Transition"><a href="#其他Transition" class="headerlink" title="其他Transition"></a>其他Transition</h4><p>类 ChangeBounds 将改变 View 的 Bound 属性，同时也要处理父容器的 Bound 改变。它有如下属性</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> String PROPNAME_BOUNDS = <span class="string">"android:changeBounds:bounds"</span>;</span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> String PROPNAME_CLIP = <span class="string">"android:changeBounds:clip"</span>;</span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> String PROPNAME_PARENT = <span class="string">"android:changeBounds:parent"</span>; <span class="comment">//父容器是否响应</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> String PROPNAME_WINDOW_X = <span class="string">"android:changeBounds:windowX"</span>; <span class="comment">//屏幕位置</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> String PROPNAME_WINDOW_Y = <span class="string">"android:changeBounds:windowY"</span>;</span><br></pre></td></tr></table></figure>
<ul>
<li>ChangeScroll ： scrollX/scrollY 属性</li>
<li>ChangeTransform ： AnimationMatrix 属性</li>
<li>ChangeClipBounds ： clipBounds 属性</li>
<li>ChangeImageTransform ：ImageView 的 animateTransform 属性</li>
</ul>
<h4 id="TransitionSet"><a href="#TransitionSet" class="headerlink" title="TransitionSet"></a>TransitionSet</h4><p>装饰器 TransitionSet 代表着 Transition 集合，并能够为其指定播放顺序。默认实现 AutoTransition 采用顺序播放，包括三个 Transition，即 Fade.OUT，ChangeBounds，Fade.IN。</p>
<p><strong>单个 Transition 可以添加或排除某个 View，排除的规则可以使用 id，transitionname字符串，class等手段。</strong></p>
<h3 id="二维路径插值器-PathMotion"><a href="#二维路径插值器-PathMotion" class="headerlink" title="二维路径插值器(PathMotion)"></a>二维路径插值器(PathMotion)</h3><p>PathMotion 负责在起始点之间进行插值，它返回的是一个路径。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">abstract</span> Path <span class="title">getPath</span><span class="params">(<span class="keyword">float</span> startX, <span class="keyword">float</span> startY, <span class="keyword">float</span> endX, <span class="keyword">float</span> endY)</span></span>;</span><br></pre></td></tr></table></figure>
<p>某些改变位置的 Transition 可以使用，如ChangeBounds</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">new</span> ChangeBounds().setPathMotion(<span class="keyword">new</span> ArcMotion())</span><br></pre></td></tr></table></figure>
<h2 id="Transition-的实践"><a href="#Transition-的实践" class="headerlink" title="Transition 的实践"></a>Transition 的实践</h2><h3 id="活动间的转场动画"><a href="#活动间的转场动画" class="headerlink" title="活动间的转场动画"></a>活动间的转场动画</h3><p>使用 ActivityOptions可以得到活动间的转场动画，这里要通过 transitionName 属性来指定采用动画的View。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">String transitionName = context.getResources().getString(R.string.transition_app_icon);</span><br><span class="line">ActivityOptions transitionActivityOptions = ActivityOptions.makeSceneTransitionAnimation(activity, appIcon, transitionName);</span><br><span class="line">context.startActivity(intent, transitionActivityOptions.toBundle());</span><br></pre></td></tr></table></figure>
<p><strong>1.执行这个动画需要设置 Window.FEATURE_ACTIVITY_TRANSITIONS。</strong></p>
<p>ActivityOptions 创建的各种动画只是记录参数到 Bundle 中去，对于 SceneTransition 主要记录 View 和 String(transitionName) 的对应关系，以便于选取 Transition。</p>
<p><strong>2.使用转场动画时，可以使用下列的一对方法来控制转场动画。</strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">postponeEnterTransition</span><span class="params">()</span></span>; <span class="comment">//使得动画阻塞</span></span><br><span class="line"><span class="comment">//Thread.sleep(3000); //可以利用这段时间做准备工作，进行数据的加载</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">startPostponedEnterTransition</span><span class="params">()</span></span>; <span class="comment">//启动动画，否则动画将一直阻塞下去，新Activit无法启动</span></span><br></pre></td></tr></table></figure>
<p><strong>3.更简单的使用场景动画的方式是</strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">startActivity(intent);</span><br><span class="line">overridePendingTransition(R.anim.slide_in_left, R.anim.slide_out_right);</span><br></pre></td></tr></table></figure>
<p>overridePendingTransition 分别决定了起始页和跳转页使用的属性动画。</p>
<p>这一点同样可以用在离开时</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onBackPressed</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">super</span>.onBackPressed();</span><br><span class="line">    overridePendingTransition(R.anim.slide_out_right, R.anim.slide_in_left);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><strong>4.使用 Transition 监听器</strong></p>
<p>活动的 Transition 是设置在 Window 上的，采用转场动画应该尽量在动画播放完成后再加载数据，避免处理控件(如RecyclerView)的滑动等。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">getWindow().getEnterTransition().addListener(<span class="keyword">this</span>);</span><br></pre></td></tr></table></figure>
<h3 id="自定义Transition"><a href="#自定义Transition" class="headerlink" title="自定义Transition"></a>自定义Transition</h3><p><strong>自定义Transition的核心是要改变容器布局中哪些 View 的哪些属性</strong>，为此需要以下步骤来确定(以改变TextView的字体大小为例)</p>
<p><strong>1.确定属性名称</strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> String PRO_NAME_TEXT_SIZE = <span class="string">"text:size"</span>;</span><br></pre></td></tr></table></figure>
<p><strong>2.如何获取起始值</strong>TransitionValues</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">captureStartValues</span><span class="params">(TransitionValues transitionValues)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(transitionValues.view <span class="keyword">instanceof</span> TextView)&#123;</span><br><span class="line">        TextView tv = (TextView) transitionValues.view;</span><br><span class="line">        transitionValues.values.put(PRO_NAME_TEXT_SIZE, tv.getTextSize());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><strong>3.创建关于字体大小的动画</strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> Animator <span class="title">createAnimator</span><span class="params">(ViewGroup sceneRoot, TransitionValues startValues, TransitionValues endValues)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(endValues.view <span class="keyword">instanceof</span> TextView)&#123;</span><br><span class="line">        TextView tv = (TextView) endValues.view;</span><br><span class="line">        <span class="keyword">float</span> start = ((TextView) startValues.view).getTextSize(); <span class="comment">//初始值</span></span><br><span class="line">        <span class="keyword">float</span> end = ((TextView) endValues.view).getTextSize();     <span class="comment">//终止值</span></span><br><span class="line">        PropertyValuesHolder holder = PropertyValuesHolder.ofFloat(PROPERTY_TEXT_SIZE, start, end);</span><br><span class="line">        <span class="keyword">return</span> ObjectAnimator.ofPropertyValuesHolder(tv, holder);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这样当设置字体时就会播放动画。</p>
<h3 id="TransitionPlayer"><a href="#TransitionPlayer" class="headerlink" title="TransitionPlayer"></a><a href="https://github.com/linfaxin/TransitionPlayer" target="_blank" rel="noopener">TransitionPlayer</a></h3><p>TransitionPlayer 中有一个精彩的引导页示例， 也是 Transition 动画的使用范例。</p>
<h2 id="Material-Animations"><a href="#Material-Animations" class="headerlink" title="Material-Animations"></a><a href="https://github.com/lgvalle/Material-Animations" target="_blank" rel="noopener">Material-Animations</a></h2><h2 id="StarWars-Android"><a href="#StarWars-Android" class="headerlink" title="StarWars.Android"></a><a href="https://github.com/Yalantis/StarWars.Android" target="_blank" rel="noopener">StarWars.Android</a></h2><p><img src="https://github.com/Yalantis/StarWars.Android/raw/master/star_wars-concept.gif" alt="img"></p>

        
      
    </div>

    
    
    
      <footer class="post-footer">
          <div class="post-eof"></div>
        
      </footer>
  </div>
  
  
  
  </article>

    
        <article itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block home">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2017/08/04/android/View/动画一：常规动画/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="xiang">
      <meta itemprop="description" content="谨守而勿失，是谓反其真">
      <meta itemprop="image" content="/images/1.jpg">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="lxt">
    </span>
      <header class="post-header">
        <h1 class="post-title" itemprop="name headline">
            
            <a href="/2017/08/04/android/View/动画一：常规动画/" class="post-title-link" itemprop="url">动画一：常规动画</a>
          
        </h1>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              
                
              

              <time title="创建时间：2017-08-04 21:26:26" itemprop="dateCreated datePublished" datetime="2017-08-04T21:26:26+08:00">2017-08-04</time>
            </span>
          
            

            
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="fa fa-calendar-check-o"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2019-09-18 16:15:57" itemprop="dateModified" datetime="2019-09-18T16:15:57+08:00">2019-09-18</time>
              </span>
            
          
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing"><a href="/categories/android/" itemprop="url" rel="index"><span itemprop="name">android</span></a></span>

                
                
                  ，
                
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing"><a href="/categories/android/View/" itemprop="url" rel="index"><span itemprop="name">View</span></a></span>

                
                
              
            </span>
          

          
          <br>
            <span class="post-meta-item" title="本文字数">
              <span class="post-meta-item-icon">
                <i class="fa fa-file-word-o"></i>
              </span>
              
                <span class="post-meta-item-text">本文字数：</span>
              
              <span>11k</span>
            </span>
          
            <span class="post-meta-item" title="阅读时长">
              <span class="post-meta-item-icon">
                <i class="fa fa-clock-o"></i>
              </span>
              
                <span class="post-meta-item-text">阅读时长 &asymp;</span>
              
              <span>10 分钟</span>
            </span>
          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h2 id="属性动画-android-animation"><a href="#属性动画-android-animation" class="headerlink" title="属性动画(android.animation)"></a>属性动画(android.animation)</h2><h3 id="插值器-Interpolator"><a href="#插值器-Interpolator" class="headerlink" title="插值器(Interpolator)"></a>插值器(Interpolator)</h3><p>Interpolator 是可以使用 XML 来定义和解析的，它的作用是根据输入产生一个 [0， 1]之间的值</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">TimeInterpolator</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">float</span> <span class="title">getInterpolation</span><span class="params">(<span class="keyword">float</span> input)</span></span>; <span class="comment">//输入和输出区间都是[0, 1] </span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>Interpolator 有各种子类，最简单的是线性的 LinearInterpolator ，各种子类的公式如下</p>
<ul>
<li>$LinearInterpolator : a(t) = t $</li>
<li>$AccelerateInterpolator : a (t) = t*t $</li>
<li>$DecelerateInterpolator : a (t) =1 - (1-t)*(1-t) $</li>
<li>$AccelerateDecelerateInterpolator : a (t) =\frac{cos((t+1)*\pi }{2} + 0.5 $</li>
<li>$AnticipateInterpolator : a(t) = t <em>t</em> ((tension + 1) * t - tension)$ 越来越快</li>
<li>$BounceInterpolator ：$分段函数，呈弹跳效果</li>
<li>$CycleInterpolator ： a (t) = sin(2<em>\pi</em>cycles<em>t) $ \</em>将时间映射成正弦曲线，呈振动式效果，这一点实际非常有用，如果时间给500ms，那么就是半周期，数值复0，适合与View的animate方法联合使用。*</li>
<li>$LookupTableInterpolator : $通过查表来产生结果值</li>
</ul>
<blockquote>
<p>插值器在属性动画中用于时间轴的变换。</p>
</blockquote>
<h3 id="估值器-TypeEvaluator"><a href="#估值器-TypeEvaluator" class="headerlink" title="估值器(TypeEvaluator)"></a>估值器(TypeEvaluator)</h3><p>TypeEvaluator 类用来根据起始值和时间坐标计算中间值。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">TypeEvaluator</span>&lt;<span class="title">T</span>&gt; </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> T <span class="title">evaluate</span><span class="params">(<span class="keyword">float</span> fraction, T startValue, T endValue)</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>典型的估值器实现如 IntEvaluator，RectEvaluator，ArgbEvaluator 等均是线性实现。</p>
<p><strong>通过自定义估值器可以实现属性动画。例如自定义一个改变控件高度的属性动画</strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//1.创建估值器，注意要改的属性是 LayoutParams.height。</span></span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> Integer <span class="title">evaluate</span><span class="params">(<span class="keyword">float</span> fraction, Integer startValue, Integer endValue)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">int</span> num = <span class="keyword">super</span>.evaluate(fraction, startValue, endValue);</span><br><span class="line">  ViewGroup.LayoutParams params = view.getLayoutParams();</span><br><span class="line">  params.height = num;</span><br><span class="line">  v.setLayoutParams(params);</span><br><span class="line">  <span class="keyword">return</span> num;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//2.创建属性动画</span></span><br><span class="line">ValueAnimator.ofObject(<span class="keyword">new</span> MyEvalutor(<span class="keyword">this</span>), <span class="number">0f</span>, <span class="number">1f</span>).start();</span><br></pre></td></tr></table></figure>
<blockquote>
<p>使用估计器比添加 AnimatorUpdateListener 接口要简洁一些。</p>
</blockquote>
<h3 id="Property-与-PropertyValuesHolder"><a href="#Property-与-PropertyValuesHolder" class="headerlink" title="Property 与 PropertyValuesHolder"></a>Property 与 PropertyValuesHolder</h3><p>Property`类表示属性，所以它要表示键值对，对于键，必须是 String 类型，其值表示属性名；对于值，需要一个对象(Class：T) 来提供，数据类型为V，使用 get/set 方法可以从对象中读取和设置属性值。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="class"><span class="keyword">class</span> <span class="title">Property</span>&lt;<span class="title">T</span>, <span class="title">V</span>&gt; </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> String mName;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> Class&lt;V&gt; mType;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">set</span><span class="params">(T object, V value)</span></span>;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">abstract</span> V <span class="title">get</span><span class="params">(T object)</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>以 View 中的”alpha”属性为例，View 对象提供 alpha 属性，其值的格式是 float。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> Property&lt;View, Float&gt; ALPHA = <span class="keyword">new</span> FloatProperty&lt;View&gt;(<span class="string">"alpha"</span>) &#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setValue</span><span class="params">(View object, <span class="keyword">float</span> value)</span> </span>&#123;</span><br><span class="line">        object.setAlpha(value);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Float <span class="title">get</span><span class="params">(View object)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> object.getAlpha();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>PropertyValuesHolder 是对属性 Property 的包装，合成了Property ，属性名称以及属性值集合等，并通过反射(Method)来修改属性值。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> PropertyValuesHolder <span class="title">ofInt</span><span class="params">(Property&lt;?, Integer&gt; property, <span class="keyword">int</span>... values)</span> </span>&#123; </span><br><span class="line">    <span class="comment">//Keyframe 是 time/value 的键值对</span></span><br><span class="line">    mKeyframes = KeyframeSet.ofInt(values); </span><br><span class="line">    mPropertyName = property.getName();</span><br><span class="line">    mProperty = property;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> IntPropertyValuesHolder(property, values);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><strong>传入的多个属性值被转为 Keyframe 集合，且设置了属性名，值类型被确定为 int，通过 Property 对象可以应用属性值。只是缺少一个对象来提供和接受 int 类型的值。</strong></p>
<ul>
<li>PropertyValuesHolder 还可以用 Object 对象来构造。</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> PropertyValuesHolder <span class="title">ofObject</span><span class="params">(String propertyName, TypeEvaluator evaluator,</span></span></span><br><span class="line"><span class="function"><span class="params">        Object... values)</span> </span>&#123;</span><br><span class="line">    PropertyValuesHolder pvh = <span class="keyword">new</span> PropertyValuesHolder(propertyName);</span><br><span class="line">    pvh.setObjectValues(values);</span><br><span class="line">    pvh.setEvaluator(evaluator);</span><br><span class="line">    <span class="keyword">return</span> pvh;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这里对象将被转换为 ObjectKeyframe，只不过属性值由Object对象提供。</p>
<p>PropertyValuesHolder 的重要职责是完成真正的步进计算</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">calculateValue</span><span class="params">(<span class="keyword">float</span> fraction)</span> </span>&#123;</span><br><span class="line">    Object value = mKeyframes.getValue(fraction);</span><br><span class="line">    mAnimatedValue = mConverter == <span class="keyword">null</span> ? value : mConverter.convert(value);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="值动画-ValueAnimator-和对象动画-ObjectAnimator"><a href="#值动画-ValueAnimator-和对象动画-ObjectAnimator" class="headerlink" title="值动画(ValueAnimator)和对象动画(ObjectAnimator)"></a>值动画(ValueAnimator)和对象动画(ObjectAnimator)</h3><p>ValueAnimator 的主要域如下</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">long</span> mStartTime;</span><br><span class="line">PropertyValuesHolder[] mValues; <span class="comment">//属性集合</span></span><br><span class="line">HashMap&lt;String, PropertyValuesHolder&gt; mValuesMap;  <span class="comment">//属性查找表</span></span><br><span class="line">ArrayList&lt;AnimatorUpdateListener&gt; mUpdateListeners;</span><br></pre></td></tr></table></figure>
<p>ValueAnimator 在构造时即是通过 PropertyValuesHolder 来完成的。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> ValueAnimator <span class="title">ofPropertyValuesHolder</span><span class="params">(PropertyValuesHolder... values)</span> </span>&#123;</span><br><span class="line">    ValueAnimator anim = <span class="keyword">new</span> ValueAnimator();</span><br><span class="line">    mValuesMap = <span class="keyword">new</span> HashMap&lt;String, PropertyValuesHolder&gt;(numValues);</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; numValues; ++i) &#123;</span><br><span class="line">        PropertyValuesHolder valuesHolder = values[i];</span><br><span class="line">        mValuesMap.put(valuesHolder.getPropertyName(), valuesHolder);</span><br><span class="line">    &#125;    </span><br><span class="line">    <span class="keyword">return</span> anim;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>使用 ofInt 方法构造的 PropertyValuesHolder 属性名为空。对于 ARGB 颜色而言需要 Evaluator。</p>
<p>ObjectAnimator 比 ValueAnimator 就多了一个对象，可以使用反射来提供和接收数值。······················</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> WeakReference&lt;Object&gt; mTarget;</span><br></pre></td></tr></table></figure>
<p>当属性动画启动后的处理如下</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">PropertyValuesHolder[] mValues;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">animateValue</span><span class="params">(<span class="keyword">float</span> fraction)</span> </span>&#123;</span><br><span class="line">    fraction = mInterpolator.getInterpolation(fraction);</span><br><span class="line">    <span class="keyword">int</span> numValues = mValues.length;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; numValues; ++i) &#123;</span><br><span class="line">        mValues[i].calculateValue(fraction);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//mUpdateListeners 回调</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="状态列表动画-StateListAnimator"><a href="#状态列表动画-StateListAnimator" class="headerlink" title="状态列表动画(StateListAnimator)"></a>状态列表动画(StateListAnimator)</h3><p>StateListAnimator 这种动画可以使得 View 在状态切换时启动属性动画，你可以只有使用</p>
<figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">com.lxt.toast.text.FadeText</span>    <span class="attr">android:stateListAnimator</span>=<span class="string">"@animator/test"</span>/&gt;</span></span><br></pre></td></tr></table></figure>
<p>也可以用代码</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">setStateListAnimator(AnimatorInflater.loadStateListAnimator(getContext(), R.animator.test));</span><br></pre></td></tr></table></figure>
<p>所用的 StateListAnimator 可以用XML来定义，标签是 selector。</p>
<figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">selector</span> <span class="attr">xmlns:android</span>=<span class="string">"http://schemas.android.com/apk/res/android"</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">item</span> <span class="attr">android:state_pressed</span>=<span class="string">"true"</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">set</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">objectAnimator</span> <span class="attr">android:propertyName</span>=<span class="string">"translationX"</span></span></span><br><span class="line"><span class="tag">                            <span class="attr">android:duration</span>=<span class="string">"1000"</span></span></span><br><span class="line"><span class="tag">                            <span class="attr">android:valueTo</span>=<span class="string">"200"</span></span></span><br><span class="line"><span class="tag">                            <span class="attr">android:valueType</span>=<span class="string">"floatType"</span>/&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">set</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">item</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">item</span></span></span><br><span class="line"><span class="tag">          <span class="attr">android:state_pressed</span>=<span class="string">"false"</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">set</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">objectAnimator</span> <span class="attr">android:propertyName</span>=<span class="string">"translationX"</span></span></span><br><span class="line"><span class="tag">                            <span class="attr">android:duration</span>=<span class="string">"1000"</span></span></span><br><span class="line"><span class="tag">                            <span class="attr">android:valueTo</span>=<span class="string">"0"</span></span></span><br><span class="line"><span class="tag">                            <span class="attr">android:valueType</span>=<span class="string">"floatType"</span>/&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">set</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">item</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">selector</span>&gt;</span></span><br></pre></td></tr></table></figure>
<h3 id="AnimatedVectorDrawableCompat"><a href="#AnimatedVectorDrawableCompat" class="headerlink" title="AnimatedVectorDrawableCompat"></a>AnimatedVectorDrawableCompat</h3><p>VectorDrawable 在XML解析时会将 path 字符串解析成 VFullPath 对象，包括 PathDataNode 数组和一些绘制信息，由此构建节点树，绘制时先将节点树绘制在缓存 Bitmap 上。</p>
<p>这里谈谈它的动画效果类 AnimatedVectorDrawableCompat，如果要兼容低版本，在XML中使用 <code>app:srcCompat</code>来引用。</p>
<p><strong>1.首先定义VectorDrawable，重点是给 path 标记 name</strong></p>
<figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">vector</span> <span class="attr">xmlns:android</span>=<span class="string">"http://schemas.android.com/apk/res/android"</span></span></span><br><span class="line"><span class="tag">        <span class="attr">android:width</span>=<span class="string">"24dp"</span></span></span><br><span class="line"><span class="tag">        <span class="attr">android:height</span>=<span class="string">"24dp"</span></span></span><br><span class="line"><span class="tag">        <span class="attr">android:viewportHeight</span>=<span class="string">"24.0"</span></span></span><br><span class="line"><span class="tag">        <span class="attr">android:viewportWidth</span>=<span class="string">"24.0"</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">path</span></span></span><br><span class="line"><span class="tag">        <span class="attr">android:name</span>=<span class="string">"end"</span></span></span><br><span class="line"><span class="tag">        <span class="attr">android:fillColor</span>=<span class="string">"#FF000000"</span></span></span><br><span class="line"><span class="tag">        <span class="attr">android:pathData</span>=<span class="string">"M12,12m-3.2,0a3.2,3.2 0,1 1,6.4 0a3.2,3.2 0,1 1,-6.4 0"</span>/&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">path</span></span></span><br><span class="line"><span class="tag">        <span class="attr">android:name</span>=<span class="string">"star"</span></span></span><br><span class="line"><span class="tag">        <span class="attr">android:fillColor</span>=<span class="string">"#FF000000"</span></span></span><br><span class="line"><span class="tag">        <span class="attr">android:pathData</span>=<span class="string">"M9,2L7.17,4H4c-1.1,0 -2,0.9 -2,2v12c0,1.1 0.9,2 2,2h16c1.1,0 2,-0.9 2,-2V6c0,-1.1 -0.9,-2 -2,-2h-3.17L15,2H9zm3,15c-2.76,0 -5,-2.24 -5,-5s2.24,-5 5,-5 5,2.24 5,5 -2.24,5 -5,5z"</span>/&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">vector</span>&gt;</span></span><br></pre></td></tr></table></figure>
<p><strong>2.定义属性动画，注意 trimPathStart 和 trimPathEnd 这两个属性</strong></p>
<figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&lt;?xml version="1.0" encoding="utf-8"?&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">set</span> <span class="attr">xmlns:android</span>=<span class="string">"http://schemas.android.com/apk/res/android"</span></span></span><br><span class="line"><span class="tag">     <span class="attr">android:ordering</span>=<span class="string">"sequentially"</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">objectAnimator</span></span></span><br><span class="line"><span class="tag">        <span class="attr">android:duration</span>=<span class="string">"1000"</span></span></span><br><span class="line"><span class="tag">        <span class="attr">android:propertyName</span>=<span class="string">"trimPathStart"</span></span></span><br><span class="line"><span class="tag">        <span class="attr">android:valueFrom</span>=<span class="string">"1"</span></span></span><br><span class="line"><span class="tag">        <span class="attr">android:valueTo</span>=<span class="string">"0"</span>/&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">objectAnimator</span></span></span><br><span class="line"><span class="tag">        <span class="attr">android:duration</span>=<span class="string">"1000"</span></span></span><br><span class="line"><span class="tag">        <span class="attr">android:propertyName</span>=<span class="string">"trimPathEnd"</span></span></span><br><span class="line"><span class="tag">        <span class="attr">android:valueFrom</span>=<span class="string">"1"</span></span></span><br><span class="line"><span class="tag">        <span class="attr">android:valueTo</span>=<span class="string">"0"</span>/&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">set</span>&gt;</span></span><br></pre></td></tr></table></figure>
<p><strong>3.合成动画Drawable</strong></p>
<figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">animated-vector</span> <span class="attr">xmlns:android</span>=<span class="string">"http://schemas.android.com/apk/res/android"</span>                 <span class="attr">android:drawable</span>=<span class="string">"@drawable/ic_menu_camera"</span>&gt;</span>    <span class="tag">&lt;<span class="name">target</span>        <span class="attr">android:name</span>=<span class="string">"star"</span>  //<span class="attr">path</span> 的 <span class="attr">name</span>        <span class="attr">android:animation</span>=<span class="string">"@animator/alpha"</span>/&gt;</span> // 使用的属性动画    <span class="tag">&lt;<span class="name">target</span>        <span class="attr">android:name</span>=<span class="string">"end"</span>        <span class="attr">android:animation</span>=<span class="string">"@animator/alpha"</span>/&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">animated-vector</span>&gt;</span></span><br></pre></td></tr></table></figure>
<p>最后调用动画</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">(AnimatedVectorDrawableCompat) fab.getDrawable().start();</span><br></pre></td></tr></table></figure>
<h3 id="AnimatorSet"><a href="#AnimatorSet" class="headerlink" title="AnimatorSet"></a>AnimatorSet</h3><p>AnimatorSet 可以多个属性动画设置播放顺序，如顺序播放，并行播放以及延迟播放，其原理是形成这些动画之间的依赖关系。</p>
<p>例如顺序播放的实现如下</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">playSequentially</span><span class="params">(Animator... items)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; items.length - <span class="number">1</span>; ++i) &#123;</span><br><span class="line">         play(items[i]).before(items[i + <span class="number">1</span>]);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>play 方法并不是播放，而是将 Animator 转为 Node 类，Node 定义了其父节点，兄弟节点和子节点集合，以便形成依赖关系</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">Node</span> <span class="keyword">implements</span> <span class="title">Cloneable</span> </span>&#123;</span><br><span class="line">    Animator mAnimation;</span><br><span class="line">    ArrayList&lt;Node&gt; mChildNodes = <span class="keyword">null</span>;</span><br><span class="line">    ArrayList&lt;Node&gt; mSiblings;</span><br><span class="line">    ArrayList&lt;Node&gt; mParents;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>before 方法会在儿子节点集合中添加代表下一个动画的 Node 节点。</p>
<p>并行播放的实现如下</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">playTogether</span><span class="params">(Animator... items)</span> </span>&#123;</span><br><span class="line">    Builder builder = play(items[<span class="number">0</span>]);</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; items.length; ++i) &#123;</span><br><span class="line">        builder.with(items[i]);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>with 方法会在兄弟节点集合中添加代表下一个动画的 Node 节点。</p>
<p>至于 after 方法自然就是添加到父节点集合中去了，此外 after 方法还能够设置延迟，这是通过插入一个时长为 delay 的空动画来实现的。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> Builder <span class="title">after</span><span class="params">(<span class="keyword">long</span> delay)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// setup dummy ValueAnimator just to run the clock</span></span><br><span class="line">    ValueAnimator anim = ValueAnimator.ofFloat(<span class="number">0f</span>, <span class="number">1f</span>);</span><br><span class="line">    anim.setDuration(delay);</span><br><span class="line">    after(anim);</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">this</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>在构建有向图的时候会使用DFS算法初始化依赖树，使用Build的这几个方法能够随心所欲的构建起动画播放顺序。</p>
<h3 id="显露动画-RevealAnimator"><a href="#显露动画-RevealAnimator" class="headerlink" title="显露动画(RevealAnimator)"></a>显露动画(RevealAnimator)</h3><p>ViewAnimationUtils 这个工具类可以用来创建显露动画，这是经过优化的一种动画，可以产生波纹效果。它是一种属性动画，其扩展应用很广泛，这个留在实践部分讲。创建方法如下</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> Animator <span class="title">createCircularReveal</span><span class="params">(View view,</span></span></span><br><span class="line"><span class="function"><span class="params">        <span class="keyword">int</span> centerX,  <span class="keyword">int</span> centerY, <span class="keyword">float</span> startRadius, <span class="keyword">float</span> endRadius)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> RevealAnimator(view, centerX, centerY, startRadius, endRadius);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<blockquote>
<p>注意波纹效果仅在View区域内。</p>
</blockquote>
<h2 id="补间动画-android-view-animation"><a href="#补间动画-android-view-animation" class="headerlink" title="补间动画(android.view.animation)"></a>补间动画(android.view.animation)</h2><p>系统定义的 Animation 确实只有四种，但完全可以通过自定义来扩展。自定义 Animation 需要重写下列方法，如直接改写控件尺寸</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">applyTransformation</span><span class="params">(<span class="keyword">float</span> interpolatedTime, Transformation t)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> newWidth = mStartWidth + (<span class="keyword">int</span>) ((mWidth - mStartWidth) * interpolatedTime);</span><br><span class="line">    mView.getLayoutParams().width = newWidth;</span><br><span class="line">    mView.requestLayout();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><strong>系统定义的 Animation 如 AlphaAnimation 是通过 Transformation 类来完成变换的，不过其功能有限，这里通过引入 View 直接修改参数。</strong></p>
<blockquote>
<p>各种动画的参数值得注意，如 使用百分比。</p>
</blockquote>
<h3 id="布局动画-LayoutAnimationController"><a href="#布局动画-LayoutAnimationController" class="headerlink" title="布局动画(LayoutAnimationController)"></a>布局动画(LayoutAnimationController)</h3><p><strong>布局动画为 ViewGroup 所独有，它能够使得各个View依次按照延迟播放动画</strong>，其构建方法如下</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">LayoutAnimationController</span><span class="params">(Animation animation, <span class="keyword">float</span> delay)</span></span>;</span><br></pre></td></tr></table></figure>
<p>其参数在 View 的布局参数中，<code>AnimationParameters</code> 中包含动画的延迟，默认按照 View 的序号生成。</p>
<p>实际通过延迟发送也能达到这种效果。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; size; i++) &#123;</span><br><span class="line">    <span class="keyword">final</span> <span class="keyword">double</span> delay = <span class="number">3</span> * <span class="number">500</span> * (i / size);</span><br><span class="line">    <span class="keyword">new</span> Handler().postDelayed(animation, delay);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="属性动画的常规使用套路"><a href="#属性动画的常规使用套路" class="headerlink" title="属性动画的常规使用套路"></a>属性动画的常规使用套路</h2><p><strong>某些控件的绘制依赖于一个参数 process(float) 的变化，对其使用属性动画是一个常规套路，能取得什么效果主要取决于 开发者的想象力。</strong><a href="https://github.com/81813780/AVLoadingIndicatorView" target="_blank" rel="noopener">AVLoadingIndicatorView</a>和<a href="https://github.com/nntuyen/mkloader" target="_blank" rel="noopener">MkLoader</a>库就是典型代表。</p>
<p><img src="https://github.com/81813780/AVLoadingIndicatorView/raw/master/screenshots/avi.gif" alt="img"> <img src="https://github.com/nntuyen/mkloader/raw/master/screenshot/screenshot.gif" alt="img"></p>
<ul>
<li>以 ClassicSpinner 的实现为例，基本效果是画8个圆，动画效果是分别播放一个属性动画，但设置延迟，造成透明度不同。</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">ValueAnimator fadeAnimator = ValueAnimator.ofInt(<span class="number">126</span>, <span class="number">255</span>, <span class="number">126</span>);</span><br><span class="line">fadeAnimator.setRepeatCount(ValueAnimator.INFINITE);</span><br><span class="line">fadeAnimator.setDuration(<span class="number">1000</span>);</span><br><span class="line">fadeAnimator.setStartDelay(index * <span class="number">120</span>);</span><br></pre></td></tr></table></figure>
<blockquote>
<p>这里将圆形抽象成Circle类，以便于使用动画。</p>
</blockquote>
<ul>
<li><code>FishSpinner</code>的绘制是5个圆，依次旋转一定角度。动画效果为360度的旋转，视觉效果即通过延迟来达到。</li>
</ul>
<h3 id="更复杂的使用：分段绘制"><a href="#更复杂的使用：分段绘制" class="headerlink" title="更复杂的使用：分段绘制"></a>更复杂的使用：分段绘制</h3><p><strong>将几个 process 控制的绘制过程拼接起来，可以达到更炫的效果。</strong><a href="https://github.com/Ajian-studio/GADownloading" target="_blank" rel="noopener">GADownloading</a>和<a href="https://github.com/android-cjj/JJSearchViewAnim" target="_blank" rel="noopener">JJSearchViewAnim</a>是分段绘制的典型。</p>
<p><img src="https://camo.githubusercontent.com/82e22c4fd86e8de5bcd0ccf4bdcc9dc1a0b7119f/687474703a2f2f7777312e73696e61696d672e636e2f6d773639302f37656630316663616777316632677a797973796772673230616e303568337a622e676966" alt="img"> <img src="https://camo.githubusercontent.com/0856e588a240305d7699a94e1bd9781cbf7e53e1/687474703a2f2f7777312e73696e61696d672e636e2f6d773639302f376566303166636167773166326b66783531366c33673230623530356c6161332e676966" alt="img"></p>
<h2 id="暴露动画的应用"><a href="#暴露动画的应用" class="headerlink" title="暴露动画的应用"></a>暴露动画的应用</h2><p><a href="https://github.com/XunMengWinter/CircularAnim" target="_blank" rel="noopener">CircularAnim</a> 是一个扩展暴露动画的典型例子，<strong>要点在于计算中心点位置和始终半径。</strong></p>
<p><img src="https://cdn.dribbble.com/users/62319/screenshots/1945593/shot.gif" alt="Login &amp; Home Screen ui ux invision app prototyping iphone material gif ae animation mobile login"></p>
<p><strong>注意中心点位置是相对于 view 的坐标位置，可以在view区域之外。这样如果要以另一个View B为动画的中心，就需要计算B的中心点相对与View左上点的位置，并要确保动画半径容纳原 View。</strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span>[] mCL = <span class="keyword">new</span> <span class="keyword">int</span>[<span class="number">2</span>];</span><br><span class="line">mContentLayout.getLocationOnScreen(mCL);</span><br><span class="line"><span class="keyword">int</span>[] mAL = <span class="keyword">new</span> <span class="keyword">int</span>[<span class="number">2</span>];</span><br><span class="line">view.getLocationOnScreen(mAL);</span><br><span class="line"><span class="keyword">int</span> cX = mAL[<span class="number">0</span>] + view.getWidth()/<span class="number">2</span>-mCL[<span class="number">0</span>];</span><br><span class="line"><span class="keyword">int</span> cY = mAL[<span class="number">1</span>] + view.getHeight()/<span class="number">2</span>-mCL[<span class="number">1</span>];</span><br></pre></td></tr></table></figure>
<p><strong>如果要实现全屏效果，可以在 DecorView 上添加一个 ImageView 来完成动画，ImageView 可以任意设置图片或颜色效果，要注意在动画结束后删除这个 ImageView 。</strong></p>
<p>至于图中的效果，是通过隐藏一个ProgressBar来完成的，将TextView的收缩半径设置为ProgressBar的一半高度，动画完成后隐藏 TextView，显示 ProgressBar 即可。</p>
<h3 id="更复杂的暴露动画效果：RippleLayout"><a href="#更复杂的暴露动画效果：RippleLayout" class="headerlink" title="更复杂的暴露动画效果：RippleLayout"></a><a href="https://github.com/liuguangqiang/RippleLayout" target="_blank" rel="noopener">更复杂的暴露动画效果：RippleLayout</a></h3><p>暴露动画实际也是属性动画，将它和其它属性动画结合能产生一些视觉效果。</p>
<p><img src="https://github.com/liuguangqiang/RippleLayout/raw/master/arts/ripple2.gif" alt="RippleLayout"></p>
<p>这里图片上的效果可以分成几部分</p>
<p><strong>1.点击活动A的按钮，开始触发波纹效果，动画结束之后启动活动B</strong></p>
<p><strong>2.活动B的布局分为上下两层，分别执行TransitionY动画。</strong></p>
<p>与之类似，点击返回键，将反向播放内容布局动画和波纹动画。</p>
<h3 id="入屏动画"><a href="#入屏动画" class="headerlink" title="入屏动画"></a><a href="https://github.com/geftimov/android-player" target="_blank" rel="noopener">入屏动画</a></h3><p><img src="https://github.com/geftimov/android-player/raw/master/art/sample_one.gif" alt="img"></p>
<p>这是一个属性动画的封装库，能够流式的使用属性动画，但无法取消以前的动画，只能用作入屏动画。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">PropertyAction fabAction = PropertyAction.newPropertyAction(fab).scaleX(<span class="number">0</span>).scaleY(<span class="number">0</span>).duration(<span class="number">750</span>).build();</span><br><span class="line">Player.init().</span><br><span class="line">        animate(headerAction).</span><br><span class="line">        then().</span><br><span class="line">        animate(fabAction).</span><br><span class="line">        then().</span><br><span class="line">        animate(bottomAction).</span><br><span class="line">        play();</span><br></pre></td></tr></table></figure>
<h3 id="FabulousFilter"><a href="#FabulousFilter" class="headerlink" title="FabulousFilter"></a><a href="https://github.com/Krupen/FabulousFilter" target="_blank" rel="noopener">FabulousFilter</a></h3><p><img src="https://raw.githubusercontent.com/Krupen/FabulousFilter/master/concept.gif" alt="img"></p>

        
      
    </div>

    
    
    
      <footer class="post-footer">
          <div class="post-eof"></div>
        
      </footer>
  </div>
  
  
  
  </article>

    
        <article itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block home">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2017/07/26/android/View/与 ImageView 有关的知识点/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="xiang">
      <meta itemprop="description" content="谨守而勿失，是谓反其真">
      <meta itemprop="image" content="/images/1.jpg">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="lxt">
    </span>
      <header class="post-header">
        <h1 class="post-title" itemprop="name headline">
            
            <a href="/2017/07/26/android/View/与 ImageView 有关的知识点/" class="post-title-link" itemprop="url">与 ImageView 有关的知识点</a>
          
        </h1>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              
                
              

              <time title="创建时间：2017-07-26 12:18:29" itemprop="dateCreated datePublished" datetime="2017-07-26T12:18:29+08:00">2017-07-26</time>
            </span>
          
            

            
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="fa fa-calendar-check-o"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2019-09-18 14:56:46" itemprop="dateModified" datetime="2019-09-18T14:56:46+08:00">2019-09-18</time>
              </span>
            
          
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing"><a href="/categories/android/" itemprop="url" rel="index"><span itemprop="name">android</span></a></span>

                
                
                  ，
                
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing"><a href="/categories/android/View/" itemprop="url" rel="index"><span itemprop="name">View</span></a></span>

                
                
              
            </span>
          

          
          <br>
            <span class="post-meta-item" title="本文字数">
              <span class="post-meta-item-icon">
                <i class="fa fa-file-word-o"></i>
              </span>
              
                <span class="post-meta-item-text">本文字数：</span>
              
              <span>7.6k</span>
            </span>
          
            <span class="post-meta-item" title="阅读时长">
              <span class="post-meta-item-icon">
                <i class="fa fa-clock-o"></i>
              </span>
              
                <span class="post-meta-item-text">阅读时长 &asymp;</span>
              
              <span>7 分钟</span>
            </span>
          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h2 id="ImageView"><a href="#ImageView" class="headerlink" title="ImageView"></a>ImageView</h2><p><strong>ImageView 的核心功能是显示 Drawable</strong>，因此其核心方法是</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setImageDrawable</span><span class="params">(@Nullable Drawable drawable)</span></span></span><br></pre></td></tr></table></figure>
<p><strong>传入新的 Drawable 对象后，会配置其各种属性，包括 level，state，染色，Bounds等。</strong></p>
<p>onDraw 方法就是对 Drawable 对象的绘制，但有两点要注意</p>
<ul>
<li>Matrix 通过左乘对 canvas 产生影响 ,可以用于图片处理</li>
<li>mCropToPadding 通过 canvas 的 clipRect 方法将对显示区域做截取， 并将 padding 纳入 Drawable 的Bound计算</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">canvas.save();</span><br><span class="line"><span class="keyword">if</span> (mCropToPadding) &#123;</span><br><span class="line">    canvas.clipRect(scrollX + mPaddingLeft, scrollY + mPaddingTop,</span><br><span class="line">            scrollX + mRight - mLeft - mPaddingRight,</span><br><span class="line">            scrollY + mBottom - mTop - mPaddingBottom);</span><br><span class="line">&#125;</span><br><span class="line">canvas.translate(mPaddingLeft, mPaddingTop);</span><br><span class="line">canvas.concat(mDrawMatrix);</span><br><span class="line">mDrawable.draw(canvas);</span><br><span class="line">canvas.restoreToCount(saveCount);</span><br></pre></td></tr></table></figure>
<blockquote>
<p>如果设置了 mCropToPadding 为 true，则滚动ImageView</p>
</blockquote>
<h3 id="ImageButton与-FloatingActionButton"><a href="#ImageButton与-FloatingActionButton" class="headerlink" title="ImageButton与 FloatingActionButton"></a>ImageButton与 FloatingActionButton</h3><p>子类 ImageButton 虽然名为 “Button”，却不是 TextView，而是 ImageView，只不过它用了与 Button 相同的背景</p>
<figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">item</span> <span class="attr">name</span>=<span class="string">"background"</span>&gt;</span>@drawable/btn_default<span class="tag">&lt;/<span class="name">item</span>&gt;</span></span><br></pre></td></tr></table></figure>
<p>子类 FloatingActionButton 的特别之处在于它强制定义了背景 Drawable，其默认配置如下</p>
<figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">style</span> <span class="attr">name</span>=<span class="string">"Widget.Design.FloatingActionButton"</span> <span class="attr">parent</span>=<span class="string">"android:Widget"</span>&gt;</span></span><br><span class="line"><span class="xml">    <span class="tag">&lt;<span class="name">item</span> <span class="attr">name</span>=<span class="string">"android:background"</span>&gt;</span>@drawable/design_fab_background<span class="tag">&lt;/<span class="name">item</span>&gt;</span> //白色的圆形 shapedrawable</span></span><br><span class="line"><span class="xml">    <span class="tag">&lt;<span class="name">item</span> <span class="attr">name</span>=<span class="string">"backgroundTint"</span>&gt;</span>?attr/colorAccent<span class="tag">&lt;/<span class="name">item</span>&gt;</span> // 背景的渲染色是 colorAccent</span></span><br><span class="line"><span class="xml">    <span class="tag">&lt;<span class="name">item</span> <span class="attr">name</span>=<span class="string">"fabSize"</span>&gt;</span>normal<span class="tag">&lt;/<span class="name">item</span>&gt;</span></span></span><br><span class="line"><span class="xml">    <span class="tag">&lt;<span class="name">item</span> <span class="attr">name</span>=<span class="string">"elevation"</span>&gt;</span>@dimen/design_fab_elevation<span class="tag">&lt;/<span class="name">item</span>&gt;</span>					  // 6dp</span></span><br><span class="line"><span class="xml">    <span class="tag">&lt;<span class="name">item</span> <span class="attr">name</span>=<span class="string">"pressedTranslationZ"</span>&gt;</span>@dimen/design_fab_translation_z_pressed<span class="tag">&lt;/<span class="name">item</span>&gt;</span> // 6dp</span></span><br><span class="line"><span class="xml">    <span class="tag">&lt;<span class="name">item</span> <span class="attr">name</span>=<span class="string">"rippleColor"</span>&gt;</span>?attr/colorControlHighlight<span class="tag">&lt;/<span class="name">item</span>&gt;</span></span></span><br><span class="line"><span class="xml">    <span class="tag">&lt;<span class="name">item</span> <span class="attr">name</span>=<span class="string">"borderWidth"</span>&gt;</span>@dimen/design_fab_border_width<span class="tag">&lt;/<span class="name">item</span>&gt;</span>				   // 0.5dp</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">style</span>&gt;</span></span><br></pre></td></tr></table></figure>
<p>然而实际的背景并不是简单地 ShapeDrawable，还要考虑描边和ripple的效果，其实现在不同的版本各不相同。</p>
<h3 id="绘制形状的改造"><a href="#绘制形状的改造" class="headerlink" title="绘制形状的改造"></a>绘制形状的改造</h3><p><a href="https://github.com/hdodenhof/CircleImageView" target="_blank" rel="noopener">圆形控件:CircleImageView</a>库实现了圆形图片，实际是重新实现了 ImageView 的绘制方法，它的绘制原理是从 Drawable 中提取出位图 Bitmap 对象，而后使用其作为 BitmapShader 的像素源，绘制圆形图片。</p>
<p>它的具体实现如下</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">onDraw</span><span class="params">(Canvas canvas)</span> </span>&#123;</span><br><span class="line">  </span><br><span class="line">    <span class="comment">//1.获取 Drawable</span></span><br><span class="line">    Drawable drawable = getDrawable();</span><br><span class="line">  </span><br><span class="line">    <span class="comment">//2.提取 Bitmap</span></span><br><span class="line">    Bitmap bitmap = Bitmap.createBitmap(drawable.getIntrinsicWidth(), drawable.getIntrinsicHeight(), ARGB_8888);</span><br><span class="line">    Canvas c = <span class="keyword">new</span> Canvas(bitmap);</span><br><span class="line">    drawable.setBounds(<span class="number">0</span>, <span class="number">0</span>, c.getWidth(), c.getHeight());</span><br><span class="line">    drawable.draw(c);</span><br><span class="line">    <span class="comment">//3.生成 BitmapShader 以配置 Paint</span></span><br><span class="line">    BitmapShader bitmapShader = <span class="keyword">new</span> BitmapShader(bitmap, CLAMP, CLAMP);</span><br><span class="line">    Paint bitmapPaint = <span class="keyword">new</span> Paint(Paint.ANTI_ALIAS_FLAG);</span><br><span class="line">    bitmapPaint.setShader(bitmapShader);</span><br><span class="line">  </span><br><span class="line">    <span class="comment">//4.计算尺寸和位置，完成最后绘制</span></span><br><span class="line">    <span class="keyword">int</span> width = getWidth() - getPaddingLeft() - getPaddingRight();</span><br><span class="line">    <span class="keyword">int</span> height = getHeight() - getPaddingTop() - getPaddingBottom();</span><br><span class="line">    <span class="keyword">int</span> radius = Math.min(width / <span class="number">2</span>, height / <span class="number">2</span>);</span><br><span class="line">    <span class="keyword">int</span> centerX = getPaddingLeft() + width / <span class="number">2</span>;</span><br><span class="line">    <span class="keyword">int</span> centerY = getPaddingTop() + height / <span class="number">2</span>;</span><br><span class="line">    canvas.drawCircle(centerX, centerY, radius, bitmapPaint);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<blockquote>
<p>实际上这也可以通过 canvas 的 clipPath 方法来实现，但截取操作在底层开销比较大，宜使用 Shader 方法。</p>
<p>v4 包中的 CircleImageView 专门用作下拉刷新控件，它的背景 Drawable 设置为圆形的 ShapeDrawable，内容 Drawable 设置为带动画效果的箭头 Drawable。</p>
</blockquote>
<p><a href="https://github.com/vinc3m1/RoundedImageView" target="_blank" rel="noopener">RoundedImageView</a>库实现圆角图片，其实现原理与上面的 CircleImageView 类似，以(0,0,200,200)为区域，半径为 20 的圆角矩形为例，最终实现方法是</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">draw</span><span class="params">(@NonNull Canvas canvas)</span> </span>&#123;</span><br><span class="line">  BitmapShader bitmapShader = <span class="keyword">new</span> BitmapShader(mBitmap, mTileModeX, mTileModeY);</span><br><span class="line">  <span class="comment">//...</span></span><br><span class="line">  canvas.drawRoundRect(mDrawableRect, radius, radius, mBitmapPaint);</span><br><span class="line">  redrawBitmapForSquareCorners(canvas);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<img src="/2017/07/26/android/View/与%20ImageView%20有关的知识点/6874.png">
<p>只是绘制由圆形变成了圆角矩形而已，但是如何只绘制单个原角呢？这里的做法是重绘，例如左上角，重绘的区域即(0,0,20,20)的矩形，将这部分的位图重绘出来就行了。如果是边界，则重绘线段。</p>
<blockquote>
<p>这里的问题是发生了重绘，在有三个圆角的情况下最为糟糕，因此应该避免这种情况。如果自己实现，可以将矩形区域划分的细一些，以便一次绘制完毕。<strong>也可以采用 Shape 的做法，通过构建路径的方式来实现。</strong></p>
</blockquote>
<h3 id="绘制内容的添加"><a href="#绘制内容的添加" class="headerlink" title="绘制内容的添加"></a>绘制内容的添加</h3><p>绘制内容的添加即在 ImageView 之上进行扩展绘制。</p>
<p><a href="https://github.com/HeZaiJin/SlantedTextView" target="_blank" rel="noopener">SlantedTextView</a>库的效果可以采用额外绘制的方法实现。</p>
<img src="/2017/07/26/android/View/与%20ImageView%20有关的知识点/screenshot.png">
<p><a href="https://github.com/zagum/Android-SwitchIcon" target="_blank" rel="noopener">SwitchIcon</a>库的效果如下</p>
<img src="/2017/07/26/android/View/与%20ImageView%20有关的知识点/sample.gif">
<p>该库所做的额外绘制稍显复杂，包括</p>
<ul>
<li>绘制斜线状态</li>
<li>达成动画效果</li>
<li>颜色渲染</li>
</ul>
<p>1.斜线是通过 Paint 绘制 Line 来实现的，其起始点在</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">dashXStart = getPaddingLeft() + <span class="number">0.5f</span> * SIN_45 * dashThickness;</span><br><span class="line">dashYStart = getPaddingTop() + <span class="number">1.5f</span> * SIN_45 * dashThickness;</span><br></pre></td></tr></table></figure>
<p>结束点在</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">dashEnd.x = (<span class="keyword">int</span>) (dashXStart + width - delta1);</span><br><span class="line">dashEnd.y = (<span class="keyword">int</span>) (dashYStart + height - delta2);</span><br></pre></td></tr></table></figure>
<p>这样斜线就是从左上向右下逐渐延伸的。</p>
<p>2.斜线的延伸由参数 friction 控制，除此之外，friction 还控制渲染的颜色，透明度的变化。这里原本的 drawable 变色是通过构建新的 PorterDuffColorFilter 来完成的，而斜线的颜色是通过Paint来设置的。</p>
<p>3.这里还有最后一个问题：就是斜线和原 Drawable 的重叠，其解决方法如下</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">onDraw</span><span class="params">(Canvas canvas)</span> </span>&#123;</span><br><span class="line">  drawDash(canvas);</span><br><span class="line">  canvas.clipPath(clipPath, Region.Op.XOR); </span><br><span class="line">  <span class="keyword">super</span>.onDraw(canvas);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这里 clipPath 覆盖斜线，并略微大于斜线，值得注意的是区域截取的方式采用的是 XOR，这保证了Canvas 将在斜线区域之外绘制原 Drawable。</p>
<h3 id="动画效果"><a href="#动画效果" class="headerlink" title="动画效果"></a>动画效果</h3><p><a href="https://github.com/Q42/AndroidScrollingImageView" target="_blank" rel="noopener">AndroidScrollingImageView</a>这种效果实际是视差造成的，动的是背景图，实际绘制的是多个 Bitmap，通过设置 offset 参数造成偏移效果，并通过控制此值形成动画效果。最终效果实际上与背景素材有关，不同的素材可以设置不同的回退速度。</p>
<img src="/2017/07/26/android/View/与%20ImageView%20有关的知识点/sample_app.png">
<p><a href="https://github.com/flavioarfaria/KenBurnsView" target="_blank" rel="noopener">KenBurnsView</a> 库实现 Ken Burns 效果，即景深效果，</p>
<img src="/2017/07/26/android/View/与%20ImageView%20有关的知识点/anim.gif">
<p>首先确定控件的尺寸和Bitmap尺寸是不一致的，后者要大于前者。在 Bitmap 尺寸范围内截取一个空间尺寸大小的区域，同时显示区域用动画移位过去，就是 Ken Burns 效果。</p>
<p>效果的实现与位置形状矩阵 Matrix 有关，这里需要将ScaleType类型设置为MATRIX</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">super</span>.setScaleType(ImageView.ScaleType.MATRIX);</span><br></pre></td></tr></table></figure>
<p>这里移位采用 Matrix 来完成，动画由 mProcess 参数来控制。</p>
<h3 id="图像处理"><a href="#图像处理" class="headerlink" title="图像处理"></a>图像处理</h3><p>图像处理主要依赖于颜色矩阵(ColorMatrix)来实现。</p>
<h4 id="ColorMatrix"><a href="#ColorMatrix" class="headerlink" title="ColorMatrix"></a>ColorMatrix</h4><p>ColorMatrix 是一个 4*5 的矩阵，4行分别代表red，green，blue和alpha向量，默认是单位阵。在实现上采用的是float数组来存储这些数据。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ColorMatrix</span> </span>&#123;    </span><br><span class="line">	<span class="keyword">private</span> <span class="keyword">final</span> <span class="keyword">float</span>[] mArray = <span class="keyword">new</span> <span class="keyword">float</span>[<span class="number">20</span>];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>最简单的操作像素颜色变化的方法是 setScale，它只改变了对角线的上的数据，这样颜色的各个分量独立的进行变化</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setScale</span><span class="params">(<span class="keyword">float</span> rScale, <span class="keyword">float</span> gScale, <span class="keyword">float</span> bScale, <span class="keyword">float</span> aScale)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">final</span> <span class="keyword">float</span>[] a = mArray;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">19</span>; i &gt; <span class="number">0</span>; --i) &#123;</span><br><span class="line">        a[i] = <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    a[<span class="number">0</span>] = rScale;</span><br><span class="line">    a[<span class="number">6</span>] = gScale;</span><br><span class="line">    a[<span class="number">12</span>] = bScale;</span><br><span class="line">    a[<span class="number">18</span>] = aScale;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="StyleImageView-库可以进行图像的处理。"><a href="#StyleImageView-库可以进行图像的处理。" class="headerlink" title="StyleImageView 库可以进行图像的处理。"></a><a href="https://github.com/chengdazhi/StyleImageView" target="_blank" rel="noopener">StyleImageView</a> 库可以进行图像的处理。</h4><img src="/2017/07/26/android/View/与%20ImageView%20有关的知识点/style_sample.gif">
<p>图像Bitmap由像素构成，像素又包括对比度(Contrast)，亮度(Brightness)，纯度(saturation)等参数，图片的重叠还涉及混合模式(Mode)。修改这些信息主要通过颜色矩阵(ColorMatrix)来完成。</p>
<p>关于构建 marix 的方法如下</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">float</span>[] calculateMatrix(<span class="keyword">int</span> mode, <span class="keyword">int</span> brightness, <span class="keyword">float</span> contrast, <span class="keyword">float</span> saturation) &#123;</span><br><span class="line">    <span class="keyword">return</span> applyBrightnessAndContrast(getMatrixByMode(mode, saturation), brightness, contrast);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">float</span>[] applyBrightnessAndContrast(<span class="keyword">float</span>[] matrix, <span class="keyword">int</span> brightness, <span class="keyword">float</span> contrast) &#123;</span><br><span class="line">    <span class="keyword">float</span> t = (<span class="number">1.0F</span> - contrast) / <span class="number">2.0F</span> * <span class="number">255.0F</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">3</span>; i++) &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j = i * <span class="number">5</span>; j &lt; i * <span class="number">5</span> + <span class="number">3</span>; j++) &#123;</span><br><span class="line">            matrix[j] *= contrast;</span><br><span class="line">        &#125;</span><br><span class="line">        matrix[<span class="number">5</span> * i + <span class="number">4</span>] += t + brightness;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> matrix;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>正常情况下直接改变像素颜色</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">final</span> <span class="keyword">float</span>[] matrix = calculateMatrix(mode, brightness, contrast, saturation);</span><br><span class="line">drawableHolder.getDrawable().setColorFilter(<span class="keyword">new</span> ColorMatrixColorFilter(<span class="keyword">new</span> ColorMatrix(matrix)));</span><br></pre></td></tr></table></figure>
<p>如果要在改变时形成动画，则需要利用颜色矩阵中的float数组作为起始值，并利用值动画来更新。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">updateStyle</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">final</span> <span class="keyword">float</span>[] matrix = calculateMatrix(mode, brightness, contrast, saturation);</span><br><span class="line">    <span class="keyword">if</span> (enableAnimation) &#123;</span><br><span class="line">        animateMatrix(oldMatrix, matrix, <span class="keyword">new</span> AnimatorListenerAdapter() &#123;</span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onAnimationEnd</span><span class="params">(Animator animation)</span> </span>&#123;</span><br><span class="line">                <span class="keyword">super</span>.onAnimationEnd(animation);</span><br><span class="line">                setDrawableStyleByMatrix(matrix);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">animateMatrix</span><span class="params">(<span class="keyword">final</span> <span class="keyword">float</span>[] startMatrix, <span class="keyword">final</span> <span class="keyword">float</span>[] endMatrix, AnimatorListenerAdapter onAnimationEndListener)</span> </span>&#123;</span><br><span class="line">    animator = ValueAnimator.ofFloat(<span class="number">0F</span>, <span class="number">1F</span>).setDuration(animationDuration);</span><br><span class="line">    animator.addUpdateListener(<span class="keyword">new</span> ValueAnimator.AnimatorUpdateListener() &#123;</span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onAnimationUpdate</span><span class="params">(ValueAnimator valueAnimator)</span> </span>&#123;</span><br><span class="line">            <span class="keyword">float</span>[] result = <span class="keyword">new</span> <span class="keyword">float</span>[<span class="number">20</span>];</span><br><span class="line">            <span class="keyword">float</span> fraction = valueAnimator.getAnimatedFraction();</span><br><span class="line">            <span class="keyword">float</span> progress = interpolator.getInterpolation(fraction);</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">20</span>; i++) &#123;</span><br><span class="line">                result[i] = (startMatrix[i] * (<span class="number">1</span> - progress)) + (endMatrix[i] * progress);</span><br><span class="line">            &#125;</span><br><span class="line">            drawableHolder.getDrawable().setColorFilter(<span class="keyword">new</span> ColorMatrixColorFilter(<span class="keyword">new</span> ColorMatrix(matrix))); </span><br><span class="line">        &#125;</span><br><span class="line">    &#125;);</span><br><span class="line">    animator.addListener(onAnimationEndListener);</span><br><span class="line">    animator.start();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

        
      
    </div>

    
    
    
      <footer class="post-footer">
          <div class="post-eof"></div>
        
      </footer>
  </div>
  
  
  
  </article>

    
        <article itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block home">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2017/07/24/android/View/与 Drawable 相关的知识点/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="xiang">
      <meta itemprop="description" content="谨守而勿失，是谓反其真">
      <meta itemprop="image" content="/images/1.jpg">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="lxt">
    </span>
      <header class="post-header">
        <h1 class="post-title" itemprop="name headline">
            
            <a href="/2017/07/24/android/View/与 Drawable 相关的知识点/" class="post-title-link" itemprop="url">与 Drawable 相关的知识点</a>
          
        </h1>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              
                
              

              <time title="创建时间：2017-07-24 14:28:29" itemprop="dateCreated datePublished" datetime="2017-07-24T14:28:29+08:00">2017-07-24</time>
            </span>
          
            

            
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="fa fa-calendar-check-o"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2019-09-18 14:49:20" itemprop="dateModified" datetime="2019-09-18T14:49:20+08:00">2019-09-18</time>
              </span>
            
          
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing"><a href="/categories/android/" itemprop="url" rel="index"><span itemprop="name">android</span></a></span>

                
                
                  ，
                
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing"><a href="/categories/android/View/" itemprop="url" rel="index"><span itemprop="name">View</span></a></span>

                
                
              
            </span>
          

          
          <br>
            <span class="post-meta-item" title="本文字数">
              <span class="post-meta-item-icon">
                <i class="fa fa-file-word-o"></i>
              </span>
              
                <span class="post-meta-item-text">本文字数：</span>
              
              <span>11k</span>
            </span>
          
            <span class="post-meta-item" title="阅读时长">
              <span class="post-meta-item-icon">
                <i class="fa fa-clock-o"></i>
              </span>
              
                <span class="post-meta-item-text">阅读时长 &asymp;</span>
              
              <span>10 分钟</span>
            </span>
          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h2 id="Drawable"><a href="#Drawable" class="headerlink" title="Drawable"></a>Drawable</h2><p>Drawable 是绘制的基础单元，但它没有事件机制，不想 View 那么复杂。Drawable 的基本机制或属性包括</p>
<ul>
<li><strong>使用 Bound 和 Padding 确定绘制的范围</strong> , 且 <strong>Drawable 必须确定 Bound</strong></li>
<li>使用 Outline 确定轮廓，默认情况下与 Bound 相同</li>
<li><strong>使用 State 记录状态</strong></li>
<li><strong>使用 Level(0-10000) 赋予一定的动态性，如定义变化中的进度条等</strong></li>
<li>使用 Callback 回调接口实现动画效果，与 View 的 invalidate() 方法配合使用</li>
<li><strong>绘制机制，需要实现抽象的 draw 方法</strong></li>
</ul>
<p>例如子类 BitmapDrawable 的绘制方法是绘制 Bitmap，且通过Bitmap来确定 Bound 和 Outline，其额外的属性(如抗锯齿等)均通过设置 Paint 对象和 Shader 对象来生效。</p>
<p>再比如子类 ColorDrawable 的本质是使用指定颜色绘制矩形。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">draw</span><span class="params">(Canvas canvas)</span> </span>&#123;</span><br><span class="line">    mPaint.setColor(mColorState.mUseColor);</span><br><span class="line">    canvas.drawRect(getBounds(), mPaint);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<blockquote>
<p>这些 Drawable 也可以用 XML 文件定义的，系统最终要使用 XML解析器将其解析成 Drawable 对象。</p>
</blockquote>
<p>关于绘制，Drawable 还有以下效果设置</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@IntRange</span>(from=<span class="number">0</span>,to=<span class="number">255</span>) <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">getAlpha</span><span class="params">()</span></span>;		<span class="comment">//1.透明度</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setXfermode</span><span class="params">(@Nullable Xfermode mode)</span></span>;   <span class="comment">//2. Xfermode</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="keyword">void</span> <span class="title">setColorFilter</span><span class="params">(@Nullable ColorFilter colorFilter)</span></span>;   <span class="comment">//3.ColorFilter</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setTint</span><span class="params">(@ColorInt <span class="keyword">int</span> tintColor)</span></span>;   <span class="comment">//4.染色</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setTintList</span><span class="params">(@Nullable ColorStateList tint)</span>   <span class="comment">//4.染色 ColorStateList</span></span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setHotspot</span><span class="params">(<span class="keyword">float</span> x, <span class="keyword">float</span> y)</span></span>;   <span class="comment">//5.热点</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setHotspotBounds</span><span class="params">(<span class="keyword">int</span> left, <span class="keyword">int</span> top, <span class="keyword">int</span> right, <span class="keyword">int</span> bottom)</span></span>;  <span class="comment">//5.热点区域 </span></span><br><span class="line"><span class="keyword">public</span> <span class="meta">@Nullable</span> <span class="function">Region <span class="title">getTransparentRegion</span><span class="params">()</span></span>;   <span class="comment">//6.透明区域</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="meta">@PixelFormat</span>.<span class="function">Opacity <span class="keyword">int</span> <span class="title">getOpacity</span><span class="params">()</span></span>;    <span class="comment">//7.设置像素格式，如是否包含表示透明度的bit</span></span><br><span class="line"><span class="keyword">public</span> <span class="meta">@NonNull</span> <span class="function">Drawable <span class="title">getCurrent</span><span class="params">()</span></span>;    <span class="comment">//8.在 Drawable 容器中获取 Drawable</span></span><br></pre></td></tr></table></figure>
<h3 id="GradientDrawable与ShapeDrawable"><a href="#GradientDrawable与ShapeDrawable" class="headerlink" title="GradientDrawable与ShapeDrawable"></a>GradientDrawable与ShapeDrawable</h3><p>GradientDrawable 可以绘制四种类型，并带有渐变和圆角特征，它与ShapeDrawable类似。</p>
<p>ShapeDrawable 即绘制“形状”，其绘制实际是“形状”对象(Shape)来代理</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">draw</span><span class="params">(Canvas canvas)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">final</span> Rect r = getBounds();</span><br><span class="line">    <span class="keyword">final</span> ShapeState state = mShapeState;</span><br><span class="line">    <span class="keyword">final</span> Paint paint = state.mPaint;</span><br><span class="line">    <span class="keyword">final</span> <span class="keyword">int</span> count = canvas.save();</span><br><span class="line">    canvas.translate(r.left, r.top);</span><br><span class="line">    shape.draw(canvas, paint);</span><br><span class="line">    canvas.restoreToCount(count);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>Shape 的基本形状是 RectShape ，其绘制实现如下</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">draw</span><span class="params">(Canvas canvas, Paint paint)</span> </span>&#123;</span><br><span class="line">    canvas.drawRect(mRect, paint);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>如果设置了 corners 标签，则使用子类 PaintDrawable 来解析</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setCornerRadii</span><span class="params">(<span class="keyword">float</span>[] radii)</span> </span>&#123;</span><br><span class="line">    setShape(<span class="keyword">new</span> RoundRectShape(radii, <span class="keyword">null</span>, <span class="keyword">null</span>));</span><br><span class="line">    invalidateSelf();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><strong>可见四角是通过圆角矩形这个形状(RoundRectShape)来实现的， 这个将在 Path 中详细讲。</strong></p>
<h3 id="DrawableWrapper"><a href="#DrawableWrapper" class="headerlink" title="DrawableWrapper"></a>DrawableWrapper</h3><p>DrawableWrapper 表示对单个 Drawable 的包装，类似于装饰器模式。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="class"><span class="keyword">class</span> <span class="title">DrawableWrapper</span> <span class="keyword">extends</span> <span class="title">Drawable</span> <span class="keyword">implements</span> <span class="title">Drawable</span>.<span class="title">Callback</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> DrawableWrapperState mState;</span><br><span class="line">    <span class="keyword">private</span> Drawable mDrawable;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>对 DrawableWrapper 的设置实际上都在处理被包装的 Drawable，包括最终的绘制</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">draw</span><span class="params">(@NonNull Canvas canvas)</span> </span>&#123;</span><br><span class="line">    mDrawable.draw(canvas);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li>InsetDrawable 实际是通过 padding 来实现缩进的。</li>
<li>ScaleDrawable 实际会按照比例重新计算 Bound</li>
<li>RotateDrawable 很容易想到旋转是通过 canvas 来实现的。</li>
<li><strong>ClipDrawable 主要要指定剪切的方向和 level，其绘制与 level 有关，需要该值计算出边界，再用canvas 的 clipRect() 方法来裁剪它。</strong></li>
</ul>
<h3 id="DrawableContainer"><a href="#DrawableContainer" class="headerlink" title="DrawableContainer"></a>DrawableContainer</h3><p>DrawableContainer 表示 Drawable 的集合，但只显示一张，同样是装饰器模式。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">draw</span><span class="params">(Canvas canvas)</span> </span>&#123;</span><br><span class="line">        mCurrDrawable.draw(canvas);</span><br><span class="line">        mLastDrawable.draw(canvas);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>关于如何在众多 Drawable 中选择一张，DrawableContainer 有如下子类</p>
<ol>
<li><strong>LevelListDrawable</strong></li>
</ol>
<figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">level-list</span> <span class="attr">xmlns:android</span>=<span class="string">"http://schemas.android.com/apk/res/android"</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">item</span> <span class="attr">android:drawable</span>=<span class="string">"@drawable/checked"</span> <span class="attr">android:minLevel</span>=<span class="string">"0"</span> <span class="attr">android:maxLevel</span>=<span class="string">"100"</span> /&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">item</span> <span class="attr">android:drawable</span>=<span class="string">"@drawable/checked"</span> <span class="attr">android:minLevel</span>=<span class="string">"100"</span> <span class="attr">android:maxLevel</span>=<span class="string">"200"</span> /&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">level-list</span>&gt;</span></span><br></pre></td></tr></table></figure>
<p>LevelListDrawable 中挑选的标准是 level 值的大小，每一个 Drawable 对象指定一个范围，显示 level 值落入范围的 Drawable 对象。</p>
<ol>
<li><strong>StateListDrawable</strong> 同理显示状态相符的 Drawable 对象。</li>
<li><strong>AnimationDrawabl</strong>e 即帧动画，用多个 Drawable 对象产生动画效果。</li>
</ol>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">start</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    mAnimating = <span class="keyword">true</span>;</span><br><span class="line">    <span class="keyword">if</span> (!mRunning) &#123;</span><br><span class="line">        selectDrawable(frame); </span><br><span class="line">        scheduleSelf(<span class="keyword">this</span>, SystemClock.uptimeMillis() + mAnimationState.mDurations[frame]);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这里帧会进行帧的步进，并触发 drawable 的动画刷新机制，直到播放完成。</p>
<h3 id="LayerDrawable"><a href="#LayerDrawable" class="headerlink" title="LayerDrawable"></a>LayerDrawable</h3><p>LayerDrawable 维持一个 Drawable 数组，并全部显示，但下标最大的那个显示最完全，构造方法如下</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">LayerDrawable</span><span class="params">(@NonNull Drawable[] layers)</span></span></span><br></pre></td></tr></table></figure>
<p>绘制方法如下</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">draw</span><span class="params">(Canvas canvas)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">final</span> ChildDrawable[] array = mLayerState.mChildren;</span><br><span class="line">    <span class="keyword">final</span> <span class="keyword">int</span> N = mLayerState.mNum;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; N; i++) &#123;</span><br><span class="line">        <span class="keyword">final</span> Drawable dr = array[i].mDrawable;</span><br><span class="line">        <span class="keyword">if</span> (dr != <span class="keyword">null</span>) &#123;</span><br><span class="line">            dr.draw(canvas);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这样可以通过为某一层设置 Padding 来进行层叠显示，如果设置合理，可以显示全部的 Drawable 。</p>
<h4 id="TransitionDrawable"><a href="#TransitionDrawable" class="headerlink" title="TransitionDrawable"></a><strong>TransitionDrawable</strong></h4><p><strong>TransitionDrawable 是一个仅有两层的LayerDrawable，可以在切换时播放动画，一般用作切换动画。</strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">startTransition</span><span class="params">(<span class="keyword">int</span> durationMillis)</span> </span>&#123;</span><br><span class="line">    mFrom = <span class="number">0</span>;</span><br><span class="line">    mTo = <span class="number">255</span>;</span><br><span class="line">    mAlpha = <span class="number">0</span>;</span><br><span class="line">    mDuration = mOriginalDuration = durationMillis;</span><br><span class="line">    mReverse = <span class="keyword">false</span>;</span><br><span class="line">    mTransitionState = TRANSITION_STARTING;</span><br><span class="line">    invalidateSelf();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>该方法设置的动画是关于透明度的，且起始值是255和0，如果要启用交叉透明效果，首先设置</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setCrossFadeEnabled</span><span class="params">(<span class="keyword">boolean</span> enabled)</span></span></span><br></pre></td></tr></table></figure>
<p>在绘制方法 draw 中通过时间的流逝计算 alpha 值</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">float</span> normalized = (<span class="keyword">float</span>)(SystemClock.uptimeMillis() - mStartTimeMillis) / mDuration;</span><br><span class="line">done = normalized &gt;= <span class="number">1.0f</span>;</span><br><span class="line">normalized = Math.min(normalized, <span class="number">1.0f</span>);</span><br><span class="line">mAlpha = (<span class="keyword">int</span>) (mFrom  + (mTo - mFrom) * normalized);</span><br></pre></td></tr></table></figure>
<p>如果时间流逝完，就将第1张显示出来，且停止刷新和动画，否则显示第0张。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (done) &#123;</span><br><span class="line">    <span class="keyword">if</span> (!crossFade || alpha == <span class="number">0</span>) &#123;</span><br><span class="line">        array[<span class="number">0</span>].mDrawable.draw(canvas);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (alpha == <span class="number">0xFF</span>) &#123;</span><br><span class="line">        array[<span class="number">1</span>].mDrawable.draw(canvas);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>如果时间没有流逝完，配置二者的透明度，并继续刷新出动画效果。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">array[<span class="number">0</span>].mDrawable.setAlpha(<span class="number">255</span> - alpha);</span><br><span class="line">array[<span class="number">1</span>].mDrawable.setAlpha(alpha);</span><br></pre></td></tr></table></figure>
<h4 id="RippleDrawable"><a href="#RippleDrawable" class="headerlink" title="RippleDrawable"></a>RippleDrawable</h4><p>最简单的添加 Ripple 效果的方法是采用如下属性</p>
<figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">android:background="?attr/selectableItemBackground"</span><br></pre></td></tr></table></figure>
<p>RippleDrawable 的XML标签为 ripple。</p>
<figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">ripple</span> <span class="attr">xmlns:android</span>=<span class="string">"http://schemas.android.com/apk/res/android"</span></span></span><br><span class="line"><span class="tag">    <span class="attr">android:color</span>=<span class="string">"@color/colorAccent"</span>             //触摸波纹颜色</span></span><br><span class="line"><span class="tag">    <span class="attr">android:radius</span>=<span class="string">"30dp"</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">item</span> <span class="attr">android:drawable</span>=<span class="string">"@android:color/white"</span>  //蒙版颜色</span></span><br><span class="line"><span class="tag">          <span class="attr">android:id</span>=<span class="string">"@android:id/mask"</span> /&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">item</span> <span class="attr">android:drawable</span>=<span class="string">"@color/colorPrimary"</span> /&gt;</span> //View 默认颜色</span><br><span class="line"><span class="tag">&lt;/<span class="name">ripple</span>&gt;</span></span><br></pre></td></tr></table></figure>
<p>注意这里有三种颜色，注意<strong>ripple下的color标签将被解析成 ColorStateList 类，这样 RippleDrawable 将可以对状态改变做出波纹效果的响应</strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">RippleDrawable</span><span class="params">(@NonNull ColorStateList color, @Nullable Drawable content,</span></span></span><br><span class="line"><span class="function"><span class="params">        @Nullable Drawable mask)</span> </span>&#123;</span><br><span class="line">    addLayer(content, <span class="keyword">null</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>);</span><br><span class="line">    addLayer(mask, <span class="keyword">null</span>, android.R.id.mask, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>从构造方法可以看出，子类 RippleDrawable 包含两个 Drawable：content 和 mask，后者的 id 是 android.R.id.mask。</p>
<p>当状态改变发生时，将构建 RippleForeground[] 和 RippleBackground 以备绘制。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">boolean</span> <span class="title">onStateChange</span><span class="params">(<span class="keyword">int</span>[] stateSet)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">final</span> <span class="keyword">boolean</span> changed = <span class="keyword">super</span>.onStateChange(stateSet);</span><br><span class="line">    <span class="keyword">boolean</span> enabled = <span class="keyword">false</span>;</span><br><span class="line">    <span class="keyword">boolean</span> pressed = <span class="keyword">false</span>;</span><br><span class="line">    <span class="keyword">boolean</span> focused = <span class="keyword">false</span>;</span><br><span class="line">    <span class="keyword">boolean</span> hovered = <span class="keyword">false</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> state : stateSet) &#123;</span><br><span class="line">        <span class="keyword">if</span> (state == R.attr.state_enabled) &#123;</span><br><span class="line">            enabled = <span class="keyword">true</span>;</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (state == R.attr.state_focused) &#123;</span><br><span class="line">            focused = <span class="keyword">true</span>;</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (state == R.attr.state_pressed) &#123;</span><br><span class="line">            pressed = <span class="keyword">true</span>;</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (state == R.attr.state_hovered) &#123;</span><br><span class="line">            hovered = <span class="keyword">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    setRippleActive(enabled &amp;&amp; pressed);</span><br><span class="line">    setBackgroundActive(hovered || focused || (enabled &amp;&amp; pressed), focused || hovered);</span><br><span class="line">    <span class="keyword">return</span> changed;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>draw 绘制的方法先绘制内容，而后绘制 ripple 效果。</p>
<p>1.绘制内容是正常的 Drawable 绘制，但避免绘制 mask 这一层</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">drawContent</span><span class="params">(Canvas canvas)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// Draw everything except the mask.</span></span><br><span class="line">    <span class="keyword">final</span> ChildDrawable[] array = mLayerState.mChildren;</span><br><span class="line">    <span class="keyword">final</span> <span class="keyword">int</span> count = mLayerState.mNum;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; count; i++) &#123;</span><br><span class="line">        <span class="keyword">if</span> (array[i].mId != R.id.mask) &#123;</span><br><span class="line">            array[i].mDrawable.draw(canvas);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>2.绘制背景以及 Ripple 效果。</p>
<p>Ripple 效果是使用 Shader 来实现的，并将 mask 层绘制到同尺寸的 Bitmap 上去。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">final</span> <span class="keyword">int</span> color = mState.mColor.getColorForState(getState(), Color.BLACK);</span><br><span class="line"><span class="keyword">final</span> <span class="keyword">int</span> halfAlpha = (Color.alpha(color) / <span class="number">2</span>) &lt;&lt; <span class="number">24</span>;</span><br><span class="line"><span class="keyword">final</span> Paint p = getRipplePaint();</span><br><span class="line">p.setColor(halfAlpha);</span><br><span class="line">p.setShader(mMaskShader);</span><br><span class="line">mBackground.draw(canvas, p);</span><br><span class="line">mRipple.draw(canvas, p);</span><br></pre></td></tr></table></figure>
<h2 id="重新认识-Canvas，Path和Paint"><a href="#重新认识-Canvas，Path和Paint" class="headerlink" title="重新认识 Canvas，Path和Paint"></a>重新认识 Canvas，Path和Paint</h2><h3 id="Canvas"><a href="#Canvas" class="headerlink" title="Canvas"></a>Canvas</h3><p>Canvas 记录绘制命令，使用下列方法能够将命令入栈</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">save</span><span class="params">()</span></span>;</span><br></pre></td></tr></table></figure>
<p>而后再将命令出栈，这样就恢复到了 save 时的状态，其中的命令和状态改变就被丢弃</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">restore</span><span class="params">()</span></span>;</span><br></pre></td></tr></table></figure>
<p>Canvas 的各种命令不再多说，只谈一个应该注意的方法</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">clipRect</span><span class="params">(@NonNull Rect rect)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">clipRect</span><span class="params">(@NonNull Rect rect, @NonNull Region.Op op)</span></span>;</span><br></pre></td></tr></table></figure>
<p>这个方法将截取某个区域来显示，其中 Op 表示区域间的叠加方式。</p>
<p>依靠 canvas.clipRect 方法实现的一个典型的例子是 <a href="https://github.com/hongyangAndroid/ColorTrackView" target="_blank" rel="noopener">ColorTrackView</a></p>
<img src="/2017/07/24/android/View/与%20Drawable%20相关的知识点/sc.gif">
<p>核心代码非常简单如下</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">canvas.drawText(<span class="string">"秦时明月汉时关"</span>, centerX, centerY, mPaint);</span><br><span class="line">canvas.clipRect(<span class="number">0</span>, <span class="number">0</span>, getBounds().width()*ratio, getBounds().height());</span><br><span class="line">canvas.drawText(<span class="string">"秦时明月汉时关"</span>, centerX, centerY, mColorPaint);</span><br><span class="line">invalidateSelf();</span><br></pre></td></tr></table></figure>
<h3 id="Path"><a href="#Path" class="headerlink" title="Path"></a>Path</h3><p>Canvas 的另一个方法 clipPath 能实现的效果更多</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">clipPath</span><span class="params">(@NonNull Path path)</span></span></span><br></pre></td></tr></table></figure>
<img src="/2017/07/24/android/View/与%20Drawable%20相关的知识点/crop_inside.png">
<p>上图中的 ArcNavigationView 就是通过创造 Path 绘制出来的，利用这一点可以将控件改造成任意形状，这里以经典的圆形图片为例，只需要重写绘制方法就可以了</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">onDraw</span><span class="params">(Canvas canvas)</span> </span>&#123;</span><br><span class="line">    canvas.clipPath(mPath);</span><br><span class="line">    <span class="keyword">super</span>.onDraw(canvas);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><strong>唯一值得注意的是 Path 的建立位置是不能放在构造方法中的，这个时刻是不能获得控件尺寸的，因此应该将其放在 layout 方法中</strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">onLayout</span><span class="params">(<span class="keyword">boolean</span> changed, <span class="keyword">int</span> left, <span class="keyword">int</span> top, <span class="keyword">int</span> right, <span class="keyword">int</span> bottom)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">super</span>.onLayout(changed, left, top, right, bottom);</span><br><span class="line">    <span class="keyword">if</span>(changed)&#123;</span><br><span class="line">        mPath = <span class="keyword">new</span> Path();</span><br><span class="line">        <span class="keyword">int</span> width = getWidth();</span><br><span class="line">        <span class="keyword">int</span> height = getHeight();</span><br><span class="line">        <span class="keyword">int</span> radius = Math.min(width/<span class="number">2</span>, height/<span class="number">2</span>);</span><br><span class="line">        mPath.addCircle(getWidth()/<span class="number">2</span>, getHeight()/<span class="number">2</span>, radius, Path.Direction.CW);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>Path 的构建方法包括</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">moveTo</span><span class="params">(<span class="keyword">float</span> x, <span class="keyword">float</span> y)</span></span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">lineTo</span><span class="params">(<span class="keyword">float</span> x, <span class="keyword">float</span> y)</span></span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">quadTo</span><span class="params">(<span class="keyword">float</span> x1, <span class="keyword">float</span> y1, <span class="keyword">float</span> x2, <span class="keyword">float</span> y2)</span></span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">cubicTo</span><span class="params">(<span class="keyword">float</span> x1, <span class="keyword">float</span> y1, <span class="keyword">float</span> x2, <span class="keyword">float</span> y2, <span class="keyword">float</span> x3, <span class="keyword">float</span> y3)</span></span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">arcTo</span><span class="params">(<span class="keyword">float</span> left, <span class="keyword">float</span> top, <span class="keyword">float</span> right, <span class="keyword">float</span> bottom, <span class="keyword">float</span> startAngle, <span class="keyword">float</span> sweepAngle, <span class="keyword">boolean</span> forceMoveTo)</span></span></span><br></pre></td></tr></table></figure>
<p>Path 也可以通过添加形状来构建</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">addRect</span><span class="params">(<span class="keyword">float</span> left, <span class="keyword">float</span> top, <span class="keyword">float</span> right, <span class="keyword">float</span> bottom, Direction dir)</span> <span class="comment">// 使用OP.UNION</span></span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">addOval</span><span class="params">(<span class="keyword">float</span> left, <span class="keyword">float</span> top, <span class="keyword">float</span> right, <span class="keyword">float</span> bottom, Direction dir)</span></span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">addCircle</span><span class="params">(<span class="keyword">float</span> x, <span class="keyword">float</span> y, <span class="keyword">float</span> radius, Direction dir)</span></span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">addArc</span><span class="params">(<span class="keyword">float</span> left, <span class="keyword">float</span> top, <span class="keyword">float</span> right, <span class="keyword">float</span> bottom, <span class="keyword">float</span> start, <span class="keyword">float</span> sweep)</span>  </span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">addRoundRect</span><span class="params">(<span class="keyword">float</span> left, <span class="keyword">float</span> top, <span class="keyword">float</span> right, <span class="keyword">float</span> bottom, <span class="keyword">float</span> rx, <span class="keyword">float</span> ry, Direction dir)</span>  </span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">addPath</span><span class="params">(Path src, <span class="keyword">float</span> dx, <span class="keyword">float</span> dy)</span></span></span><br></pre></td></tr></table></figure>
<p><strong>Path 内部包含区域(Region)，如何合并两个 Path 包括如下方式</strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">enum</span> Op &#123;</span><br><span class="line">    DIFFERENCE, <span class="comment">// PathA - PathB</span></span><br><span class="line">    INTERSECT, <span class="comment">// 二者的交集</span></span><br><span class="line">    UNION, <span class="comment">// PathA + PathB</span></span><br><span class="line">    XOR, <span class="comment">// UNION - INTERSECT</span></span><br><span class="line">    REVERSE_DIFFERENCE <span class="comment">// PathB - PathA</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>Path 的另一个主要方法是路径偏移</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">offset</span><span class="params">(<span class="keyword">float</span> dx, <span class="keyword">float</span> dy)</span></span></span><br></pre></td></tr></table></figure>
<h3 id="Paint"><a href="#Paint" class="headerlink" title="Paint"></a>Paint</h3><p>1.获取文字区域 Rect</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">getTextBounds</span><span class="params">(String text, <span class="keyword">int</span> start, <span class="keyword">int</span> end, Rect bounds)</span></span></span><br></pre></td></tr></table></figure>
<p>2.获取文字路径 Path</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">getTextPath</span><span class="params">(String text, <span class="keyword">int</span> start, <span class="keyword">int</span> end, <span class="keyword">float</span> x, <span class="keyword">float</span> y, Path path)</span></span></span><br></pre></td></tr></table></figure>
<blockquote>
<p>使用画笔获取文字路径后，可以使用 Path 的偏移方法调整其位置。</p>
</blockquote>
<p>3.画笔的众多 flag 效果，如添加下划线效果</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setUnderlineText</span><span class="params">(<span class="keyword">boolean</span> underlineText)</span></span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> STRIKE_THRU_TEXT_FLAG </span>= <span class="number">0x10</span>;</span><br></pre></td></tr></table></figure>
<p>4.字体参数 FontMetrics，使用 ascent+descent 可以获得偏移量</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">FontMetrics</span> </span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">float</span>   top;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">float</span>   ascent; <span class="comment">//baseline到字顶，负值</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">float</span>   descent; <span class="comment">//baseline到字底，正值</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">float</span>   bottom;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">float</span>   leading;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>5.获得文本宽度</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">float</span> <span class="title">measureText</span><span class="params">(String text)</span></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> measureText(text, <span class="number">0</span>, text.length());</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//设置最大文本宽度</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">breakText</span><span class="params">(String text, <span class="keyword">boolean</span> measureForwards, loat maxWidth, <span class="keyword">float</span>[] measuredWidth)</span> </span>&#123;&#125;</span><br></pre></td></tr></table></figure>

        
      
    </div>

    
    
    
      <footer class="post-footer">
          <div class="post-eof"></div>
        
      </footer>
  </div>
  
  
  
  </article>

    
        <article itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block home">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2017/07/23/android/View/与 TextView 相关的知识点/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="xiang">
      <meta itemprop="description" content="谨守而勿失，是谓反其真">
      <meta itemprop="image" content="/images/1.jpg">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="lxt">
    </span>
      <header class="post-header">
        <h1 class="post-title" itemprop="name headline">
            
            <a href="/2017/07/23/android/View/与 TextView 相关的知识点/" class="post-title-link" itemprop="url">与 TextView 相关的知识点</a>
          
        </h1>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              
                
              

              <time title="创建时间：2017-07-23 14:28:29" itemprop="dateCreated datePublished" datetime="2017-07-23T14:28:29+08:00">2017-07-23</time>
            </span>
          
            

            
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="fa fa-calendar-check-o"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2019-09-18 14:38:01" itemprop="dateModified" datetime="2019-09-18T14:38:01+08:00">2019-09-18</time>
              </span>
            
          
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing"><a href="/categories/android/" itemprop="url" rel="index"><span itemprop="name">android</span></a></span>

                
                
                  ，
                
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing"><a href="/categories/android/View/" itemprop="url" rel="index"><span itemprop="name">View</span></a></span>

                
                
              
            </span>
          

          
          <br>
            <span class="post-meta-item" title="本文字数">
              <span class="post-meta-item-icon">
                <i class="fa fa-file-word-o"></i>
              </span>
              
                <span class="post-meta-item-text">本文字数：</span>
              
              <span>9.4k</span>
            </span>
          
            <span class="post-meta-item" title="阅读时长">
              <span class="post-meta-item-icon">
                <i class="fa fa-clock-o"></i>
              </span>
              
                <span class="post-meta-item-text">阅读时长 &asymp;</span>
              
              <span>9 分钟</span>
            </span>
          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h2 id="TextView以及其子类"><a href="#TextView以及其子类" class="headerlink" title="TextView以及其子类"></a>TextView以及其子类</h2><p>先说两个小知识</p>
<p><strong>1.TextView 实现跑马灯效果</strong></p>
<figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">TextView</span></span></span><br><span class="line"><span class="tag">    <span class="attr">android:singleLine</span>=<span class="string">"true"</span>            // 必须</span></span><br><span class="line"><span class="tag">    <span class="attr">android:marqueeRepeatLimit</span>=<span class="string">"marquee_forever"</span>  //是否永远循环</span></span><br><span class="line"><span class="tag">    <span class="attr">android:focusable</span>=<span class="string">"true"</span>             // 必须</span></span><br><span class="line"><span class="tag">    <span class="attr">android:focusableInTouchMode</span>=<span class="string">"true"</span>  // 必须 </span></span><br><span class="line"><span class="tag">    <span class="attr">android:ellipsize</span>=<span class="string">"marquee"</span>"/&gt;</span>       // 必须</span><br></pre></td></tr></table></figure>
<p><strong>2.TextView 的字体设置</strong><br>字体设置可以在 fonts.xml 文件中查找，其定义如下</p>
<figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">family</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">nameset</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">name</span>&gt;</span>cursive<span class="tag">&lt;/<span class="name">name</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">nameset</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">fileset</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">file</span>&gt;</span>DancingScript-Regular.ttf<span class="tag">&lt;/<span class="name">file</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">file</span>&gt;</span>DancingScript-Bold.ttf<span class="tag">&lt;/<span class="name">file</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">fileset</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">family</span>&gt;</span></span><br></pre></td></tr></table></figure>
<p>使用时指定名称就可以了</p>
<figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">app:family="casual"  //这是一个 string 类型的属性</span><br></pre></td></tr></table></figure>
<p>读取该值后可以创建字体</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Typeface.create(mFamily, Typeface.NORMAL)</span><br></pre></td></tr></table></figure>
<h3 id="TextView的绘制：Layout"><a href="#TextView的绘制：Layout" class="headerlink" title="TextView的绘制：Layout"></a>TextView的绘制：Layout</h3><p>TextView 在绘制时会先绘制四边的 drawable 。</p>
<figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">android:drawableLeft="@drawable/left"</span><br><span class="line">android:drawableTop="@drawable/top"</span><br><span class="line">android:drawableBottom="@drawable/bottom"</span><br><span class="line">android:drawableRight="@drawable/right"</span><br></pre></td></tr></table></figure>
<p>其余的绘制工作就交给 Layout 类了，正常情况下采用 StaticLayout，而 EditText 采用 DynamicLayout。</p>
<p>Layout 负责文本的布局和绘制，绘制效果取决于构造它的诸多参数</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> text the text to render</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> paint the default paint for the layout.  Styles can override</span></span><br><span class="line"><span class="comment"> * various attributes of the paint.</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> width the wrapping width for the text.</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> align whether to left, right, or center the text.  Styles can</span></span><br><span class="line"><span class="comment"> * override the alignment.</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> spacingMult factor by which to scale the font size to get the</span></span><br><span class="line"><span class="comment"> * default line spacing</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> spacingAdd amount to add to the default line spacing</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">protected</span> <span class="title">Layout</span><span class="params">(CharSequence text, TextPaint paint,</span></span></span><br><span class="line"><span class="function"><span class="params">                 <span class="keyword">int</span> width, Alignment align, TextDirectionHeuristic textDir,</span></span></span><br><span class="line"><span class="function"><span class="params">                 <span class="keyword">float</span> spacingMult, <span class="keyword">float</span> spacingAdd)</span></span></span><br></pre></td></tr></table></figure>
<p>绘制方法包括两步，即按行绘制文本即行背景。</p>
<p>Layout 有很多获取和设置布局的信息，如</p>
<p><strong>1.获得某画笔类TextPaint下的文本宽度</strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">float</span> <span class="title">getDesiredWidth</span><span class="params">(CharSequence source, <span class="keyword">int</span> start, <span class="keyword">int</span> end, TextPaint paint)</span></span></span><br></pre></td></tr></table></figure>
<p><strong>2.获得文本行数以及某一行的信息</strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">getLineCount</span><span class="params">()</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">getLineTop</span><span class="params">(<span class="keyword">int</span> line)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">getLineDescent</span><span class="params">(<span class="keyword">int</span> line)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="keyword">int</span> <span class="title">getLineStart</span><span class="params">(<span class="keyword">int</span> line)</span></span>;</span><br></pre></td></tr></table></figure>
<p>实际上完全可以覆盖掉默认的绘制方法，利用Layout实现绘制效果，如</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">onDraw</span><span class="params">(Canvas canvas)</span> </span>&#123;</span><br><span class="line">    <span class="comment">//super.onDraw(canvas);</span></span><br><span class="line">    Layout layout = getLayout();</span><br><span class="line">    <span class="keyword">int</span> count = layout.getLineCount();</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; count; i++) &#123;</span><br><span class="line">        <span class="keyword">float</span> lineLeft = layout.getLineLeft(i);</span><br><span class="line">        <span class="keyword">float</span> lineBaseline = layout.getLineBaseline(i);</span><br><span class="line">        String lineText = getText().subSequence(lineStart, lineEnd).toString();</span><br><span class="line">        canvas.drawText(lineText, lineLeft, lineBaseline, getPaint());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<blockquote>
<p>这个效果和默认的绘制效果至少看上去完全一致(实际丢失了对marquee标记的处理)，使用 Layout 还能够达成更多效果。</p>
</blockquote>
<h3 id="EditText"><a href="#EditText" class="headerlink" title="EditText"></a>EditText</h3><p>EditText 实际上完完全全就是 TextView，只不过它采用的样式如下</p>
<figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">style</span> <span class="attr">name</span>=<span class="string">"Widget.EditText"</span>&gt;</span></span><br><span class="line"><span class="xml">    <span class="tag">&lt;<span class="name">item</span> <span class="attr">name</span>=<span class="string">"focusable"</span>&gt;</span>true<span class="tag">&lt;/<span class="name">item</span>&gt;</span></span></span><br><span class="line"><span class="xml">    <span class="tag">&lt;<span class="name">item</span> <span class="attr">name</span>=<span class="string">"focusableInTouchMode"</span>&gt;</span>true<span class="tag">&lt;/<span class="name">item</span>&gt;</span></span></span><br><span class="line"><span class="xml">    <span class="tag">&lt;<span class="name">item</span> <span class="attr">name</span>=<span class="string">"clickable"</span>&gt;</span>true<span class="tag">&lt;/<span class="name">item</span>&gt;</span></span></span><br><span class="line"><span class="xml">    <span class="tag">&lt;<span class="name">item</span> <span class="attr">name</span>=<span class="string">"background"</span>&gt;</span>?attr/editTextBackground<span class="tag">&lt;/<span class="name">item</span>&gt;</span></span></span><br><span class="line"><span class="xml">    <span class="tag">&lt;<span class="name">item</span> <span class="attr">name</span>=<span class="string">"textAppearance"</span>&gt;</span>?attr/textAppearanceMediumInverse<span class="tag">&lt;/<span class="name">item</span>&gt;</span></span></span><br><span class="line"><span class="xml">    <span class="tag">&lt;<span class="name">item</span> <span class="attr">name</span>=<span class="string">"textColor"</span>&gt;</span>?attr/editTextColor<span class="tag">&lt;/<span class="name">item</span>&gt;</span></span></span><br><span class="line"><span class="xml">    <span class="tag">&lt;<span class="name">item</span> <span class="attr">name</span>=<span class="string">"gravity"</span>&gt;</span>center_vertical<span class="tag">&lt;/<span class="name">item</span>&gt;</span></span></span><br><span class="line"><span class="xml">    <span class="tag">&lt;<span class="name">item</span> <span class="attr">name</span>=<span class="string">"breakStrategy"</span>&gt;</span>simple<span class="tag">&lt;/<span class="name">item</span>&gt;</span></span></span><br><span class="line"><span class="xml">    <span class="tag">&lt;<span class="name">item</span> <span class="attr">name</span>=<span class="string">"hyphenationFrequency"</span>&gt;</span>normal<span class="tag">&lt;/<span class="name">item</span>&gt;</span></span></span><br><span class="line"><span class="tag">&lt;/<span class="name">style</span>&gt;</span></span><br></pre></td></tr></table></figure>
<p>其背景 drawable 在正常状态下是白色的.9图（@drawable/textfield_default），通过设置如下属性 TextView 亦可以选择文本供剪贴板使用</p>
<figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">android:textIsSelectable="true"</span><br></pre></td></tr></table></figure>
<p>TextView 和 EditText 所得的文本为 EditText 类，这是一个继承了很多文本处理接口的类，功能强大，例如可以设置过滤器 InputFilter，数字输入框，号码框就是靠其实现的。</p>
<blockquote>
<p>AutoCompleteTextView 继承 EditText ，本是一个带 PopupWindow(带 ListView) 的 EditText，获取焦点时显示 PopupWindow。</p>
</blockquote>
<h3 id="Button"><a href="#Button" class="headerlink" title="Button"></a>Button</h3><p>Button 实际上也完完全全就是 TextView，只不过它使用了默认的样式，改变了外观，所采用的样式可以在 themes 文件中找到，如下</p>
<figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">style</span> <span class="attr">name</span>=<span class="string">"Widget.Button"</span>&gt;</span></span><br><span class="line"><span class="xml">    <span class="tag">&lt;<span class="name">item</span> <span class="attr">name</span>=<span class="string">"background"</span>&gt;</span>@drawable/btn_default<span class="tag">&lt;/<span class="name">item</span>&gt;</span></span></span><br><span class="line"><span class="xml">    <span class="tag">&lt;<span class="name">item</span> <span class="attr">name</span>=<span class="string">"focusable"</span>&gt;</span>true<span class="tag">&lt;/<span class="name">item</span>&gt;</span></span></span><br><span class="line"><span class="xml">    <span class="tag">&lt;<span class="name">item</span> <span class="attr">name</span>=<span class="string">"clickable"</span>&gt;</span>true<span class="tag">&lt;/<span class="name">item</span>&gt;</span></span></span><br><span class="line"><span class="xml">    <span class="tag">&lt;<span class="name">item</span> <span class="attr">name</span>=<span class="string">"textAppearance"</span>&gt;</span>?attr/textAppearanceSmallInverse<span class="tag">&lt;/<span class="name">item</span>&gt;</span></span></span><br><span class="line"><span class="xml">    <span class="tag">&lt;<span class="name">item</span> <span class="attr">name</span>=<span class="string">"textColor"</span>&gt;</span>@color/primary_text_light<span class="tag">&lt;/<span class="name">item</span>&gt;</span></span></span><br><span class="line"><span class="xml">    <span class="tag">&lt;<span class="name">item</span> <span class="attr">name</span>=<span class="string">"gravity"</span>&gt;</span>center_vertical|center_horizontal<span class="tag">&lt;/<span class="name">item</span>&gt;</span></span></span><br><span class="line"><span class="tag">&lt;/<span class="name">style</span>&gt;</span></span><br></pre></td></tr></table></figure>
<p>其中影响按钮外观最大的就是背景 Drawable，默认情况下为一个 SelectDrawable，在正常状态下是灰色的.9图(位于res\drawable-mdpi.btn_default_normal.9.png)，并在不同的状态/主题下采用不同颜色的.9图。</p>
<p><strong>android 默认提供了很多按钮的 style</strong>，如</p>
<figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">style="?android:attr/imageButtonStyle"</span><br></pre></td></tr></table></figure>
<h4 id="CompoundButton"><a href="#CompoundButton" class="headerlink" title="CompoundButton"></a>CompoundButton</h4><p>CompoundButton 是一种特殊的 Button，从功能上将它只有两种状态，即是否 isChecked；从实现上看，它采用了新 Drawable 来表示 checked 状态，并重写了 onDraw 方法。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">onDraw</span><span class="params">(Canvas canvas)</span> </span>&#123;</span><br><span class="line">	<span class="comment">//1.首先绘制 TextView 和 背景 Drawable</span></span><br><span class="line">    <span class="keyword">super</span>.onDraw(canvas);</span><br><span class="line">    buttonDrawable.setBounds(left, top, right, bottom);</span><br><span class="line">    <span class="comment">//2.再绘制 buttonDrawable，注意这里的 trick，要处理 scrollX/scrollY</span></span><br><span class="line">    <span class="keyword">if</span> (buttonDrawable != <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="keyword">final</span> <span class="keyword">int</span> scrollX = mScrollX;</span><br><span class="line">        <span class="keyword">final</span> <span class="keyword">int</span> scrollY = mScrollY;</span><br><span class="line">        <span class="keyword">if</span> (scrollX == <span class="number">0</span> &amp;&amp; scrollY == <span class="number">0</span>) &#123;</span><br><span class="line">            buttonDrawable.draw(canvas);</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            canvas.translate(scrollX, scrollY);</span><br><span class="line">            buttonDrawable.draw(canvas);</span><br><span class="line">            canvas.translate(-scrollX, -scrollY);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>因此我们知道改变 CompoundButton 既可以改变其外观，在XML上属性为</p>
<figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">android:button="@null" // 即buttonDrawable为空</span><br></pre></td></tr></table></figure>
<p>在 java 代码上</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setButtonDrawable</span><span class="params">(@DrawableRes <span class="keyword">int</span> resId)</span></span></span><br></pre></td></tr></table></figure>
<p>子类 CheckBox玩玩全全就是 CompoundButton，另一个子类 Switch 则较为复杂。</p>
<p>发生点击事件后处理如下</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">performClick</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    toggle();</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">super</span>.performClick();</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">toggle</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    setChecked(!mChecked);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="Switch"><a href="#Switch" class="headerlink" title="Switch"></a>Switch</h4><p>Switch 上除了 button 参数，另有两个 drawable，底层的叫 “track”，上层的叫“thumb”，上层面积是底层的一半左右，通过遮盖和移位来表示 checked 状态。此外 checked 时的文本叫做 “textOn”，而反之叫做 “textOff”。</p>
<blockquote>
<p>注意此时 Button Drawable 依然有效。</p>
</blockquote>
<p>在实现上，除了重写 onDraw 方法外，还要处理 “thumb” 区域的触摸事件，以完成状态切换。</p>
<p>因为“thumb” 是飘在 “track”上左右移动的，因此切换的动画是用属性动画完成的。</p>
<h2 id="一些与-Text-相关的库"><a href="#一些与-Text-相关的库" class="headerlink" title="一些与 Text 相关的库"></a>一些与 Text 相关的库</h2><h3 id="集大成者-HTextView"><a href="#集大成者-HTextView" class="headerlink" title="集大成者 : HTextView"></a><a href="https://github.com/hanks-zyh/HTextView" target="_blank" rel="noopener"><strong>集大成者 : HTextView</strong></a></h3><p>HTextView 这个库实现的效果华丽，代码的风格和扩展性也非常好，而且作者将不同的效果仅仅分包，引入某种效果的体积极小，实在是不可多得的优质库。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="class"><span class="keyword">class</span> <span class="title">HTextView</span> <span class="keyword">extends</span> <span class="title">TextView</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="keyword">void</span> <span class="title">setProgress</span><span class="params">(<span class="keyword">float</span> progress)</span></span>;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="keyword">void</span> <span class="title">animateText</span><span class="params">(CharSequence text)</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<img src="/2017/07/23/android/View/与%20TextView%20相关的知识点/demo7.gif">
<p>1.Line 效果实质是在文本之外定点，描边，画线，这是附加性质的绘制。</p>
<img src="/2017/07/23/android/View/与%20TextView%20相关的知识点/fade.gif">
<p>2.Fade 效果是自发绘制文本，这里要利用 TextView 中 Layout 这个类。首先**均匀的挑出透明的字符位置，组成 alphaList。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">drawFrame</span><span class="params">(Canvas canvas)</span> </span>&#123;</span><br><span class="line">    Layout layout = mHTextView.getLayout();</span><br><span class="line">    <span class="keyword">int</span> gapIndex = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; layout.getLineCount(); i++) &#123;</span><br><span class="line">        <span class="keyword">int</span> lineStart = layout.getLineStart(i);</span><br><span class="line">        <span class="keyword">int</span> lineEnd = layout.getLineEnd(i);</span><br><span class="line">        <span class="keyword">float</span> lineLeft = layout.getLineLeft(i);</span><br><span class="line">        <span class="keyword">float</span> lineBaseline = layout.getLineBaseline(i);</span><br><span class="line">        String lineText = mText.subSequence(lineStart, lineEnd).toString();</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> c = <span class="number">0</span>; c &lt; lineText.length(); c++) &#123;</span><br><span class="line">            <span class="keyword">int</span> alpha = alphaList.get(gapIndex);</span><br><span class="line">            mPaint.setAlpha((<span class="keyword">int</span>) ((<span class="number">255</span> - alpha) * progress + alpha));</span><br><span class="line">            String str = lineText.substring(j, j+<span class="number">1</span>);</span><br><span class="line">            canvas.drawText(str, lineLeft, lineBaseline, mPaint);</span><br><span class="line">            lineLeft += getPaint().measureText(str);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>
<blockquote>
<p>这里要准确测量每一个字符的宽度。</p>
</blockquote>
<img src="/2017/07/23/android/View/与%20TextView%20相关的知识点/typer.gif">
<p>3.打字机效果的实现十分简单</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setProgress</span><span class="params">(<span class="keyword">float</span> progress)</span> </span>&#123;</span><br><span class="line">    setText(mText.subSequence(<span class="number">0</span>, (<span class="keyword">int</span>) (mText.length() * progress)));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<img src="/2017/07/23/android/View/与%20TextView%20相关的知识点/rainbow.gif">
<p>4.彩虹效果：通过操作Shader的矩阵完成染色。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">onDraw</span><span class="params">(Canvas canvas)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (mMatrix == <span class="keyword">null</span>) &#123;</span><br><span class="line">        mMatrix = <span class="keyword">new</span> Matrix();</span><br><span class="line">    &#125;</span><br><span class="line">    mTranslate += colorSpeed;</span><br><span class="line">    mMatrix.setTranslate(mTranslate, <span class="number">0</span>);</span><br><span class="line">    mLinearGradient.setLocalMatrix(mMatrix);</span><br><span class="line">    <span class="keyword">super</span>.onDraw(canvas);</span><br><span class="line">    postInvalidateDelayed(<span class="number">100</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<img src="/2017/07/23/android/View/与%20TextView%20相关的知识点/demo3.gif">
<p>5.Scale 效果：利用 Layout 重新定义了绘制方法，以重绘新旧字符串。重复的字符移位，其余的收缩。以下两种情况亦然。</p>
<img src="/2017/07/23/android/View/与%20TextView%20相关的知识点/demo6.gif">
<h3 id="Shimmer"><a href="#Shimmer" class="headerlink" title="Shimmer"></a><a href="https://github.com/facebook/shimmer-android" target="_blank" rel="noopener">Shimmer</a></h3><img src="/2017/07/23/android/View/与%20TextView%20相关的知识点/shimmer.gif">
<p>一般情况下闪光效果和 HTextView 一样是采用渐变的效果达成的，对画笔进行设置，使渐变的位置发生偏移，即产生闪光效果。这里只需要改变 Paint 取像素的方式即可</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">mGradient.setLocalMatrix(mMatrix);</span><br><span class="line">getPaint().setShader(mGradient);</span><br></pre></td></tr></table></figure>
<blockquote>
<p>这里将原生画笔的像素提供方式改变了，它只与绘制的内容文本有关，与背景没有干扰。如果要取消闪光效果，可以将其设为null。</p>
</blockquote>
<p>但要达到较好的效果还需要</p>
<p>1.仔细的设置渐变的参数，渐变的设置如下</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">mGradient = <span class="keyword">new</span> LinearGradient(getWidth(), <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>,</span><br><span class="line">        <span class="keyword">new</span> <span class="keyword">int</span>[]&#123;</span><br><span class="line">                getCurrentTextColor(), </span><br><span class="line">                <span class="number">0xFFFFFFFF</span>, </span><br><span class="line">                getCurrentTextColor()&#125;,</span><br><span class="line">        <span class="keyword">new</span> <span class="keyword">float</span>[]&#123;<span class="number">0</span>, <span class="number">0.5f</span>, <span class="number">1</span>&#125;, </span><br><span class="line">        Shader.TileMode.CLAMP);</span><br></pre></td></tr></table></figure>
<p>2.处理矩阵的变化已达到动画效果。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">mMatrix.setTranslate((mProcess-<span class="number">0.5f</span>)*getMeasuredWidth(), <span class="number">0</span>);<span class="comment">//这里要回退半个屏幕距离，和渐变的设置有关</span></span><br><span class="line">mMGradient.setLocalMatrix(mMatrix);</span><br><span class="line"><span class="keyword">super</span>.onDraw(canvas);</span><br></pre></td></tr></table></figure>
<p><strong>facebook的这个 Shimmer 库可贵的是将闪光效果扩展到布局上去了，其实他的做法也是通过Shader，但首先要将 布局内容转为 Bitmap，再在绘制 Bitmap 的时候应用上述这一套。</strong></p>
<h3 id="ReadMoreTextView"><a href="#ReadMoreTextView" class="headerlink" title="ReadMoreTextView"></a><a href="https://github.com/bravoborja/ReadMoreTextView" target="_blank" rel="noopener">ReadMoreTextView</a></h3><img src="/2017/07/23/android/View/与%20TextView%20相关的知识点/expanded.png">
<p>这里文本设置两种模式：显示完全和保留显示(最多显示240字)；</p>
<p>ReadMoreTextView 是利用 ClickSpan 来设置最后的提示文本，<a href="https://github.com/Manabu-GT/ExpandableTextView" target="_blank" rel="noopener">ExpandableTextView</a>这个库则是另外的思路，它本质上是一个 Linear 布局，需要重新计算尺寸，以及在点击事件发生时播放动画。相比之下前者的实现更简洁，但在切换时没有实现动画效果。</p>
<p>实现这个效果，我们要重写如下方法</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setText</span><span class="params">(CharSequence text, BufferType type)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">super</span>.setText(getDisplayText(text), type);</span><br><span class="line">    setMovementMethod(LinkMovementMethod.getInstance());<span class="comment">//使得TextView能够响应动作</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>使用 SpannableStringBuilder 来改造原来的 text</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> CharSequence <span class="title">getDisplayText</span><span class="params">(<span class="keyword">final</span> CharSequence text)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> len = text.length();</span><br><span class="line">    <span class="keyword">if</span> (len &lt; <span class="number">240</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> text;</span><br><span class="line">    &#125;</span><br><span class="line">    SpannableStringBuilder builder = generateText(text, isShowMore);</span><br><span class="line">    builder.setSpan(<span class="keyword">new</span> ClickableSpan() &#123;</span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onClick</span><span class="params">(View widget)</span> </span>&#123;</span><br><span class="line">                isShowMore = !isShowMore;</span><br><span class="line">                setText(text);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;, start, end, Spanned.SPAN_EXCLUSIVE_INCLUSIVE);</span><br><span class="line">    &#125; ;</span><br><span class="line">    <span class="keyword">return</span> builder;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="字体设置"><a href="#字体设置" class="headerlink" title="字体设置"></a><a href="https://github.com/chrisjenx/Calligraphy" target="_blank" rel="noopener">字体设置</a></h3><img src="/2017/07/23/android/View/与%20TextView%20相关的知识点/screenshot.png">
<figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">TextView</span> <span class="attr">fontPath</span>=<span class="string">"fonts/MyFont.ttf"</span>/&gt;</span></span><br></pre></td></tr></table></figure>
<p>这里 TextView 可以使用新的标签，这是通过代理 Context 来实现的，这里主要是改造 LayoutInflater 。改造 Factory2 和 Factory完成。</p>

        
      
    </div>

    
    
    
      <footer class="post-footer">
          <div class="post-eof"></div>
        
      </footer>
  </div>
  
  
  
  </article>

    
        <article itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block home">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2017/07/06/android/View/滑动与触摸/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="xiang">
      <meta itemprop="description" content="谨守而勿失，是谓反其真">
      <meta itemprop="image" content="/images/1.jpg">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="lxt">
    </span>
      <header class="post-header">
        <h1 class="post-title" itemprop="name headline">
            
            <a href="/2017/07/06/android/View/滑动与触摸/" class="post-title-link" itemprop="url">滑动与触摸</a>
          
        </h1>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              
                
              

              <time title="创建时间：2017-07-06 21:26:26" itemprop="dateCreated datePublished" datetime="2017-07-06T21:26:26+08:00">2017-07-06</time>
            </span>
          
            

            
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="fa fa-calendar-check-o"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2019-09-18 15:52:50" itemprop="dateModified" datetime="2019-09-18T15:52:50+08:00">2019-09-18</time>
              </span>
            
          
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing"><a href="/categories/android/" itemprop="url" rel="index"><span itemprop="name">android</span></a></span>

                
                
                  ，
                
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing"><a href="/categories/android/View/" itemprop="url" rel="index"><span itemprop="name">View</span></a></span>

                
                
              
            </span>
          

          
          <br>
            <span class="post-meta-item" title="本文字数">
              <span class="post-meta-item-icon">
                <i class="fa fa-file-word-o"></i>
              </span>
              
                <span class="post-meta-item-text">本文字数：</span>
              
              <span>16k</span>
            </span>
          
            <span class="post-meta-item" title="阅读时长">
              <span class="post-meta-item-icon">
                <i class="fa fa-clock-o"></i>
              </span>
              
                <span class="post-meta-item-text">阅读时长 &asymp;</span>
              
              <span>15 分钟</span>
            </span>
          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <p>滑动事件和触摸机制的结合有一定的套路，但也比较的复杂。其套路大概是在 ACTION_MOVE 动作时进行拖动，到了 ACTION_UP 动作进行释放，其中夹杂着一些处理动作坐标，id，速度，touchslop ，scroll 清理等琐碎的事件，<strong>但最核心和复杂的地方还是在于处理好触摸事件的传递</strong>。</p>
<h2 id="ViewDragHelper"><a href="#ViewDragHelper" class="headerlink" title="ViewDragHelper"></a>ViewDragHelper</h2><p>ViewDragHelper 类干预了容器的触摸事件机制，是一个非常好的研究对象。具体干预可以分为两个阶段</p>
<ul>
<li>拖动阶段：此时使用ViewCompat.offset 方法进行移动。</li>
<li>释放阶段：非必须，依赖于 Scoller 类来实现。</li>
</ul>
<p>ViewDragHelper 的工作实际非常简单，即获取点击点下的子控件，并随着手指滑动它，手势离开时释放，Callback 可以提供一些参数和信息，也包括处理一些回调。</p>
<p>在处理滑动的时候有两个细节要注意</p>
<p><strong>1.如何判断和获取滑动的步进距离？</strong></p>
<p>ACTION_MOVE事件下的实际步进距离 dx/dy 为两次动作的差值，一般都设定不能超过 touchslop。</p>
<p>此外dx/dy 的取值不能按照真实值，而是以 touchslop 为准，以保持滑动过程的平稳。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//相当于给本来紊乱的数据流加了一个滑动滤波器，使其归于平稳</span></span><br><span class="line"><span class="keyword">if</span> (Math.abs(dx) &gt;= touchSlop) &#123;</span><br><span class="line">    dx = (dx &gt; <span class="number">0</span>) ? touchSlop : -touchSlop;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span> (Math.abs(dy) &gt;= touchSlop) &#123;</span><br><span class="line">    dy = (dy &gt; <span class="number">0</span>) ? touchSlop : -touchSlop;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><strong>2.如何确定实际移动距离？</strong></p>
<p>有了可用的步进距离，还需要看控件是不是实际需要移动这么多距离，移动时CapureView的位置有三个取值</p>
<ul>
<li><p>旧值 int oldLeft = toCapture.getLeft();</p>
</li>
<li><p>期望值 int targetLeft = oldLeft + (int) dx;</p>
</li>
<li><p><strong>实际值 int clampedX = mCallback.clampViewPositionHorizontal(oldLeft , dx);</strong></p>
</li>
</ul>
<p>clampViewPositionHorizontal 方法是必须实现的，否则控件只能移动到(0，0)坐标处。</p>
<h3 id="深入触摸事件处理的实现"><a href="#深入触摸事件处理的实现" class="headerlink" title="深入触摸事件处理的实现"></a>深入触摸事件处理的实现</h3><p>现在深入讨论下在如下简单使用的情况下，ViewDragHelper 是如何进行触摸事件处理的？</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">onInterceptTouchEvent</span><span class="params">(MotionEvent ev)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> dragHelper.shouldInterceptTouchEvent(ev);</span><br><span class="line">&#125;</span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">onTouchEvent</span><span class="params">(MotionEvent ev)</span> </span>&#123;</span><br><span class="line">    dragHelper.processTouchEvent(ev);</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>首先明确拦截方法是以状态是否为拖动状态(即STATE_DRAGGING) 为判据的。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">shouldInterceptTouchEvent</span><span class="params">(MotionEvent ev)</span> </span>&#123;</span><br><span class="line">    <span class="comment">//...</span></span><br><span class="line">    <span class="keyword">return</span> mDragState == STATE_DRAGGING;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>正常点击(即状态为STATE_IDLE，点击动作为 ACTION_DOWN) 时，此方法并不去捕捉View，也不修改状态，自然也就拦截无效，事件向下传递；<strong>这时要想生效，只能祈祷下面的控件不要处理事件，使得事件能够传回到 onTouchEvent 方法中进行View的捕捉，并修改状态为 STATE_DRAGGING。</strong></p>
<p><strong>这样当动作转为 ACTION_MOVE 后，拦截机制虽然判定为真，但却没有机会执行了，而是直接执行 onTouchEvent 方法进行拖动，直到释放为止。</strong></p>
<p>这里有两个引申问题</p>
<p><strong>1.实际上拦截方法什么都没干，去掉拦截方法，也一样能够实现拖动效果。如果子控件拦截了事件(如设置了监听器)，那么 ViewDragHelper 的这种简单使用方法就失效了，不会产生拖动效果。</strong></p>
<p>2.那么拦截事件的意义是什么呢？</p>
<p><strong>当释放控件或处在释放状态(即STATE_SETTLING)时，发生触摸时，拦截方法将发挥作用，此时会主动进行捕捉View和修改状态，触摸事件被拦截在这一层，其主要意义在于截断了子控件的事件处理</strong>。</p>
<p><strong>此外在动作处于 ACTION_MOVE 时，也会尝试截断事件处理流程。</strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//1.计算每一个手指</span></span><br><span class="line"><span class="keyword">final</span> <span class="keyword">int</span> pointerCount = ev.getPointerCount();</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; pointerCount; i++) &#123;</span><br><span class="line">  </span><br><span class="line">    <span class="keyword">final</span> <span class="keyword">int</span> pointerId = ev.getPointerId(i);</span><br><span class="line">    <span class="keyword">final</span> <span class="keyword">float</span> x = ev.getX(i);</span><br><span class="line">    <span class="keyword">final</span> <span class="keyword">float</span> y = ev.getY(i);</span><br><span class="line">    <span class="keyword">final</span> <span class="keyword">float</span> dx = x - mInitialMotionX[pointerId];</span><br><span class="line">    <span class="keyword">final</span> <span class="keyword">float</span> dy = y - mInitialMotionY[pointerId];</span><br><span class="line">    <span class="keyword">final</span> View toCapture = findTopChildUnder((<span class="keyword">int</span>) x, (<span class="keyword">int</span>) y);</span><br><span class="line">    <span class="comment">//2，滑动距离要超过 TouchSlop</span></span><br><span class="line">    <span class="keyword">final</span> <span class="keyword">boolean</span> pastSlop = toCapture != <span class="keyword">null</span> &amp;&amp; checkTouchSlop(toCapture, dx, dy);</span><br><span class="line">    <span class="keyword">if</span> (pastSlop) &#123;</span><br><span class="line">        <span class="comment">//3. 实际想要滑动的距离 newLeft和newTop</span></span><br><span class="line">        <span class="keyword">final</span> <span class="keyword">int</span> oldLeft = toCapture.getLeft();</span><br><span class="line">        <span class="keyword">final</span> <span class="keyword">int</span> targetLeft = oldLeft + (<span class="keyword">int</span>) dx;</span><br><span class="line">        <span class="keyword">final</span> <span class="keyword">int</span> newLeft = mCallback.clampViewPositionHorizontal(toCapture,</span><br><span class="line">                targetLeft, (<span class="keyword">int</span>) dx);</span><br><span class="line">        <span class="keyword">final</span> <span class="keyword">int</span> oldTop = toCapture.getTop();</span><br><span class="line">        <span class="keyword">final</span> <span class="keyword">int</span> targetTop = oldTop + (<span class="keyword">int</span>) dy;</span><br><span class="line">        <span class="keyword">final</span> <span class="keyword">int</span> newTop = mCallback.clampViewPositionVertical(toCapture, targetTop,</span><br><span class="line">                (<span class="keyword">int</span>) dy);</span><br><span class="line">        <span class="comment">//4.水平和垂直滑动范围 horizontalDragRange和verticalDragRange</span></span><br><span class="line">        <span class="keyword">final</span> <span class="keyword">int</span> horizontalDragRange = mCallback.getViewHorizontalDragRange(</span><br><span class="line">                toCapture);</span><br><span class="line">        <span class="keyword">final</span> <span class="keyword">int</span> verticalDragRange = mCallback.getViewVerticalDragRange(toCapture);</span><br><span class="line">        <span class="comment">//5. 屏蔽掉不能滑动的情况</span></span><br><span class="line">        <span class="keyword">if</span> ((horizontalDragRange == <span class="number">0</span> || horizontalDragRange &gt; <span class="number">0</span></span><br><span class="line">                &amp;&amp; newLeft == oldLeft) &amp;&amp; (verticalDragRange == <span class="number">0</span></span><br><span class="line">                || verticalDragRange &gt; <span class="number">0</span> &amp;&amp; newTop == oldTop)) &#123;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//6.一旦某一个手指的动作符合标准，尝试捕捉View和拦截</span></span><br><span class="line">    <span class="keyword">if</span> (pastSlop &amp;&amp; tryCaptureViewForDrag(toCapture, pointerId)) &#123;</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这部分代码只在子控件获取到控制权时才发挥作用，其效果就是把控制权夺取回来。前面已经说过，如果子控件设置了点击事件监听器，ViewDragHelper 默认就无法拦截和处理了，你可以做以下配置解决这个问题，使得子控件的点击事件和滑动同时生效。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">getViewHorizontalDragRange</span><span class="params">(View child)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">getViewVerticalDragRange</span><span class="params">(View child)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>只要上述两个方法有一个不返还 0 就可以完成事件的截断。只是也要避免以下的极端情况</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">clampViewPositionHorizontal</span><span class="params">(View child, <span class="keyword">int</span> left, <span class="keyword">int</span> dx)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> left-dx;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<blockquote>
<p>最后还应该注意到，这种简单实现中，onTouchEvent 方法则永远进行处理，这意味着其上的控件永远无法得到处理机会，除非提前使用拦截方法完成拦截。</p>
</blockquote>
<h3 id="释放后的滚动"><a href="#释放后的滚动" class="headerlink" title="释放后的滚动"></a>释放后的滚动</h3><p>当ACTION_UP和ACTION_CANCEL事件发生时，将进行控件的释放，即</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">releaseViewForPointerUp</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    mVelocityTracker.computeCurrentVelocity(<span class="number">1000</span>, mMaxVelocity);</span><br><span class="line">    <span class="keyword">final</span> <span class="keyword">float</span> xvel = clampMag(</span><br><span class="line">            VelocityTrackerCompat.getXVelocity(mVelocityTracker, mActivePointerId),</span><br><span class="line">            mMinVelocity, mMaxVelocity);</span><br><span class="line">    <span class="keyword">final</span> <span class="keyword">float</span> yvel = clampMag(</span><br><span class="line">            VelocityTrackerCompat.getYVelocity(mVelocityTracker, mActivePointerId),</span><br><span class="line">            mMinVelocity, mMaxVelocity);</span><br><span class="line">    dispatchViewReleased(xvel, yvel);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这里将调用onViewReleased回调方法，并将状态设置回 STATE_IDLE。</p>
<p>在回调方法里可以主动释放控件，该效果基于ScrollerCompat 实现，需要smoothSlideViewTo方法与continueSettling 方法配合使用。例如</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//callback 中的回调方法</span></span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onViewReleased</span><span class="params">(View releasedChild, <span class="keyword">float</span> xvel, <span class="keyword">float</span> yvel)</span> </span>&#123;</span><br><span class="line">    mHelper.smoothSlideViewTo(releasedChild, <span class="number">100</span>, <span class="number">300</span>); <span class="comment">//移动到一个点上</span></span><br><span class="line">    <span class="comment">//dragHelper.flingCapturedView(0, 200, 200, 400); 返回到一个区域内</span></span><br><span class="line">    invalidate();</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//容器内</span></span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">computeScroll</span><span class="params">()</span> </span>&#123;</span><br><span class="line">   <span class="keyword">if</span> (mLeftDragger.continueSettling(<span class="keyword">true</span>)) &#123;</span><br><span class="line">       ViewCompat.postInvalidateOnAnimation(<span class="keyword">this</span>);</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这里 smoothSlideViewTo 方法实际是要 Scroller 实现的，其参数指定了滑动的终点，而起点则是View的左上角(left/top)，至于滑动的时间还与速度速度有关。</p>
<p>这里提一下速度参数的获取和使用</p>
<h4 id="VelocityTracker"><a href="#VelocityTracker" class="headerlink" title="VelocityTracker"></a><strong>VelocityTracker</strong></h4><p>VelocityTracker计算速度的流程如下</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//1，带入动作 MotionEvent</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">addMovement</span><span class="params">(MotionEvent event)</span></span>;</span><br><span class="line"><span class="comment">//2，配置时间单位 1000表示每秒速度，1表示每毫秒速度</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">computeCurrentVelocity</span><span class="params">(<span class="keyword">int</span> units)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">float</span> <span class="title">getYVelocity</span><span class="params">(<span class="keyword">int</span> id)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">float</span> <span class="title">getXVelocity</span><span class="params">(<span class="keyword">int</span> id)</span></span>;</span><br></pre></td></tr></table></figure>
<p>获取速度分量之后的使用与 scroller 有关，即作为滑动的一个参数。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">fling</span><span class="params">(<span class="keyword">int</span> startX, <span class="keyword">int</span> startY, <span class="keyword">int</span> velocityX, <span class="keyword">int</span> velocityY, <span class="keyword">int</span> minX, <span class="keyword">int</span> maxX, <span class="keyword">int</span> minY, <span class="keyword">int</span> maxY)</span></span></span><br></pre></td></tr></table></figure>
<h3 id="额外的细节：边界处理和锁定"><a href="#额外的细节：边界处理和锁定" class="headerlink" title="额外的细节：边界处理和锁定"></a>额外的细节：边界处理和锁定</h3><p>因为四边区域是有交叉的，故而应该采用位运算的标记方式来表示它们。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> EDGE_LEFT = <span class="number">1</span> &lt;&lt; <span class="number">0</span>;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> EDGE_RIGHT = <span class="number">1</span> &lt;&lt; <span class="number">1</span>;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> EDGE_TOP = <span class="number">1</span> &lt;&lt; <span class="number">2</span>;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> EDGE_BOTTOM = <span class="number">1</span> &lt;&lt; <span class="number">3</span>;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> EDGE_ALL = EDGE_LEFT | EDGE_TOP | EDGE_RIGHT | EDGE_BOTTOM;</span><br></pre></td></tr></table></figure>
<p>如何判断点击点(x,y)处于四边之内呢？</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">int</span> <span class="title">getEdgesTouched</span><span class="params">(<span class="keyword">int</span> x, <span class="keyword">int</span> y)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> result = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">if</span> (x &lt; mParentView.getLeft() + mEdgeSize) result |= EDGE_LEFT;</span><br><span class="line">    <span class="keyword">if</span> (y &lt; mParentView.getTop() + mEdgeSize) result |= EDGE_TOP;</span><br><span class="line">    <span class="keyword">if</span> (x &gt; mParentView.getRight() - mEdgeSize) result |= EDGE_RIGHT;</span><br><span class="line">    <span class="keyword">if</span> (y &gt; mParentView.getBottom() - mEdgeSize) result |= EDGE_BOTTOM;</span><br><span class="line">    <span class="keyword">return</span> result;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>在触摸事件处理时，ACTION_MOVE 动作只处理点击点在控件内的事件，此时是无法使用边界的；只有在 ACTION_DOWN 动作时才能进行拦截，处理代码如下</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">final</span> <span class="keyword">int</span> edgesTouched = mInitialEdgesTouched[pointerId];</span><br><span class="line"><span class="keyword">if</span> ((edgesTouched &amp; mTrackingEdges) != <span class="number">0</span>) &#123;</span><br><span class="line">    mCallback.onEdgeTouched(edgesTouched &amp; mTrackingEdges, pointerId);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这里首先要配置 mTrackingEdges 参数。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">viewDragHelper.setEdgeTrackingEnabled(ViewDragHelper.EDGE_ALL);</span><br></pre></td></tr></table></figure>
<p>而后在回调方法中进行捕捉View</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onEdgeTouched</span><span class="params">(<span class="keyword">int</span> edgeFlags, <span class="keyword">int</span> pointerId)</span> </span>&#123;</span><br><span class="line">    dragHelper.tryCaptureViewForDrag(getChildAt(<span class="number">0</span>), pointerId);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这样就改变了事件处理的流程，截断了事件的向下传递，改为容器自己处理。</p>
<h3 id="ViewDragHelper的实践：SwipeBackLayout"><a href="#ViewDragHelper的实践：SwipeBackLayout" class="headerlink" title="ViewDragHelper的实践：SwipeBackLayout"></a>ViewDragHelper的实践：SwipeBackLayout</h3><img src="/2017/07/06/android/View/滑动与触摸/screenshot.png">
<blockquote>
<p>同类型的库还有<a href="https://github.com/anzewei/ParallaxBackLayout" target="_blank" rel="noopener">ParallaxBackLayout</a>。</p>
</blockquote>
<p>使用 ViewDragHelper 可以快速实现一些容器，例如抽屉控件等，这里介绍一个经典的库 SwipeBackLayout，其效果是使得 Activity 能够滑动关闭，达到这种效果需要三步。</p>
<p>1.使用 ViewDragHelper 定义 SwipeBackLayout，其内部只有一个子控件就是 Activity 的 content 控件。</p>
<p>2.在DecorView中插入 SwipeBackLayout 布局，并将原来Activity 的 content 控件加入到此布局中去。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">ViewGroup decor = (ViewGroup) activity.getWindow().getDecorView();</span><br><span class="line">ViewGroup decorChild = (ViewGroup) decor.getChildAt(<span class="number">0</span>);</span><br><span class="line">TypedArray a = activity.getTheme().obtainStyledAttributes(<span class="keyword">new</span> <span class="keyword">int</span>[]&#123;</span><br><span class="line">        android.R.attr.windowBackground</span><br><span class="line">&#125;);</span><br><span class="line"><span class="keyword">int</span> background = a.getResourceId(<span class="number">0</span>, <span class="number">0</span>);</span><br><span class="line">a.recycle();</span><br><span class="line">decorChild.setBackgroundResource(background);</span><br><span class="line"><span class="comment">//decor删去内容控件，添加 SwipeBackLayout，SwipeBackLayout再添加 内容控件</span></span><br><span class="line">decor.removeView(decorChild);</span><br><span class="line">addView(decorChild);</span><br><span class="line">setContentView(decorChild);</span><br><span class="line">decor.addView(<span class="keyword">this</span>);</span><br></pre></td></tr></table></figure>
<p>到此为止，内容控件可以被捕捉和滑动了。</p>
<p><strong>3.实现透明效果</strong></p>
<p>将 window 的背景改为透明</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">mActivity.getWindow().setBackgroundDrawable(<span class="keyword">new</span> ColorDrawable(Color.TRANSPARENT));</span><br></pre></td></tr></table></figure>
<p>正常情况下背景将变成黑色，如果不使用该方法则默认的windowBackground颜色是白色。此时需要采用 translucent 模式，修改主题为</p>
<figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">style</span> <span class="attr">name</span>=<span class="string">"AppTheme"</span> <span class="attr">parent</span>=<span class="string">"Theme.AppCompat.Light.DarkActionBar"</span>&gt;</span></span><br><span class="line"><span class="xml">    <span class="tag">&lt;<span class="name">item</span> <span class="attr">name</span>=<span class="string">"android:windowIsTranslucent"</span>&gt;</span>true<span class="tag">&lt;/<span class="name">item</span>&gt;</span></span></span><br><span class="line"><span class="tag">&lt;/<span class="name">style</span>&gt;</span></span><br></pre></td></tr></table></figure>
<h2 id="嵌套滑动-NestedScroll"><a href="#嵌套滑动-NestedScroll" class="headerlink" title="嵌套滑动(NestedScroll)"></a>嵌套滑动(NestedScroll)</h2><p>嵌套滑动机制解决<strong>主控件</strong>的滑动带动<strong>副控件</strong>做跟随滑动的问题，这其实是很不可思议的一件事，因为事件触摸机制会截断事件的处理，正常情况下一次只能滑动一个控件。</p>
<p>使用嵌套滑动时主要实现主控件的逻辑，即 NestedScrollingParent 接口中的方法，一般是进行主控件的滑动。</p>
<p><strong>在一次嵌套滑动事件中，二者处于问答式交互，其一般流程如下</strong></p>
<p>1.调用 startNestedScroll() 方法，子控件会在控件树上不断上溯寻找能够响应嵌套滑动事件的父容器，一旦确定会调用父控件的 onStartNestedScroll 方法和 onNestedScrollAccepted 方法判断是否响应，一旦父控件响应就会启动嵌套滑动。</p>
<p>2.执行 dispatchNestedPreScroll 方法，触发父控件中的嵌套滑动事件回调，此时可以滑动父控件。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//dx表示限定的滑动距离，consumed记录父容器消费的滑动距离，offsetInWindow距离在屏幕上移动的距离</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">dispatchNestedPreScroll</span><span class="params">(<span class="keyword">int</span> dx, <span class="keyword">int</span> dy, <span class="keyword">int</span>[] consumed, <span class="keyword">int</span>[] offsetInWindow)</span> </span>&#123;</span><br><span class="line">    <span class="comment">//1.如果开启嵌套滑动，且父控件存在，且滑动有效</span></span><br><span class="line">    mView.getLocationInWindow(offsetInWindow);</span><br><span class="line">    <span class="keyword">int</span> startX = offsetInWindow[<span class="number">0</span>];</span><br><span class="line">    <span class="keyword">int</span> startY = offsetInWindow[<span class="number">1</span>];</span><br><span class="line">    </span><br><span class="line">    consumed[<span class="number">0</span>] = <span class="number">0</span>;</span><br><span class="line">    consumed[<span class="number">1</span>] = <span class="number">0</span>;  </span><br><span class="line">    <span class="comment">//2.执行父控件回调</span></span><br><span class="line">    ViewParentCompat.onNestedPreScroll(mNestedScrollingParent, mView, dx, dy, consumed);</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//3.在滑动前后计算了子控件在屏幕上的偏移位置 offsetInWindow，</span></span><br><span class="line">    <span class="comment">//这和父控件的消费量 consumed 是有所差别的，最后返回的结果是父控件是否滑动了</span></span><br><span class="line">    mView.getLocationInWindow(offsetInWindow);</span><br><span class="line">    offsetInWindow[<span class="number">0</span>] -= startX;</span><br><span class="line">    offsetInWindow[<span class="number">1</span>] -= startY; </span><br><span class="line">    <span class="keyword">return</span> consumed[<span class="number">0</span>] != <span class="number">0</span> || consumed[<span class="number">1</span>] != <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这里如果<code>consumed</code>数组中的值不为0，整个方法返回<code>true</code>，表示父控件消费了滑动事件。</p>
<p>3.最后一轮对话 dispatchNestedScroll 方法</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//dxConsumed 是子控件滑动的消费，dxUnconsumed则是留给父容器的未消费距离</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">dispatchNestedScroll</span><span class="params">(dxConsumed, dyConsumed, dxUnconsumed, dyUnconsumed,</span></span></span><br><span class="line"><span class="function"><span class="params">        offsetInWindow)</span></span>;</span><br></pre></td></tr></table></figure>
<p><strong>要使用嵌套滑动，要在触摸事件方法中进行，以便启动该机制；其次要设置父容器的嵌套处理方法。</strong>例如</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onNestedPreScroll</span><span class="params">(View target, <span class="keyword">int</span> dx, <span class="keyword">int</span> dy, <span class="keyword">int</span>[] consumed)</span></span>&#123;</span><br><span class="line">    consumed[<span class="number">1</span>] = dy/<span class="number">2</span>;</span><br><span class="line">    ViewCompat.offsetTopAndBottom(<span class="keyword">this</span>, consumed[<span class="number">1</span>]);    <span class="comment">//父容器消费一半距离</span></span><br><span class="line">    ViewCompat.offsetTopAndBottom(target, -consumed[<span class="number">1</span>]); <span class="comment">//抵消子控件跟随父容器的滚动</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onNestedScroll</span><span class="params">(View target, <span class="keyword">int</span> dxConsumed, <span class="keyword">int</span> dyConsumed,</span></span></span><br><span class="line"><span class="function"><span class="params">                           <span class="keyword">int</span> dxUnconsumed, <span class="keyword">int</span> dyUnconsumed)</span></span>&#123;</span><br><span class="line">    ViewCompat.offsetTopAndBottom(<span class="keyword">this</span>, dyUnconsumed); <span class="comment">//父容器滚动另一半内部滚动距离</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>就会得到一个2倍的视差滚动效果，子控件的滚动速度是父控件的一半。</p>
<p>下面我们先研究 ScrollView 和 NestedScrollView 中是如何使用嵌套滑动的。</p>
<h2 id="ScrollView"><a href="#ScrollView" class="headerlink" title="ScrollView"></a>ScrollView</h2><p>ScrollView 类是一个研究滑动与触摸的绝佳例子，它拦截触摸事件进行上下滚动，而且能够响应嵌套滑动事件。</p>
<p>ScrollView 的拦截是以 mIsBeingDragged 位来判定的，这里有一些简化步骤。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">onInterceptTouchEvent</span><span class="params">(MotionEvent ev)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">final</span> <span class="keyword">int</span> action = ev.getAction();</span><br><span class="line">    <span class="comment">//1.如果 ACTION_MOVE 且 mIsBeingDragged 直接拦截</span></span><br><span class="line">    <span class="keyword">if</span> ((action == MotionEvent.ACTION_MOVE) &amp;&amp; (mIsBeingDragged)) <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">    <span class="comment">//2.先正常拦截，避免阻塞子控件中的事件，只有</span></span><br><span class="line">    <span class="keyword">if</span> (<span class="keyword">super</span>.onInterceptTouchEvent(ev)) <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">    <span class="comment">//3.不能滑动，不拦截</span></span><br><span class="line">    <span class="keyword">if</span> (getScrollY() == <span class="number">0</span> &amp;&amp; !canScrollVertically(<span class="number">1</span>)) <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">  </span><br><span class="line">    <span class="comment">//,,,,,,</span></span><br><span class="line">    <span class="keyword">return</span> mIsBeingDragged;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>我们首先说说，在 ACTION_DOWN 和 ACTION_UP 里进行的初始化和回收工作，注意这两个动作里一定是不进行拦截的。</p>
<p><strong>1.动作 ACTION_DOWN 发生时要注意清理旧的滚动以及开启嵌套滑动。</strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">mScroller.computeScrollOffset();       </span><br><span class="line">mIsBeingDragged = !mScroller.isFinished();<span class="comment">//3.如果滑动完成了，不拦截；仍在滑动，拦截处理</span></span><br><span class="line">startNestedScroll(SCROLL_AXIS_VERTICAL);  <span class="comment">//4.请求嵌套滑动</span></span><br></pre></td></tr></table></figure>
<p>这里按下时控件在滑动中，会拦截事件进行处理，主要是停止正在进行的滑动，并记录数据</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//1.禁止父容器拦截事件，停止滚动，记录数据</span></span><br><span class="line"><span class="keyword">if</span> ((mIsBeingDragged = !mScroller.isFinished())) &#123;</span><br><span class="line">    getParent().requestDisallowInterceptTouchEvent(<span class="keyword">true</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span> (!mScroller.isFinished()) &#123;</span><br><span class="line">    mScroller.abortAnimation(); </span><br><span class="line">&#125;</span><br><span class="line">mLastMotionY = (<span class="keyword">int</span>) ev.getY();</span><br><span class="line">mActivePointerId = ev.getPointerId(<span class="number">0</span>);</span><br><span class="line">startNestedScroll(SCROLL_AXIS_VERTICAL);</span><br></pre></td></tr></table></figure>
<p>要注意的是，这时 mIsBeingDragged 的值为 false，不会发生拦截，事件将向下传递，如果没有人处理，则在 onTouchEvent 方法是这样处理的。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> ((mIsBeingDragged = !mScroller.isFinished())) &#123;</span><br><span class="line">    getParent().requestDisallowInterceptTouchEvent(<span class="keyword">true</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span> (!mScroller.isFinished()) &#123;</span><br><span class="line">    mScroller.abortAnimation();</span><br><span class="line">&#125;</span><br><span class="line">startNestedScroll(SCROLL_AXIS_VERTICAL);</span><br></pre></td></tr></table></figure>
<p>mIsBeingDragged 的值是 mScroller 是否还在滚动。</p>
<p><strong>2.动作 ACTION_UP 发生时，不进行拦截，但又要完成释放回弹和停止嵌套滑动的动作。</strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">mIsBeingDragged = <span class="keyword">false</span>;</span><br><span class="line"><span class="keyword">if</span> (mScroller.springBack(mScrollX, mScrollY, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, getScrollRange())) &#123;</span><br><span class="line">    postInvalidateOnAnimation();</span><br><span class="line">&#125;</span><br><span class="line">stopNestedScroll();</span><br></pre></td></tr></table></figure>
<p><strong>3.最主要的事件处理发生在 动作ACTION_MOVE 中，此时将发生拦截。</strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//1.根据判定条件进行拦截</span></span><br><span class="line"><span class="keyword">if</span> (yDiff &gt; mTouchSlop &amp;&amp; (getNestedScrollAxes() &amp; SCROLL_AXIS_VERTICAL) == <span class="number">0</span>) &#123;</span><br><span class="line">    mIsBeingDragged = <span class="keyword">true</span>;</span><br><span class="line">    mLastMotionY = y; <span class="comment">//更新 mLastMotionY</span></span><br><span class="line">    initVelocityTrackerIfNotExists(); <span class="comment">//更新 VelocityTracker</span></span><br><span class="line">    mVelocityTracker.addMovement(ev);</span><br><span class="line">    mNestedYOffset = <span class="number">0</span>;</span><br><span class="line">    getParent().requestDisallowInterceptTouchEvent(<span class="keyword">true</span>); <span class="comment">//一旦拦截，不许父控件拦截</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><strong>包含嵌套滑动的滚动处理，首先交给父控件进行嵌套滑动，而后子控件自己滚动，最后再交给父控件一次</strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">final</span> <span class="keyword">int</span> y = (<span class="keyword">int</span>) ev.getY(activePointerIndex);</span><br><span class="line"><span class="keyword">int</span> deltaY = mLastMotionY - y;</span><br><span class="line"><span class="keyword">if</span> (dispatchNestedPreScroll(<span class="number">0</span>, deltaY, mScrollConsumed, mScrollOffset)) &#123;</span><br><span class="line">    deltaY -= mScrollConsumed[<span class="number">1</span>]; <span class="comment">//1.deltaY 减去嵌套滑动已消费的距离</span></span><br><span class="line">    vtev.offsetLocation(<span class="number">0</span>, mScrollOffset[<span class="number">1</span>]); </span><br><span class="line">    mNestedYOffset += mScrollOffset[<span class="number">1</span>];<span class="comment">//2.mNestedYOffset 记录嵌套滑动已消费的距离</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span> (!mIsBeingDragged &amp;&amp; Math.abs(deltaY) &gt; mTouchSlop) &#123;</span><br><span class="line">    getParent().requestDisallowInterceptTouchEvent(<span class="keyword">true</span>);</span><br><span class="line">    mIsBeingDragged = <span class="keyword">true</span>;</span><br><span class="line">    <span class="keyword">if</span> (deltaY &gt; <span class="number">0</span>) &#123;</span><br><span class="line">        deltaY -= mTouchSlop;     <span class="comment">//3.控制 deltaY 的数值，使其滑动均匀可控</span></span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        deltaY += mTouchSlop;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span> (mIsBeingDragged) &#123;</span><br><span class="line">    mLastMotionY = y - mScrollOffset[<span class="number">1</span>];</span><br><span class="line">    <span class="keyword">final</span> <span class="keyword">int</span> oldY = mScrollY;</span><br><span class="line">    <span class="keyword">final</span> <span class="keyword">int</span> range = getScrollRange();</span><br><span class="line">    <span class="keyword">final</span> <span class="keyword">int</span> overscrollMode = getOverScrollMode();</span><br><span class="line">    <span class="comment">//4.处理自己的滚动</span></span><br><span class="line">    <span class="keyword">if</span> (overScrollBy(<span class="number">0</span>, deltaY, <span class="number">0</span>, mScrollY, <span class="number">0</span>, range, <span class="number">0</span>, mOverscrollDistance, <span class="keyword">true</span>)</span><br><span class="line">            &amp;&amp; !hasNestedScrollingParent()) &#123;</span><br><span class="line">        mVelocityTracker.clear();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//5.再次发起嵌套滚动 </span></span><br><span class="line">    <span class="keyword">final</span> <span class="keyword">int</span> scrolledDeltaY = mScrollY - oldY;</span><br><span class="line">    <span class="keyword">final</span> <span class="keyword">int</span> unconsumedY = deltaY - scrolledDeltaY;</span><br><span class="line">    <span class="keyword">if</span> (dispatchNestedScroll(<span class="number">0</span>, scrolledDeltaY, <span class="number">0</span>, unconsumedY, mScrollOffset)) &#123;</span><br><span class="line">        mLastMotionY -= mScrollOffset[<span class="number">1</span>];</span><br><span class="line">        vtev.offsetLocation(<span class="number">0</span>, mScrollOffset[<span class="number">1</span>]);</span><br><span class="line">        mNestedYOffset += mScrollOffset[<span class="number">1</span>];</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (canOverscroll) &#123;</span><br><span class="line">        <span class="comment">//6.如果父控件没有消费，则处理覆盖滚动</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="覆盖滚动"><a href="#覆盖滚动" class="headerlink" title="覆盖滚动"></a>覆盖滚动</h4><p>覆盖滚动的触发条件是</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">final</span> <span class="keyword">int</span> overscrollMode = getOverScrollMode();</span><br><span class="line"><span class="keyword">boolean</span> canOverscroll = overscrollMode == OVER_SCROLL_ALWAYS ||</span><br><span class="line">        (overscrollMode == OVER_SCROLL_IF_CONTENT_SCROLLS &amp;&amp; range &gt; <span class="number">0</span>);</span><br></pre></td></tr></table></figure>
<p>这里给出的 getScrollRange 为</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Math.max(<span class="number">0</span>, child.getHeight() - (getHeight() - mPaddingBottom - mPaddingTop));</span><br></pre></td></tr></table></figure>
<p>覆盖滚动的效果是靠 EdgeGlow 实现的。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">final</span> <span class="keyword">int</span> pulledToY = getScrollY() + deltaY;</span><br><span class="line"><span class="keyword">if</span> (pulledToY &lt; <span class="number">0</span>) &#123;</span><br><span class="line">    mEdgeGlowTop.onPull((<span class="keyword">float</span>) deltaY / getHeight(), ev.getX() / getWidth());</span><br><span class="line">    <span class="keyword">if</span> (!mEdgeGlowBottom.isFinished()) &#123;</span><br><span class="line">        mEdgeGlowBottom.onRelease();</span><br><span class="line">    &#125;</span><br><span class="line">&#125; <span class="keyword">else</span> <span class="keyword">if</span> (pulledToY &gt; range) &#123;</span><br><span class="line">    mEdgeGlowBottom.onPull((<span class="keyword">float</span>) deltaY / getHeight(), <span class="number">1</span>.f - ev.getX() / getWidth());</span><br><span class="line">    <span class="keyword">if</span> (!mEdgeGlowTop.isFinished()) &#123;</span><br><span class="line">        mEdgeGlowTop.onRelease();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span> (!mEdgeGlowTop.isFinished() || !mEdgeGlowBottom.isFinished()) &#123;</span><br><span class="line">    postInvalidateOnAnimation();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="嵌套滑动的实践：-NestedScrollView"><a href="#嵌套滑动的实践：-NestedScrollView" class="headerlink" title="嵌套滑动的实践： NestedScrollView"></a>嵌套滑动的实践： NestedScrollView</h4><p>ScrollView 实际已经与 NestedScrollView 大致上一样了，它同时可以作为嵌套滑动的父容器和子控件。我们主要关注它作为父控件时是如何应答的:</p>
<p>1.能够相应的类型是垂直滑动</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">onStartNestedScroll</span><span class="params">(View child, View target, <span class="keyword">int</span> nestedScrollAxes)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> (nestedScrollAxes &amp; ViewCompat.SCROLL_AXIS_VERTICAL) != <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>而且自己作为子控件将事件继续向上分发</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onNestedScrollAccepted</span><span class="params">(View child, View target, <span class="keyword">int</span> nestedScrollAxes)</span> </span>&#123;</span><br><span class="line">    mNestedScrollAxes = axes;</span><br><span class="line">    startNestedScroll(ViewCompat.SCROLL_AXIS_VERTICAL);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>2.第一轮问答</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onNestedPreScroll</span><span class="params">(View target, <span class="keyword">int</span> dx, <span class="keyword">int</span> dy, <span class="keyword">int</span>[] consumed)</span> </span>&#123;</span><br><span class="line">    <span class="comment">//此时 consumed 为 null</span></span><br><span class="line">    mChildHelper.dispatchNestedPreScroll(dx, dy, consumed, <span class="keyword">null</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>从 onNestedPreScroll 方法的实现上看，当它作为父容器要响应嵌套滑动时，它会将事件转发给它的子控件。</p>
<p>3.第二轮问答</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onNestedScroll</span><span class="params">(View target, <span class="keyword">int</span> dxConsumed, <span class="keyword">int</span> dyConsumed, <span class="keyword">int</span> dxUnconsumed, <span class="keyword">int</span> dyUnconsumed)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">final</span> <span class="keyword">int</span> oldScrollY = getScrollY();</span><br><span class="line">    scrollBy(<span class="number">0</span>, dyUnconsumed);</span><br><span class="line">    <span class="keyword">final</span> <span class="keyword">int</span> myConsumed = getScrollY() - oldScrollY;</span><br><span class="line">    <span class="keyword">final</span> <span class="keyword">int</span> myUnconsumed = dyUnconsumed - myConsumed;</span><br><span class="line">    mChildHelper.dispatchNestedScroll(<span class="number">0</span>, myConsumed, <span class="number">0</span>, myUnconsumed, <span class="keyword">null</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><strong>注意在第二轮问答时 NestedScrollView 控件本身发生了滚动，距离为传入的参数 dyUnconsumed，这是发起者消费后的余量。</strong>消费距离实际就是 dyUnconsumed，而未消费距离为0。此后将这一数据向子控件继续分发。</p>

        
      
    </div>

    
    
    
      <footer class="post-footer">
          <div class="post-eof"></div>
        
      </footer>
  </div>
  
  
  
  </article>

    
        <article itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block home">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2017/05/29/android/系统/Broadcast/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="xiang">
      <meta itemprop="description" content="谨守而勿失，是谓反其真">
      <meta itemprop="image" content="/images/1.jpg">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="lxt">
    </span>
      <header class="post-header">
        <h1 class="post-title" itemprop="name headline">
            
            <a href="/2017/05/29/android/系统/Broadcast/" class="post-title-link" itemprop="url">Broadcast</a>
          
        </h1>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              
                
              

              <time title="创建时间：2017-05-29 17:56:36" itemprop="dateCreated datePublished" datetime="2017-05-29T17:56:36+08:00">2017-05-29</time>
            </span>
          
            

            
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="fa fa-calendar-check-o"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2019-09-18 12:47:47" itemprop="dateModified" datetime="2019-09-18T12:47:47+08:00">2019-09-18</time>
              </span>
            
          
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing"><a href="/categories/android/" itemprop="url" rel="index"><span itemprop="name">android</span></a></span>

                
                
                  ，
                
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing"><a href="/categories/android/系统/" itemprop="url" rel="index"><span itemprop="name">系统</span></a></span>

                
                
              
            </span>
          

          
          <br>
            <span class="post-meta-item" title="本文字数">
              <span class="post-meta-item-icon">
                <i class="fa fa-file-word-o"></i>
              </span>
              
                <span class="post-meta-item-text">本文字数：</span>
              
              <span>8.6k</span>
            </span>
          
            <span class="post-meta-item" title="阅读时长">
              <span class="post-meta-item-icon">
                <i class="fa fa-clock-o"></i>
              </span>
              
                <span class="post-meta-item-text">阅读时长 &asymp;</span>
              
              <span>8 分钟</span>
            </span>
          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h2 id="基本原理"><a href="#基本原理" class="headerlink" title="基本原理"></a>基本原理</h2><p>广播的使用包括<strong>注册</strong>和<strong>发送</strong>两步。<strong>注册广播</strong>又分为两种方式</p>
<ul>
<li>在代码中进行动态注册</li>
<li>在XML文件中进行静态注册。</li>
</ul>
<p>不管哪种方式都涉及两个类 BroadcastReceiver 与 IntentFilter。<strong>前者负责处理广播，后者负责匹配广播</strong>。</p>
<blockquote>
<p>因为广播易造成内存泄漏，一般在活动的<code>onResume</code>和<code>onPause</code>方法中<strong>成对的</strong>进行注册和销毁。</p>
</blockquote>
<p>2.<strong>发送广播</strong>本质上是一个后台操作，发送广播的类型包括</p>
<ul>
<li><code>sendBroadcast</code> 发送无序广播，异步执行，效率高，但存在隐患</li>
<li><code>sendOrderedBroadcast</code> 发送有序广播，在某个接收器执行的同时会阻塞其他的接收器</li>
</ul>
<blockquote>
<p>虽然执行广播的进程是一个优先级较高的前台进程，但<code>BroadcastReceiver</code> 对象的生命周期只在 <code>onReceive</code>方法的执行过程中，一旦执行完，对象将销毁。<strong>这一特性决定了如果在广播接收器内部执行异步操作，将无法返回。</strong></p>
</blockquote>
<h3 id="局部广播"><a href="#局部广播" class="headerlink" title="局部广播"></a>局部广播</h3><p><code>LocalBroadcastManager</code>局部广播不需要跨进程，并非使用<code>Binder</code>机制。</p>
<h3 id="粘性广播"><a href="#粘性广播" class="headerlink" title="粘性广播"></a>粘性广播</h3><p>粘性广播在21中被<code>deprecated</code> 了，使用粘性广播首先需要权限</p>
<figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">android.permission.BROADCAST_STICKYXML</span><br></pre></td></tr></table></figure>
<p>使用方法<code>sendStickyBroadcast</code>方法来发送粘性广播</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Intent intent = <span class="keyword">new</span> Intent(<span class="string">"receiver"</span>);</span><br><span class="line">intent.putExtra(<span class="string">"DATA"</span>,<span class="string">"receiver"</span>);</span><br><span class="line">sendStickyBroadcast(intent);</span><br></pre></td></tr></table></figure>
<p>它的行为和正常广播基本一致，在广播接收器取消注册后不会受理广播。唯一有区别的一点是<strong>广播接收器取消注册后，如果发送粘性广播，则Intent将被会缓存到系统中。</strong>这样<strong>再次注册广播接收器时，能从该方法返回值中获取先前的Intent即其中的数据。</strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Intent mIntentSticky = registerReceiver(receiver,filter);</span><br><span class="line">-------------------------</span><br><span class="line"><span class="comment">//s = "receiver"String s = mIntentSticky .getStringExtra("DATA");</span></span><br></pre></td></tr></table></figure>
<p>因此发送粘性广播即便不能被成功接受，也可以保存数据，可见粘性广播的好处是使得广播能够在<strong>注册周期之外感知数据变化</strong>，但损失的是<strong>安全性</strong>，这些数据可以被任意获取与修改。</p>
<h3 id="最佳实践"><a href="#最佳实践" class="headerlink" title="最佳实践"></a>最佳实践</h3><p>使用广播必须要手动注册接收机，可以优化的地方有两点</p>
<p>1.注册和解除配对出现，一般放在 onStart 和 onStop 方法中，其目的是防止内存泄漏。</p>
<p>2.视广播如何处理决定是否在注册时禁用(enable)，以避免无谓的耗电。</p>
<p>首先禁止广播</p>
<figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">receiver</span></span></span><br><span class="line"><span class="tag">    <span class="attr">android:name</span>=<span class="string">".MyReceiver"</span></span></span><br><span class="line"><span class="tag">    <span class="attr">android:enabled</span>=<span class="string">"false"</span></span></span><br><span class="line"><span class="tag">    <span class="attr">android:exported</span>=<span class="string">"true"</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">receiver</span>&gt;</span></span><br></pre></td></tr></table></figure>
<p>在必要时开启，并及时释放</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">PackageManager packageManager = getPackageManager();</span><br><span class="line">ComponentName componentName = <span class="keyword">new</span> ComponentName(<span class="keyword">this</span>, MyReceiver.class);</span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">onStart</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">super</span>.onStart();</span><br><span class="line">    registerReceiver(receiver, filter);</span><br><span class="line">    packageManager.setComponentEnabledSetting(componentName,</span><br><span class="line">            PackageManager.COMPONENT_ENABLED_STATE_ENABLED,</span><br><span class="line">            PackageManager.DONT_KILL_APP);</span><br><span class="line">&#125;</span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">onStop</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">super</span>.onStop();</span><br><span class="line">    unregisterReceiver(receiver);</span><br><span class="line">    packageManager.setComponentEnabledSetting(componentName,</span><br><span class="line">            PackageManager.COMPONENT_ENABLED_STATE_DISABLED,</span><br><span class="line">            PackageManager.DONT_KILL_APP);</span><br></pre></td></tr></table></figure>
<h2 id="广播注册原理"><a href="#广播注册原理" class="headerlink" title="广播注册原理"></a><strong>广播注册原理</strong></h2><p>在 Android 的广播机制中， ActivityManagerService 扮演着广播中心的角色，负责系统中所有广播的注册和发布操作，因此，Android应用程序注册广播接收器的过程就是<strong>把广播接收器注册到ActivityManagerService的过程</strong>。</p>
<p>广播注册实际由<code>ContextImpl</code>的如下方法执行(已作精简)</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> Intent <span class="title">registerReceiverInternal</span><span class="params">(BroadcastReceiver receiver, ..., Context context)</span> </span>&#123;</span><br><span class="line">    IIntentReceiver rd = <span class="keyword">new</span> LoadedApk.ReceiverDispatcher(receiver, context, scheduler, <span class="keyword">null</span>, <span class="keyword">true</span>).getIIntentReceiver();</span><br><span class="line">    <span class="keyword">return</span> ActivityManagerNative.getDefault().registerReceiver(...);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>该方法首先构建 IIntentReceiver 对象接口 ，这是一个<strong>单向</strong>的 Binder 对象，专门负责<strong>执行接收广播</strong>，定义如下</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">oneway <span class="class"><span class="keyword">interface</span> <span class="title">IIntentReceiver</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">performReceive</span><span class="params">(in Intent intent, <span class="keyword">int</span> resultCode, String data,in Bundle extras, <span class="keyword">boolean</span> ordered, <span class="keyword">boolean</span> sticky, <span class="keyword">int</span> sendingUser)</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>而后使用<code>ActivityManagerService</code>类在服务端进行真实的广播注册</p>
<hr>
<p>在研究AMS如何注册广播之前，先做些预备工作</p>
<p>1.<code>ActivityManagerService</code>维持着一个广播过滤器集合</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">HashMap&lt;IBinder, ReceiverList&gt; mRegisteredReceivers</span><br></pre></td></tr></table></figure>
<p>其中<code>key</code>为 IIntentReceivers 对象，而<code>Value</code>为 ReceiverList ，代表一个注册了若干个广播的广播接收机，定义如下</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">ReceiverList</span> <span class="keyword">extends</span> <span class="title">ArrayList</span>&lt;<span class="title">BroadcastFilter</span>&gt;</span>&#123;	</span><br><span class="line">    IIntentReceiver receiver;	</span><br><span class="line">    BroadcastRecord curBroadcast = <span class="keyword">null</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>可见 ReceiverList 是一个集合类，元素为<strong>广播过滤器</strong> BroadcastFilter 。该类是 IntentFilter 的子类。</p>
<p>2.<strong>IntentResolver</strong>类负责<strong>操作广播过滤器</strong>，其中有一个重要的方法是<strong>判断两个 IntentFilter 对象是否相等</strong>。其实现原理是是依次比较<code>Action</code>，<code>Category</code>以及<code>Data</code>是否相等，其中<code>Data</code>的比较又分为多个部分。</p>
<hr>
<p>AMS 中注册广播的方法如下</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> Intent <span class="title">registerReceiver</span><span class="params">(IIntentReceiver receiver, IntentFilter filter, String permission, <span class="keyword">int</span> userId)</span> </span>&#123; </span><br><span class="line">        <span class="comment">//1，收集粘性广播列表</span></span><br><span class="line">	<span class="comment">//2，获取匹配过滤器的所有粘性广播</span></span><br><span class="line">	<span class="comment">//3. 是否使用粘性广播	</span></span><br><span class="line">	Intent sticky = allSticky != <span class="keyword">null</span> ? allSticky.get(<span class="number">0</span>) : <span class="keyword">null</span>; </span><br><span class="line">	<span class="comment">//4，广播注册</span></span><br><span class="line">	<span class="keyword">synchronized</span> (<span class="keyword">this</span>) &#123;</span><br><span class="line">		ReceiverList rl = mRegisteredReceivers.get(receiver.asBinder()); </span><br><span class="line">            <span class="keyword">if</span> (rl == <span class="keyword">null</span>) &#123;</span><br><span class="line">                rl = <span class="keyword">new</span> ReceiverList(<span class="keyword">this</span>, callerApp, callingPid, callingUid,userId, receiver);</span><br><span class="line">				mRegisteredReceivers.put(receiver.asBinder(), rl);</span><br><span class="line">&#125; </span><br><span class="line">            BroadcastFilter bf = <span class="keyword">new</span> BroadcastFilter(filter, rl, callerPackage,permission, callingUid, userId);</span><br><span class="line">            rl.add(bf);</span><br><span class="line">	mReceiverResolver.addFilter(bf);		</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> sticky;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>注册广播的大部分代码是在处理粘性广播，对此只大略叙述</p>
<p>1.首先收集所有的粘性广播<br>2.而后收集能够经过过滤器的粘性广播集合<br>3.如果确实发送的是粘性广播，则返回代表最近的一条粘性广播的<code>Intent</code>。</p>
<p>广播注册的过程是同步的，实际步骤是</p>
<p>1.先从广播过滤器缓存集合中查询是否存在传入的广播接收器，如果没有，则创建 ReceiverList ，并将其存入缓存<br>2.根据参数 IntentFilter 创建过滤器 BroadcastFilter ，并添加到系统解析器 mReceiverResolver中。</p>
<blockquote>
<p><strong>总结</strong>：广播有两个要素<code>BroadcastReceiver</code>与<code>IntentFilter</code>。注册广播时前者生成<code>Binder</code>对象，定义了如何处理广播；后者生成一个新的过滤器。系统内存维持着一个字典集合，不考虑粘性广播，则广播的注册过程是将二者写入这个字典集合中去。</p>
</blockquote>
<h2 id="WakefulBroadcastReceiver"><a href="#WakefulBroadcastReceiver" class="headerlink" title="WakefulBroadcastReceiver"></a>WakefulBroadcastReceiver</h2><h3 id="唤醒锁"><a href="#唤醒锁" class="headerlink" title="唤醒锁"></a><strong>唤醒锁</strong></h3><p>在认识<code>WakefulBroadcastReceiver</code>广播之前先要了解唤醒锁。</p>
<p>安卓使用<code>PowerManager</code>服务来<strong>控制设备电源状态</strong>，设备的接口定义在<code>IPowerManager</code>接口中，可执行的方法如下</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">goToSleep</span><span class="params">(<span class="keyword">long</span> time)</span></span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">wakeUp</span><span class="params">(<span class="keyword">long</span> time)</span> </span></span><br><span class="line"><span class="function"><span class="keyword">boolean</span> <span class="title">isScreenOn</span><span class="params">()</span> </span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">reboot</span><span class="params">(String reason)</span> </span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">shutdown</span><span class="params">(<span class="keyword">boolean</span> confirm, <span class="keyword">boolean</span> wait)</span></span></span><br></pre></td></tr></table></figure>
<p>其中最重要的方法是<strong>创建唤醒锁</strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">WakeLock <span class="title">newWakeLock</span><span class="params">(<span class="keyword">int</span> levelAndFlags, String tag)</span></span></span><br></pre></td></tr></table></figure>
<p><code>WakeLock</code>类即代表唤醒锁，是<code>PowerManager</code>的内部类，<strong>保持该锁会使得设备保持开启状态，无法进入休眠</strong>，必须等待锁的释放。</p>
<p>在上述方法中参数<code>levelAndFlags</code>表示锁的级别与类型，<strong>实际使用中应尽量不使用以及使用最低级别的锁</strong>。</p>
<ul>
<li><code>FULL_WAKE_LOCK</code></li>
<li><code>PARTIAL_WAKE_LOCK</code> 该类型的所会使<strong>CPU保持运行，无视屏幕是否熄灭</strong>，即使按下电源键设备也不能进入休眠。</li>
<li><code>SCREEN_DIM_WAKE_LOCK</code> 屏幕将一直保持较暗的亮度，但不会熄灭。<strong>按下电源键锁将释放</strong>。</li>
<li><code>SCREEN_BRIGHT_WAKE_LOCK</code> 同上</li>
</ul>
<p>在创建唤醒锁之后使用如下方法启用</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">acquire()</span><br></pre></td></tr></table></figure>
<p>释放唤醒锁</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">release()</span><br></pre></td></tr></table></figure>
<blockquote>
<p>使用唤醒锁可以保持屏幕长亮，但更轻量级的做法是对窗口对象使用属性android.view.WindowManager.LayoutParams#FLAG_KEEP_SCREEN_ON。</p>
</blockquote>
<h3 id="WifiLock"><a href="#WifiLock" class="headerlink" title="WifiLock"></a><strong>WifiLock</strong></h3><p>与<code>WakeLock</code>类似的还有<code>WifiLock</code>，该锁保持<code>Wi-Fi</code>射频模块开启。正常模式下<code>Wi-Fi</code>射频模块会自动关闭以节省电量，在下载大文件时可以使用该锁。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">WifiLock <span class="title">createWifiLock</span><span class="params">(<span class="keyword">int</span> lockType, String tag)</span></span></span><br></pre></td></tr></table></figure>
<p>lockType 的可能取值为</p>
<ul>
<li><code>WIFI_MODE_FULL_HIGH_PERF</code> 表示高性能连接，低丢包率，适合传输语音</li>
<li><code>WIFI_MODE_FULL</code></li>
<li><code>WIFI_MODE_SCAN_ONLY</code></li>
</ul>
<h3 id="WakefulBroadcastReceiver-1"><a href="#WakefulBroadcastReceiver-1" class="headerlink" title="WakefulBroadcastReceiver"></a><strong>WakefulBroadcastReceiver</strong></h3><p><strong>WakefulBroadcastReceiver</strong>是一种利用唤醒锁的特殊广播，其目的是确保广播发射到启动服务的过程中，设备始终处于唤醒状态，不会因为进入休眠状态而中止启动服务。类内部保持了唤醒锁集合</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">SparseArray&lt;PowerManager.WakeLock&gt; mActiveWakeLocks;</span><br></pre></td></tr></table></figure>
<p>该广播提供了一个工具方法<code>startWakefulService</code>来启动服务，其实现如下</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> ComponentName <span class="title">startWakefulService</span><span class="params">(Context context, Intent intent)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">synchronized</span> (mActiveWakeLocks) &#123;</span><br><span class="line">        <span class="keyword">int</span> id = mNextId;</span><br><span class="line">        mNextId++;</span><br><span class="line">        <span class="keyword">if</span> (mNextId &lt;= <span class="number">0</span>) &#123;</span><br><span class="line">            mNextId = <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        intent.putExtra(EXTRA_WAKE_LOCK_ID, id);</span><br><span class="line">        ComponentName comp = context.startService(intent);</span><br><span class="line">        PowerManager pm = (PowerManager)context.getSystemService(Context.POWER_SERVICE);</span><br><span class="line">        PowerManager.WakeLock wl = pm.newWakeLock(PowerManager.PARTIAL_WAKE_LOCK,</span><br><span class="line">                <span class="string">"wake:"</span> + comp.flattenToShortString());</span><br><span class="line">        wl.setReferenceCounted(<span class="keyword">false</span>);</span><br><span class="line">        wl.acquire(<span class="number">60</span>*<span class="number">1000</span>);</span><br><span class="line">        mActiveWakeLocks.put(id, wl);</span><br><span class="line">        <span class="keyword">return</span> comp;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><strong>可见在启动服务的时候，将创建一个唤醒锁，并获得60s的唤醒时间，在此期间设备保持唤醒状态。</strong></p>
<p><strong>该广播还提供了completeWakefulIntent方法以便在服务中释放唤醒锁</strong>，其实现如下</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">boolean</span> <span class="title">completeWakefulIntent</span><span class="params">(Intent intent)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">final</span> <span class="keyword">int</span> id = intent.getIntExtra(EXTRA_WAKE_LOCK_ID, <span class="number">0</span>);</span><br><span class="line">    PowerManager.WakeLock wl = mActiveWakeLocks.get(id);</span><br><span class="line">    wl.release();</span><br><span class="line">    mActiveWakeLocks.remove(id);</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="小部件-AppWidgetProvider"><a href="#小部件-AppWidgetProvider" class="headerlink" title="小部件(AppWidgetProvider)"></a>小部件(AppWidgetProvider)</h3><p>小部件是 APP 的简易入口，<strong>宿主APP</strong>与小部件处于不同的进程中，宿主通过广播(AppWidgetProvider)来更新小部件，小部件通过 PedentIndent 与宿主交互。</p>
<p>继承 AppWidgetProvider 类创建一个广播，并注册到清单文件</p>
<figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">receiver</span> <span class="attr">android:name</span>=<span class="string">"ExampleAppWidgetProvider"</span> &gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">intent-filter</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">action</span> <span class="attr">android:name</span>=<span class="string">"android.appwidget.action.APPWIDGET_UPDATE"</span> /&gt;</span> </span><br><span class="line">    <span class="tag">&lt;/<span class="name">intent-filter</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">meta-data</span> <span class="attr">android:name</span>=<span class="string">"android.appwidget.provider"</span></span></span><br><span class="line"><span class="tag">               <span class="attr">android:resource</span>=<span class="string">"@xml/example_appwidget_info"</span> /&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">receiver</span>&gt;</span></span><br></pre></td></tr></table></figure>
<p>有两点要注意</p>
<ul>
<li>必须制定特殊的 action，系统由此判定是小部件</li>
<li>必须提供小部件的配置信息</li>
</ul>
<figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">appwidget-provider</span> <span class="attr">xmlns:android</span>=<span class="string">"http://schemas.android.com/apk/res/android"</span></span></span><br><span class="line"><span class="tag">    <span class="attr">android:minWidth</span>=<span class="string">"40dp"</span></span></span><br><span class="line"><span class="tag">    <span class="attr">android:minHeight</span>=<span class="string">"40dp"</span></span></span><br><span class="line"><span class="tag">    <span class="attr">android:updatePeriodMillis</span>=<span class="string">"86400000"</span></span></span><br><span class="line"><span class="tag">    <span class="attr">android:previewImage</span>=<span class="string">"@drawable/preview"</span> //</span></span><br><span class="line"><span class="tag">    <span class="attr">android:initialLayout</span>=<span class="string">"@layout/example_appwidget"</span></span></span><br><span class="line"><span class="tag">    <span class="attr">android:configure</span>=<span class="string">"com.example.android.ExampleAppWidgetConfigure"</span> </span></span><br><span class="line"><span class="tag">    <span class="attr">android:resizeMode</span>=<span class="string">"horizontal|vertical"</span></span></span><br><span class="line"><span class="tag">    <span class="attr">android:widgetCategory</span>=<span class="string">"home_screen|keyguard"</span></span></span><br><span class="line"><span class="tag">    <span class="attr">android:initialKeyguardLayout</span>=<span class="string">"@layout/example_keyguard"</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">appwidget-provider</span>&gt;</span></span><br></pre></td></tr></table></figure>
<p>小部件信息的必要配置有4个，但<strong>小部件布局能够支持的布局和控件内是有限的，且要注意小部件的边距问题。</strong></p>
<p>到此为止 ，小部件就已经建立起来了，但 没有任何功能。</p>
<p>AppWidgetProvider 类实际就是普通广播，仅仅对5个广播相关的事件进行了转发处理</p>
<ul>
<li>ACTION_APPWIDGET_UPDATE： 小部件更新</li>
<li>ACTION_APPWIDGET_DELETED：删除每一个小部件</li>
<li>ACTION_APPWIDGET_ENABLED ：发生在添加第一个小部件时</li>
<li>ACTION_APPWIDGET_DISABLED：发生在移除最后一个小部件时</li>
<li>ACTION_APPWIDGET_OPTIONS_CHANGED 小部件配置改变</li>
</ul>
<p><strong>更新小部件需要利用 AppWidgetManager 类，更具体的内容是操作 RemoteViews</strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onUpdate</span><span class="params">(Context context, AppWidgetManager appWidgetManager, <span class="keyword">int</span>[] appWidgetIds)</span> </span>&#123;</span><br><span class="line">    RemoteViews remoteViews = <span class="keyword">new</span> RemoteViews(context.getPackageName(), R.layout.update_main);    </span><br><span class="line">    remoteViews.setImageViewResource(R.id.image, srcs[index]);</span><br><span class="line">    remoteViews.setOnClickPendingIntent(R.id.image, PendingIntent.getBroadcast(context, <span class="number">1</span>, <span class="keyword">new</span> Intent(<span class="string">"com.mowang.click"</span>), PendingIntent.FLAG_UPDATE_CURRENT));</span><br><span class="line">    ComponentName componentName = <span class="keyword">new</span> ComponentName(context, <span class="keyword">this</span>.getClass());</span><br><span class="line">    appWidgetManager.updateAppWidget(componentName , remoteViews);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

        
      
    </div>

    
    
    
      <footer class="post-footer">
          <div class="post-eof"></div>
        
      </footer>
  </div>
  
  
  
  </article>

    
        <article itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block home">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2017/05/24/android/系统/Window/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="xiang">
      <meta itemprop="description" content="谨守而勿失，是谓反其真">
      <meta itemprop="image" content="/images/1.jpg">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="lxt">
    </span>
      <header class="post-header">
        <h1 class="post-title" itemprop="name headline">
            
            <a href="/2017/05/24/android/系统/Window/" class="post-title-link" itemprop="url">Window</a>
          
        </h1>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              
                
              

              <time title="创建时间：2017-05-24 11:56:26" itemprop="dateCreated datePublished" datetime="2017-05-24T11:56:26+08:00">2017-05-24</time>
            </span>
          
            

            
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="fa fa-calendar-check-o"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2019-09-18 12:35:54" itemprop="dateModified" datetime="2019-09-18T12:35:54+08:00">2019-09-18</time>
              </span>
            
          
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing"><a href="/categories/android/" itemprop="url" rel="index"><span itemprop="name">android</span></a></span>

                
                
                  ，
                
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing"><a href="/categories/android/系统/" itemprop="url" rel="index"><span itemprop="name">系统</span></a></span>

                
                
              
            </span>
          

          
          <br>
            <span class="post-meta-item" title="本文字数">
              <span class="post-meta-item-icon">
                <i class="fa fa-file-word-o"></i>
              </span>
              
                <span class="post-meta-item-text">本文字数：</span>
              
              <span>15k</span>
            </span>
          
            <span class="post-meta-item" title="阅读时长">
              <span class="post-meta-item-icon">
                <i class="fa fa-clock-o"></i>
              </span>
              
                <span class="post-meta-item-text">阅读时长 &asymp;</span>
              
              <span>14 分钟</span>
            </span>
          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h2 id="基本原理"><a href="#基本原理" class="headerlink" title="基本原理"></a>基本原理</h2><p>Window 的实现类是 PhoneWindow，它是视图系统的核心，也是一切事件的起源。</p>
<p>Window 系统是通过 IPC 机制实现的，使用 WindowManager 来添加和移除控件，其实现类是 WindowManagerGlobal，其内部维持着以下四个集合</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">ArrayList&lt;View&gt; mViews = <span class="keyword">new</span> ArrayList&lt;View&gt;(); <span class="comment">// Window上存在的View集合</span></span><br><span class="line">ArrayList&lt;ViewRootImpl&gt; mRoots = <span class="keyword">new</span> ArrayList&lt;ViewRootImpl&gt;();</span><br><span class="line">ArrayList&lt;WindowManager.LayoutParams&gt; mParams;</span><br><span class="line">ArraySet&lt;View&gt; mDyingViews = <span class="keyword">new</span> ArraySet&lt;View&gt;();</span><br></pre></td></tr></table></figure>
<p><strong>在 Window 上添加 View 的逻辑就是更新这几个集合</strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">addView</span><span class="params">(View view, ViewGroup.LayoutParams params,  Display display, Window parentWindow)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">final</span> WindowManager.LayoutParams wparams = (WindowManager.LayoutParams) params;</span><br><span class="line">    ViewRootImpl root;</span><br><span class="line">    View panelParentView = <span class="keyword">null</span>;</span><br><span class="line">    <span class="keyword">synchronized</span> (mLock) &#123;</span><br><span class="line">        root = <span class="keyword">new</span> ViewRootImpl(view.getContext(), display);</span><br><span class="line">        view.setLayoutParams(wparams);</span><br><span class="line">        mViews.add(view);</span><br><span class="line">        mRoots.add(root);</span><br><span class="line">        mParams.add(wparams);</span><br><span class="line">    &#125;</span><br><span class="line">    root.setView(view, wparams, panelParentView);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>实际的工作交给了 ViewRootImpl。</p>
<h3 id="与-Activity-的关系"><a href="#与-Activity-的关系" class="headerlink" title="与 Activity 的关系"></a>与 Activity 的关系</h3><p>Window 与 Activity 实际是两个独立的系统，只不过二者有交集，<strong>Window 需要在 Activity 启动时展示其设置的布局而已</strong>。</p>
<p>在启动活动前，要进行 WindowManager 的初始化</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">WindowManagerGlobal.initialize();</span><br><span class="line">Activity a = performLaunchActivity(r, customIntent);</span><br></pre></td></tr></table></figure>
<p><strong>使用反射创建 Activity 对象后，将执行 attach 方法，此时将创建 PhoneWindow 并配置 WindowManager</strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">final</span> <span class="keyword">void</span> <span class="title">attach</span><span class="params">(Context context, ActivityThread aThread ，...)</span> </span>&#123;</span><br><span class="line">    attachBaseContext(context); <span class="comment">//attach 回调方法</span></span><br><span class="line">    mFragments.attachHost(<span class="keyword">null</span>);</span><br><span class="line">    mWindow = <span class="keyword">new</span> PhoneWindow(<span class="keyword">this</span>); <span class="comment">//创建 PhoneWindow 并配置 WindowManager</span></span><br><span class="line">    mWindow.setWindowManager(</span><br><span class="line">            (WindowManager)context.getSystemService(Context.WINDOW_SERVICE),</span><br><span class="line">            mToken, mComponent.flattenToString(),</span><br><span class="line">            (info.flags &amp; ActivityInfo.FLAG_HARDWARE_ACCELERATED) != <span class="number">0</span>);</span><br><span class="line">    mWindowManager = mWindow.getWindowManager();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><strong>Activity 的onCreate方法也在这一步进行，到此 Window 中的 decorView 将被设置好，只是没有添加到 Window 上去。</strong></p>
<p>而后是显示Activity 的 handleResumeActivity 方法，这里才利用 WindowManager 将 DecorView 添加到Window上去，参数全部由WindowManager.LayoutParams 决定。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">View decor = r.window.getDecorView();</span><br><span class="line">decor.setVisibility(View.INVISIBLE);</span><br><span class="line">ViewManager wm = a.getWindowManager();</span><br><span class="line">WindowManager.LayoutParams l = r.window.getAttributes();</span><br><span class="line">wm.addView(decor, l);</span><br></pre></td></tr></table></figure>
<h3 id="DecorView-和-ContentParent"><a href="#DecorView-和-ContentParent" class="headerlink" title="DecorView 和 ContentParent"></a>DecorView 和 ContentParent</h3><p>PhoneWindow 中会创建 DecorView 和 ContentParent 两个控件</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">installDecor</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (mDecor == <span class="keyword">null</span>) &#123;</span><br><span class="line">        mDecor = <span class="keyword">new</span> DecorView(getContext(), -<span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (mContentParent == <span class="keyword">null</span>) &#123;</span><br><span class="line">        mContentParent = generateLayout(mDecor);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><strong>mContentParent 的创建较为复杂，它会根据theme配置有所不同。</strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">protected</span> ViewGroup <span class="title">generateLayout</span><span class="params">(DecorView decor)</span> </span>&#123;</span><br><span class="line">    TypedArray a = getWindowStyle();</span><br><span class="line">    <span class="comment">//1.windowIsFloating决定是否采用floating，如果是则布局以WRAP_CONTENT计算，并清除其它flag</span></span><br><span class="line">    mIsFloating = a.getBoolean(R.styleable.Window_windowIsFloating, <span class="keyword">false</span>);</span><br><span class="line">    <span class="keyword">int</span> flagsToUpdate = (FLAG_LAYOUT_IN_SCREEN|FLAG_LAYOUT_INSET_DECOR)</span><br><span class="line">            &amp; (~getForcedWindowFlags());</span><br><span class="line">    <span class="keyword">if</span> (mIsFloating) &#123;</span><br><span class="line">        setLayout(WRAP_CONTENT, WRAP_CONTENT);</span><br><span class="line">        setFlags(<span class="number">0</span>, flagsToUpdate);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        setFlags(FLAG_LAYOUT_IN_SCREEN|FLAG_LAYOUT_INSET_DECOR, flagsToUpdate);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//2. Feature 参数决定了加载哪种系统布局，windowNoTitle和windowActionBar是互斥的</span></span><br><span class="line">    <span class="keyword">if</span> (a.getBoolean(R.styleable.Window_windowNoTitle, <span class="keyword">false</span>)) &#123;</span><br><span class="line">        requestFeature(FEATURE_NO_TITLE);</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (a.getBoolean(R.styleable.Window_windowActionBar, <span class="keyword">false</span>)) &#123;</span><br><span class="line">        requestFeature(FEATURE_ACTION_BAR);</span><br><span class="line">    &#125; </span><br><span class="line">    <span class="comment">// 比较特殊的 Feature 参数是FEATURE_CONTENT_TRANSITIONS和FEATURE_ACTIVITY_TRANSITIONS，它采用 Transition 动画</span></span><br><span class="line">    </span><br><span class="line">    <span class="comment">//3. Flag 参数决定了窗口类型，如全屏类型和TRANSLUCENT_STATUS</span></span><br><span class="line">    <span class="keyword">if</span> (a.getBoolean(R.styleable.Window_windowFullscreen, <span class="keyword">false</span>)) &#123;</span><br><span class="line">        setFlags(FLAG_FULLSCREEN, FLAG_FULLSCREEN &amp; (~getForcedWindowFlags()));</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (a.getBoolean(R.styleable.Window_windowTranslucentStatus,</span><br><span class="line">            <span class="keyword">false</span>)) &#123;</span><br><span class="line">        setFlags(FLAG_TRANSLUCENT_STATUS, ...);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//特殊的 flag 包括 windowDrawsSystemBarBackgrounds，必须配合statusBarColor才能生效</span></span><br><span class="line">    <span class="comment">// backgroundDimEnabled 背景是否模糊，设置FLAG_DIM_BEHIND，配合backgroundDimAmount生效</span></span><br><span class="line">    WindowManager.LayoutParams params = getAttributes();</span><br><span class="line">    <span class="comment">//根据不同的 feature 获得不同的布局资源，并加载到 window decor.</span></span><br><span class="line">    <span class="keyword">int</span> layoutResource = R.layout.screen_simple;</span><br><span class="line">    View in = mLayoutInflater.inflate(layoutResource, <span class="keyword">null</span>);</span><br><span class="line">    decor.addView(in, <span class="keyword">new</span> ViewGroup.LayoutParams(MATCH_PARENT, MATCH_PARENT));</span><br><span class="line">    mContentRoot = (ViewGroup) in;</span><br><span class="line">    <span class="comment">//返回ID为 ID_ANDROID_CONTENT 的内容控件</span></span><br><span class="line">    ViewGroup contentParent = (ViewGroup)findViewById(ID_ANDROID_CONTENT);</span><br><span class="line">    <span class="keyword">if</span> (contentParent == <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> RuntimeException(<span class="string">"Window couldn't find content container view"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> contentParent;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>到此为止内容控件只是一个占位控件，如在 R.layout.screen_simple 中</p>
<figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">LinearLayout</span> <span class="attr">xmlns:android</span>=<span class="string">"http://schemas.android.com/apk/res/android"</span></span></span><br><span class="line"><span class="tag">    <span class="attr">android:layout_width</span>=<span class="string">"match_parent"</span></span></span><br><span class="line"><span class="tag">    <span class="attr">android:layout_height</span>=<span class="string">"match_parent"</span></span></span><br><span class="line"><span class="tag">    <span class="attr">android:fitsSystemWindows</span>=<span class="string">"true"</span></span></span><br><span class="line"><span class="tag">    <span class="attr">android:orientation</span>=<span class="string">"vertical"</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">ViewStub</span> <span class="attr">android:id</span>=<span class="string">"@+id/action_mode_bar_stub"</span></span></span><br><span class="line"><span class="tag">              <span class="attr">android:inflatedId</span>=<span class="string">"@+id/action_mode_bar"</span></span></span><br><span class="line"><span class="tag">              <span class="attr">android:layout</span>=<span class="string">"@layout/action_mode_bar"</span></span></span><br><span class="line"><span class="tag">              <span class="attr">android:layout_width</span>=<span class="string">"match_parent"</span></span></span><br><span class="line"><span class="tag">              <span class="attr">android:layout_height</span>=<span class="string">"wrap_content"</span></span></span><br><span class="line"><span class="tag">              <span class="attr">android:theme</span>=<span class="string">"?attr/actionBarTheme"</span> /&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">FrameLayout</span></span></span><br><span class="line"><span class="tag">         <span class="attr">android:id</span>=<span class="string">"@android:id/content"</span></span></span><br><span class="line"><span class="tag">         <span class="attr">android:layout_width</span>=<span class="string">"match_parent"</span></span></span><br><span class="line"><span class="tag">         <span class="attr">android:layout_height</span>=<span class="string">"match_parent"</span></span></span><br><span class="line"><span class="tag">         <span class="attr">android:foregroundInsidePadding</span>=<span class="string">"false"</span></span></span><br><span class="line"><span class="tag">         <span class="attr">android:foregroundGravity</span>=<span class="string">"fill_horizontal|top"</span></span></span><br><span class="line"><span class="tag">         <span class="attr">android:foreground</span>=<span class="string">"?android:attr/windowContentOverlay"</span> /&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">LinearLayout</span>&gt;</span></span><br></pre></td></tr></table></figure>
<p>当活动启动时最终调用 setContentView 方法时将替换这个内容布局，这里将提供的布局加载到 @android:id/content 中去，并处理了设置 FEATURE_CONTENT_TRANSITIONS 的情况。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setContentView</span><span class="params">(<span class="keyword">int</span> layoutResID)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (mContentParent == <span class="keyword">null</span>) &#123;</span><br><span class="line">        installDecor();</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (!hasFeature(FEATURE_CONTENT_TRANSITIONS)) &#123;</span><br><span class="line">        mContentParent.removeAllViews();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (hasFeature(FEATURE_CONTENT_TRANSITIONS)) &#123;</span><br><span class="line">        <span class="keyword">final</span> Scene newScene = Scene.getSceneForLayout(mContentParent, layoutResID,</span><br><span class="line">                getContext());</span><br><span class="line">        transitionTo(newScene);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        mLayoutInflater.inflate(layoutResID, mContentParent);</span><br><span class="line">    &#125;</span><br><span class="line">    mContentParent.requestApplyInsets(); <span class="comment">//应用 Inset</span></span><br><span class="line">    <span class="keyword">final</span> Callback cb = getCallback();</span><br><span class="line">    <span class="keyword">if</span> (cb != <span class="keyword">null</span> &amp;&amp; !isDestroyed()) &#123;</span><br><span class="line">        cb.onContentChanged();           <span class="comment">//内容回调</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="WindowManager-LayoutParams"><a href="#WindowManager-LayoutParams" class="headerlink" title="WindowManager.LayoutParams"></a>WindowManager.LayoutParams</h3><p>对Window窗口的改变都是通过 WindowManager.LayoutParams 参数来实现的，最突出了莫过于 WindowInset 了。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> WindowInsets <span class="title">onApplyWindowInsets</span><span class="params">(WindowInsets insets)</span> </span>&#123;</span><br><span class="line">    mFrameOffsets.set(insets.getSystemWindowInsets());</span><br><span class="line">    insets = updateColorViews(insets, <span class="keyword">true</span> <span class="comment">/* animate */</span>);</span><br><span class="line">    insets = updateStatusGuard(insets);</span><br><span class="line">    updateNavigationGuard(insets);</span><br><span class="line">    <span class="keyword">return</span> insets;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>updateColorViews 方法的作用主要是处理横竖屏情况下的 WindowInsets ，并通过更新 statusBar 和 navigationBar 的布局参数来处理 WindowInsets事件。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> WindowInsets <span class="title">updateColorViews</span><span class="params">(WindowInsets insets, <span class="keyword">boolean</span> animate)</span> </span>&#123;</span><br><span class="line">    WindowManager.LayoutParams attrs = getAttributes();</span><br><span class="line">    <span class="keyword">int</span> sysUiVisibility = attrs.systemUiVisibility | getWindowSystemUiVisibility();</span><br><span class="line">    <span class="keyword">boolean</span> disallowAnimate = (mLastWindowFlags ^ attrs.flags)</span><br><span class="line">                    &amp; FLAG_DRAWS_SYSTEM_BAR_BACKGROUNDS != <span class="number">0</span>;</span><br><span class="line">    mLastWindowFlags = attrs.flags;</span><br><span class="line">    mLastTopInset = Math.min(insets.getStableInsetTop(),</span><br><span class="line">                        insets.getSystemWindowInsetTop());</span><br><span class="line">    mLastBottomInset = Math.min(insets.getStableInsetBottom(),</span><br><span class="line">                        insets.getSystemWindowInsetBottom());</span><br><span class="line">    mLastRightInset = Math.min(insets.getStableInsetRight(),</span><br><span class="line">                        insets.getSystemWindowInsetRight());</span><br><span class="line">    <span class="keyword">boolean</span> navBarToRightEdge = mLastBottomInset == <span class="number">0</span> &amp;&amp; mLastRightInset &gt; <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">int</span> navBarSize = navBarToRightEdge ? mLastRightInset : mLastBottomInset;</span><br><span class="line">    updateColorViewInt(mNavigationColorViewState, sysUiVisibility, mNavigationBarColor, navBarSize, navBarToRightEdge, <span class="number">0</span>, animate &amp;&amp; !disallowAnimate);</span><br><span class="line">      </span><br><span class="line">    <span class="keyword">boolean</span> statusBarNeedsRightInset = navBarToRightEdge</span><br><span class="line">                    &amp;&amp; mNavigationColorViewState.present;</span><br><span class="line">    <span class="keyword">int</span> statusBarRightInset = statusBarNeedsRightInset ? mLastRightInset : <span class="number">0</span>;</span><br><span class="line">    updateColorViewInt(mStatusColorViewState, sysUiVisibility, mStatusBarColor,</span><br><span class="line">                    mLastTopInset, <span class="keyword">false</span>, statusBarRightInset,</span><br><span class="line">                    animate &amp;&amp; !disallowAnimate);</span><br><span class="line">    <span class="keyword">return</span> insets;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>默认情况下 ColorViewState 配置了一个参数 systemUiHideFlag， 取值为 SYSTEM_UI_FLAG_FULLSCREEN，如果设置为改制，更新方法 updateColorViewInt 无效。</p>
<h2 id="与-Dialog-的关系"><a href="#与-Dialog-的关系" class="headerlink" title="与 Dialog 的关系"></a>与 Dialog 的关系</h2><p>Dialog 的构造方法如下</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">Dialog(<span class="meta">@NonNull</span> Context context, <span class="meta">@StyleRes</span> <span class="keyword">int</span> themeResId) &#123; </span><br><span class="line">    <span class="comment">//1.从配置文件中虚招主题，并构建 ContextThemeWrapper</span></span><br><span class="line">    TypedValue outValue = <span class="keyword">new</span> TypedValue();</span><br><span class="line">    context.getTheme().resolveAttribute(R.attr.dialogTheme, outValue, <span class="keyword">true</span>);</span><br><span class="line">    themeResId = outValue.resourceId;</span><br><span class="line">    mContext = <span class="keyword">new</span> ContextThemeWrapper(context, themeResId);</span><br><span class="line">    mWindowManager = (WindowManager) context.getSystemService(Context.WINDOW_SERVICE);</span><br><span class="line">    <span class="comment">//2.创建 PhoneWindow 对象并居中</span></span><br><span class="line">    <span class="keyword">final</span> Window w = <span class="keyword">new</span> PhoneWindow(mContext);</span><br><span class="line">    w.setGravity(Gravity.CENTER);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这里明白的显示了一个 Dialog 就是一个 Window，显示什么内容也遵循 Window 的规律，使用 setContentView 来添加自定义布局。</p>
<p><strong>至于显示则是利用 WindowManager 将准备好的 DecorView 添加到 Window 上去。</strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">show</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    mDecor = mWindow.getDecorView();</span><br><span class="line">    mWindowManager.addView(mDecor, l);</span><br><span class="line">    mShowing = <span class="keyword">true</span>;</span><br><span class="line">    sendShowMessage();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><strong>同理 hide() 方法实际就是隐藏 DecorView，dismiss 方法就是使用 WindowManager 移除 DecorView。</strong></p>
<p>Dialog 的若干子类不过是配置它的布局而已，此外 Dilog 没有生命周期。</p>
<h2 id="状态栏染色"><a href="#状态栏染色" class="headerlink" title="状态栏染色"></a>状态栏染色</h2><p>我们已经知道状态栏的染色是通过添加View来完成的，其必须满足条件</p>
<figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">item</span> <span class="attr">name</span>=<span class="string">"android:windowDrawsSystemBarBackgrounds"</span>&gt;</span>true<span class="tag">&lt;/<span class="name">item</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">item</span> <span class="attr">name</span>=<span class="string">"android:windowTranslucentStatus"</span>&gt;</span>false<span class="tag">&lt;/<span class="name">item</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">item</span> <span class="attr">name</span>=<span class="string">"android:statusBarColor"</span>&gt;</span>#FF786312<span class="tag">&lt;/<span class="name">item</span>&gt;</span> //非必须</span><br></pre></td></tr></table></figure>
<p>动态染色可以采用如下办法</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">getWindow().setStatusBarColor(Color.MAGENTA);</span><br></pre></td></tr></table></figure>
<p>实际上这个 View 是这样定义的</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">final</span> ColorViewState mStatusColorViewState = <span class="keyword">new</span> ColorViewState(</span><br><span class="line">            SYSTEM_UI_FLAG_FULLSCREEN, FLAG_TRANSLUCENT_STATUS,</span><br><span class="line">            Gravity.TOP,</span><br><span class="line">            Gravity.LEFT,</span><br><span class="line">            STATUS_BAR_BACKGROUND_TRANSITION_NAME,</span><br><span class="line">            com.android.internal.R.id.statusBarBackground, <span class="comment">//id</span></span><br><span class="line">            FLAG_FULLSCREEN);</span><br></pre></td></tr></table></figure>
<p>我们也完全可以这样做</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">View view = findViewById(android.R.id.statusBarBackground);<span class="comment">//获取 StatusColorView</span></span><br><span class="line">view.setBackgroundColor(Color.YELLOW);</span><br></pre></td></tr></table></figure>
<p>如果播放一个动画，就能完全看清楚这个 View</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">v.animate().setDuration(<span class="number">2000</span>).setInterpolator(<span class="keyword">new</span> CycleInterpolator(<span class="number">0.5f</span>)).translationY(<span class="number">200</span>).start();</span><br></pre></td></tr></table></figure>
<p>这一过程的实现如下</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">* Update a color view</span></span><br><span class="line"><span class="comment">*</span></span><br><span class="line"><span class="comment">* <span class="doctag">@param</span> state the color view to update.</span></span><br><span class="line"><span class="comment">* <span class="doctag">@param</span> sysUiVis the current systemUiVisibility to apply.</span></span><br><span class="line"><span class="comment">* <span class="doctag">@param</span> color the current color to apply.</span></span><br><span class="line"><span class="comment">* <span class="doctag">@param</span> size the current size in the non-parent-matching dimension.</span></span><br><span class="line"><span class="comment">* <span class="doctag">@param</span> verticalBar if true view is attached to a vertical edge, otherwise to a</span></span><br><span class="line"><span class="comment">*                    horizontal edge,</span></span><br><span class="line"><span class="comment">* <span class="doctag">@param</span> rightMargin rightMargin for the color view.</span></span><br><span class="line"><span class="comment">* <span class="doctag">@param</span> animate if true, the change will be animated.</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">updateColorViewInt</span><span class="params">(<span class="keyword">final</span> ColorViewState state, <span class="keyword">int</span> sysUiVis, <span class="keyword">int</span> color,</span></span></span><br><span class="line"><span class="function"><span class="params">            <span class="keyword">int</span> size, <span class="keyword">boolean</span> verticalBar, <span class="keyword">int</span> rightMargin, <span class="keyword">boolean</span> animate)</span> </span>&#123;</span><br><span class="line">    <span class="comment">//1.判断是否存在更新的条件，包括 inset 的尺寸要有，flag 不能有 hideWindowFlag，必须有 FLAG_DRAWS_SYSTEM_BAR_BACKGROUNDS</span></span><br><span class="line">    state.present = size &gt; <span class="number">0</span> &amp;&amp; (sysUiVis &amp; state.systemUiHideFlag) == <span class="number">0</span></span><br><span class="line">                &amp;&amp; (getAttributes().flags &amp; state.hideWindowFlag) == <span class="number">0</span></span><br><span class="line">                &amp;&amp; (getAttributes().flags &amp; FLAG_DRAWS_SYSTEM_BAR_BACKGROUNDS) != <span class="number">0</span>;</span><br><span class="line">    <span class="comment">//2.判断是否要显示，包括颜色不能是黑色，flag 不能配置成 translucent</span></span><br><span class="line">    <span class="keyword">boolean</span> show = state.present</span><br><span class="line">                &amp;&amp; (color &amp; Color.BLACK) != <span class="number">0</span></span><br><span class="line">                &amp;&amp; (getAttributes().flags &amp; state.translucentFlag) == <span class="number">0</span>;</span><br><span class="line">    View view = state.view;</span><br><span class="line">    <span class="keyword">int</span> resolvedHeight = verticalBar ? LayoutParams.MATCH_PARENT : size;</span><br><span class="line">    <span class="keyword">int</span> resolvedWidth = verticalBar ? size : LayoutParams.MATCH_PARENT;</span><br><span class="line">    <span class="keyword">int</span> resolvedGravity = verticalBar ? state.horizontalGravity : state.verticalGravity;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//通过添加一个带颜色的 View ，并更新其 LayoutParams 参数实现效果。</span></span><br><span class="line">    <span class="keyword">if</span> (view == <span class="keyword">null</span>) &#123;</span><br><span class="line">            state.view = view = <span class="keyword">new</span> View(mContext);</span><br><span class="line">            view.setBackgroundColor(color);</span><br><span class="line">            view.setVisibility(INVISIBLE);</span><br><span class="line">            LayoutParams lp = <span class="keyword">new</span> LayoutParams(resolvedWidth, resolvedHeight,</span><br><span class="line">                        resolvedGravity);</span><br><span class="line">            lp.rightMargin = rightMargin;</span><br><span class="line">            addView(view, lp);</span><br><span class="line">            updateColorViewTranslations(); <span class="comment">//使用动画效果</span></span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            LayoutParams lp = (LayoutParams) view.getLayoutParams();</span><br><span class="line">            lp.height = resolvedHeight;</span><br><span class="line">            lp.width = resolvedWidth;</span><br><span class="line">            lp.gravity = resolvedGravity;</span><br><span class="line">            lp.rightMargin = rightMargin;</span><br><span class="line">            view.setLayoutParams(lp);</span><br><span class="line">            view.setBackgroundColor(color);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (animate) &#123;</span><br><span class="line">         view.animate().alpha(<span class="number">1.0f</span>).setInterpolator(mShowInterpolator).</span><br><span class="line">                            setDuration(mBarEnterExitDuration);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>
<p><strong>这里 windowDrawsSystemBarBackgrounds 和 windowTranslucentStatus 是互相排斥的，想要改变状态栏颜色，必须使用前者，禁止后者。后者一旦生效，上述方法将无效，View 不会被创建。</strong></p>
<h4 id="WindowSystemUiVisibility"><a href="#WindowSystemUiVisibility" class="headerlink" title="WindowSystemUiVisibility"></a>WindowSystemUiVisibility</h4><p>SystemUiVisibility 能够完成的动作完全可以通过设置 Window 来完成，但好处在于随时可以清除效果。</p>
<p>SystemUiVisibility 的设置必染色要复杂，涉及状态栏和布局的变化，不过在回调中也会执行更新方法</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onWindowSystemUiVisibilityChanged</span><span class="params">(<span class="keyword">int</span> visible)</span> </span>&#123;</span><br><span class="line">    updateColorViews(<span class="keyword">null</span>, <span class="keyword">true</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li>View.SYSTEM_UI_FLAG_FULLSCREEN 这种情况下，状态栏将彻底消失，内容布局扩展到全屏模式<ul>
<li>SYSTEM_UI_FLAG_IMMERSIVE 默认情况下，触摸下拉会出现通知栏，必须手动清除才能取消 SYSTEM_UI_FLAG_FULLSCREEN 的效果；配合该标记能够下拉出状态栏，且立即清除效果</li>
<li>SYSTEM_UI_FLAG_IMMERSIVE_STICKY 下拉出原生未染色的的状态栏，且不清除效果</li>
</ul>
</li>
<li>View.SYSTEM_UI_FLAG_LAYOUT_FULLSCREEN 内容布局到全屏，且给ActionBar设置一个padding显示状态栏，一旦清除，布局回收，该Padding还在</li>
<li>View.SYSTEM_UI_FLAG_LAYOUT_STABLE 配合上述设置，使得更改永久生效，清除之后布局不回收</li>
</ul>
<h3 id="Toolbar"><a href="#Toolbar" class="headerlink" title="Toolbar"></a>Toolbar</h3><p>最后在说下 ActionBar 和 Toolbar 的关系</p>
<p>设置 Toolbar 的方法如下，首先要判断是否已经存在 ActionBar，通常如果使用 FEATURE_ACTION_BAR 则会初始化 ActionBar， 实现类是 WindowDecorActionBar</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Nullable</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> ActionBar <span class="title">getActionBar</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    Window window = getWindow();</span><br><span class="line">    <span class="keyword">if</span> (!window.hasFeature(Window.FEATURE_ACTION_BAR) || mActionBar != <span class="keyword">null</span>) <span class="keyword">return</span>;</span><br><span class="line">    mActionBar = <span class="keyword">new</span> WindowDecorActionBar(<span class="keyword">this</span>);</span><br><span class="line">    <span class="keyword">return</span> mActionBar;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>如果没有，可以正常进行，新建的实现类是 ToolbarActionBar。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setActionBar</span><span class="params">(@Nullable Toolbar toolbar)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (getActionBar() <span class="keyword">instanceof</span> WindowDecorActionBar) &#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> IllegalStateException(<span class="string">"This Activity already has an action bar supplied "</span> + <span class="string">"by the window decor. Do not request Window.FEATURE_ACTION_BAR and set "</span> +</span><br><span class="line"><span class="string">"android:windowActionBar to false in your theme to use a Toolbar instead."</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    ToolbarActionBar tbab = <span class="keyword">new</span> ToolbarActionBar(toolbar, getTitle(), <span class="keyword">this</span>);</span><br><span class="line">    mActionBar = tbab;</span><br><span class="line">    mActionBar.invalidateOptionsMenu();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>可见 ActionBar 和 Toolbar 是表里的关系。你可以处理菜单相关的事项</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">Menu <span class="title">getMenu</span><span class="params">()</span></span>;</span><br><span class="line">inflateMenu(R.menu.menu_main);</span><br><span class="line"><span class="function"><span class="keyword">boolean</span> <span class="title">showOverflowMenu</span><span class="params">()</span></span>; <span class="comment">//通过反射修改显示 OverflowMenu</span></span><br><span class="line"><span class="function"><span class="keyword">boolean</span> <span class="title">hideOverflowMenu</span><span class="params">()</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">setOnMenuItemClickListener</span><span class="params">(OnMenuItemClickListener listener)</span></span>;</span><br></pre></td></tr></table></figure>
<p>也可以使用动画</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ViewPropertyAnimator toolbarAnimator = toolbar.animate();</span><br></pre></td></tr></table></figure>

        
      
    </div>

    
    
    
      <footer class="post-footer">
          <div class="post-eof"></div>
        
      </footer>
  </div>
  
  
  
  </article>

    
        <article itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block home">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2017/05/18/android/系统/Activity/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="xiang">
      <meta itemprop="description" content="谨守而勿失，是谓反其真">
      <meta itemprop="image" content="/images/1.jpg">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="lxt">
    </span>
      <header class="post-header">
        <h1 class="post-title" itemprop="name headline">
            
            <a href="/2017/05/18/android/系统/Activity/" class="post-title-link" itemprop="url">Activity</a>
          
        </h1>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              
                
              

              <time title="创建时间：2017-05-18 11:26:26" itemprop="dateCreated datePublished" datetime="2017-05-18T11:26:26+08:00">2017-05-18</time>
            </span>
          
            

            
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="fa fa-calendar-check-o"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2019-09-17 23:11:27" itemprop="dateModified" datetime="2019-09-17T23:11:27+08:00">2019-09-17</time>
              </span>
            
          
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing"><a href="/categories/android/" itemprop="url" rel="index"><span itemprop="name">android</span></a></span>

                
                
                  ，
                
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing"><a href="/categories/android/系统/" itemprop="url" rel="index"><span itemprop="name">系统</span></a></span>

                
                
              
            </span>
          

          
          <br>
            <span class="post-meta-item" title="本文字数">
              <span class="post-meta-item-icon">
                <i class="fa fa-file-word-o"></i>
              </span>
              
                <span class="post-meta-item-text">本文字数：</span>
              
              <span>13k</span>
            </span>
          
            <span class="post-meta-item" title="阅读时长">
              <span class="post-meta-item-icon">
                <i class="fa fa-clock-o"></i>
              </span>
              
                <span class="post-meta-item-text">阅读时长 &asymp;</span>
              
              <span>12 分钟</span>
            </span>
          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h2 id="启动流程"><a href="#启动流程" class="headerlink" title="启动流程"></a>启动流程</h2><p>使用 Context 启动活动的方法如下</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">startActivity</span><span class="params">(Intent intent)</span></span>;</span><br></pre></td></tr></table></figure>
<p><strong>其实际流程如图俄罗斯瓷娃娃一样，分别经过ContextImpl，Instrumentation和AMS的处理。</strong></p>
<p>1。首先是 ContextImpl 类，它委托给了Instrumentation 类，自己仅仅检查线程和 flag 参数。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">startActivity</span><span class="params">(Intent intent, Bundle options)</span> </span>&#123;</span><br><span class="line">    warnIfCallingFromSystemProcess();</span><br><span class="line">    <span class="keyword">if</span> ((intent.getFlags()&amp;Intent.FLAG_ACTIVITY_NEW_TASK) == <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> AndroidRuntimeException(</span><br><span class="line">                <span class="string">"Calling startActivity() from outside of an Activity "</span></span><br><span class="line">                + <span class="string">" context requires the FLAG_ACTIVITY_NEW_TASK flag."</span></span><br><span class="line">                + <span class="string">" Is this really what you want?"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    mMainThread.getInstrumentation().execStartActivity(</span><br><span class="line">            getOuterContext(), mMainThread.getApplicationThread(), <span class="keyword">null</span>,</span><br><span class="line">            (Activity) <span class="keyword">null</span>, intent, -<span class="number">1</span>, options);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><strong>这里应该注意如果不是从 Activity 中启动活动，则需要添加 FLAG_ACTIVITY_NEW_TASK 标记，否则将抛出异常。</strong></p>
<p>活动启动的结果用 Instrumentation.ActivityResult 类表示，其定义如下</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">final</span> <span class="keyword">int</span> mResultCode;</span><br><span class="line"><span class="keyword">private</span> <span class="keyword">final</span> Intent mResultData;</span><br></pre></td></tr></table></figure>
<p>而后将对该结果进行检测处理，采用主线程 Handler 机制进行，发生消息为 H.SEND_RESULT ，响应方法为</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">handleSendResult</span><span class="params">(ResultData res)</span></span></span><br></pre></td></tr></table></figure>
<p>该方法中将分发处理结果( dispatchActivityResult )，并调用 onActivityResult(requestCode, resultCode, data) 方法。</p>
<p>2。其次是 Instrumentation 类，它委托给AMS来完成，自己只检查下结果，验证活动是否能够正确启动。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">ActivityResult <span class="title">execStartActivity</span><span class="params">(...)</span></span>&#123;</span><br><span class="line">    IApplicationThread whoThread = (IApplicationThread) contextThread;     </span><br><span class="line">    <span class="keyword">int</span> result = ActivityManagerNative.getDefault().startActivity(...);    </span><br><span class="line">    checkStartActivityResult(result, intent);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>如结果是 ActivityManager.START_CLASS_NOT_FOUND 会爆出常见异常</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Unable to find explicit activity <span class="class"><span class="keyword">class</span> </span>; have you declared <span class="keyword">this</span> activity in your AndroidManifest.xml?<span class="string">"</span></span><br></pre></td></tr></table></figure>
<p>3。最后是AMS ，启动活动会经过一系列复杂的流转，涉及到活动栈的处理等，但最终会回到 ActivityThread 类中来。</p>
<p>在 ActivityThread的 main 方法中，启动了主线程的 Looper 循环。启动活动将发送一个 LAUNCH_ACTIVITY 消息，而后使用内部类 H 来处理该消息。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">ActivityClientRecord r = (ActivityClientRecord) msg.obj;</span><br><span class="line">handleLaunchActivity(r, <span class="keyword">null</span>);</span><br></pre></td></tr></table></figure>
<p>handleLaunchActivity 方法将完成 WindowManager 初始化，并利用反射创建活动对象</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">handleLaunchActivity</span><span class="params">(ActivityClientRecord r, Intent customIntent)</span> </span>&#123;	</span><br><span class="line">    <span class="comment">//1. WindowManager初始化    </span></span><br><span class="line">    WindowManagerGlobal.initialize();    </span><br><span class="line">    Activity a = performLaunchActivity(r, customIntent);    </span><br><span class="line">    <span class="keyword">if</span> (a != <span class="keyword">null</span>) &#123;        </span><br><span class="line">        handleResumeActivity(r.token, <span class="keyword">false</span>, r.isForward);    </span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;        </span><br><span class="line">        ActivityManagerNative.getDefault().finishActivity(r.tokene);    </span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>performLaunchActivity 方法创建活动，</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> Activity <span class="title">performLaunchActivity</span><span class="params">(ActivityClientRecord r, Intent customIntent)</span></span>&#123;	</span><br><span class="line">    Activity activity = mInstrumentation.newActivity(...);        </span><br><span class="line">    Application app = r.packageInfo.makeApplication(<span class="keyword">false</span>, mInstrumentation);	</span><br><span class="line">    Context appContext = createBaseContextForActivity(r, activity);	</span><br><span class="line">    Configuration config = <span class="keyword">new</span> Configuration(mCompatConfiguration);        </span><br><span class="line">    activity.attach(...);                    </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>其中 attach 方法创建了 Window 的实例。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">attach</span><span class="params">(Context context)</span></span>&#123;</span><br><span class="line">    mWindow = <span class="keyword">new</span> PhoneWindow(<span class="keyword">this</span>);    </span><br><span class="line">    mWindow.setCallback(<span class="keyword">this</span>);	</span><br><span class="line">    mWindow.setUiOptions(info.uiOptions);	</span><br><span class="line">    mWindow.setWindowManager()</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>如果活动创建失败，则结束；如果成功，handleResumeActivity 方法会将 DecorView 对象渲染到窗口 PhoneWindow 上去，但注意<strong>此时该控件是不可见的</strong>。如果启动成功，在处理结果的时候后将可见性改为可见。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">handleResumeActivity</span><span class="params">(IBinder token, ...)</span></span>&#123;	</span><br><span class="line">    ActivityClientRecord r = performResumeActivity(token, clearHide);	</span><br><span class="line">    Activity a = r.activity;	</span><br><span class="line">    r.window = r.activity.getWindow();    </span><br><span class="line">    View decor = r.window.getDecorView();    </span><br><span class="line">    decor.setVisibility(View.INVISIBLE);    </span><br><span class="line">    ViewManager wm = a.getWindowManager();    </span><br><span class="line">    WindowManager.LayoutParams l = r.window.getAttributes();    </span><br><span class="line">    a.mDecor = decor;    </span><br><span class="line">    l.type = WindowManager.LayoutParams.TYPE_BASE_APPLICATION;    </span><br><span class="line">    <span class="keyword">if</span> (a.mVisibleFromClient) &#123;         </span><br><span class="line">        a.mWindowAdded = <span class="keyword">true</span>;         </span><br><span class="line">        wm.addView(decor, l);    </span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>因为 AMS 是单例实现，Hook 掉 AMS 非常容易，详情见<a href="http://weishu.me/2016/03/07/understand-plugin-framework-ams-pms-hook/" target="_blank" rel="noopener">weishu的文章</a></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">Class amsClass = Class.forName(<span class="string">"android.app.ActivityManagerNative"</span>);</span><br><span class="line">Method getDefaultMethod = amsClass.getDeclaredMethod(<span class="string">"getDefault"</span>);</span><br><span class="line">Object iActivityManager = getDefaultMethod.invoke(<span class="keyword">null</span>);</span><br><span class="line">Field gDefaultField = amsClass.getDeclaredField(<span class="string">"gDefault"</span>);</span><br><span class="line">gDefaultField.setAccessible(<span class="keyword">true</span>);</span><br><span class="line">Object gDefaultSingleton = gDefaultField.get(<span class="keyword">null</span>);</span><br><span class="line">Class&lt;?&gt; singletonClass = Class.forName(<span class="string">"android.util.Singleton"</span>);</span><br><span class="line">Field mInstanceField = singletonClass.getDeclaredField(<span class="string">"mInstance"</span>);</span><br><span class="line">mInstanceField.setAccessible(<span class="keyword">true</span>);</span><br><span class="line">Class&lt;?&gt; iActivityManagerInterface = Class.forName(<span class="string">"android.app.IActivityManager"</span>);</span><br><span class="line">Object mInstance = Proxy.newProxyInstance(gDefaultSingleton.getClass().getClassLoader(),        <span class="keyword">new</span> Class[]&#123;</span><br><span class="line">    iActivityManagerInterface&#125;,<span class="keyword">new</span> ActivityManagerHandler(iActivityManager));</span><br><span class="line">mInstanceField.set(gDefaultSingleton, mInstance);</span><br></pre></td></tr></table></figure>
<h2 id="生命周期"><a href="#生命周期" class="headerlink" title="生命周期"></a>生命周期</h2><p>在理解了启动流程后，更容易理解生命周期，正常的启动和退出流程是</p>
<p>启动(post 方法等为碎片而存在)：</p>
<blockquote>
<p>onCreate –&gt; onStart –&gt; onPostCreate –&gt; onResume –&gt; onPostResume –&gt; onAttachedToWindow</p>
</blockquote>
<p>退出：</p>
<blockquote>
<p>onPause –&gt; onStop –&gt; onDestroy –&gt; onDetachedFromWindow</p>
</blockquote>
<p>如果中途切换其它 App</p>
<blockquote>
<p>onPause –&gt; <strong>onSaveInstanceState</strong> –&gt; onStop</p>
</blockquote>
<p>恢复页面</p>
<blockquote>
<p><strong>onRestart</strong> –&gt; onStart –&gt; onResume –&gt; onPostResume</p>
</blockquote>
<p>使用adb命令回收Activity(adb shell am force-stop [包名])，与正常退出一致。</p>
<p>如果使用下列方法<strong>旋转屏幕(可以靠重力感应完成，会销毁和重建活动)</strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">setRequestedOrientation(ActivityInfo.SCREEN_ORIENTATION_PORTRAIT);</span><br></pre></td></tr></table></figure>
<p>则生命周期如下，这里调用保存和恢复方法，也可以在onCreate方法中恢复。</p>
<blockquote>
<p>onPause –&gt; <strong>onSaveInstanceState</strong> –&gt; onStop –&gt; onDestroy –&gt; onDetachedFromWindow–&gt;</p>
<p><strong>onCreate</strong> –&gt; onStart –&gt; <strong>onRestoreInstanceState</strong> –&gt; onResume –&gt; onAttachedToWindow</p>
</blockquote>
<p><strong>这和使用 recreate()方法效果一样。</strong></p>
<p>做如下配置可以避免重建，只执行 onConfig 方法</p>
<figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">android:configChanges="keyboard|screenSize|orientation"</span><br></pre></td></tr></table></figure>
<p><strong>此外启动栈内已存在的活动将会调用 onNewIntent 方法。</strong></p>
<h3 id="保存和恢复"><a href="#保存和恢复" class="headerlink" title="保存和恢复"></a><a href="https://github.com/frankiesardo/icepick" target="_blank" rel="noopener">保存和恢复</a></h3><p>活动的保存和恢复是向下分发的，碎片和View都受到影响。如 View会构建一个BaseSavedState对象</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">protected</span> Parcelable <span class="title">onSaveInstanceState</span><span class="params">()</span> </span>&#123;    </span><br><span class="line">    mPrivateFlags |= PFLAG_SAVE_STATE_CALLED;    </span><br><span class="line">    <span class="keyword">if</span> (mStartActivityRequestWho != <span class="keyword">null</span>) &#123;        </span><br><span class="line">        BaseSavedState state = <span class="keyword">new</span> BaseSavedState(AbsSavedState.EMPTY_STATE);        </span><br><span class="line">        state.mStartActivityRequestWhoSaved = mStartActivityRequestWho;        </span><br><span class="line">        <span class="keyword">return</span> state;    </span><br><span class="line">    &#125;    </span><br><span class="line">    <span class="keyword">return</span> BaseSavedState.EMPTY_STATE;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>使用时获取并扩展该对象，写入数据即可。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">SavedState</span> <span class="keyword">extends</span> <span class="title">BaseSavedState</span> </span>&#123;    </span><br><span class="line">    CharSequence text;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="任务栈"><a href="#任务栈" class="headerlink" title="任务栈"></a>任务栈</h2><p>Activity 的启动跳转关系与<strong>Task（任务）和 Back Stack（回退栈）</strong>紧密相连，<code>Task</code> 是一个<strong>Framework</strong>层概念，<strong>专指在程序运行时一组相互关联的activity的集合，负责控制界面的跳转和返回</strong>。<strong>Back Stack</strong>则是实现 Task 所用的数据结构，拥有栈的特点.</p>
<p>下面三个属性会影响<strong>Task</strong>和<strong>Back Stack</strong>的状态。</p>
<ul>
<li><strong>活动的启动模式</strong></li>
<li><strong>taskAffinity属性</strong></li>
<li><strong>intent的flag属性</strong></li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">android:launchMode=<span class="string">"standard"</span></span><br><span class="line">android:taskAffinity=<span class="string">"con.incredible"</span></span><br><span class="line">intent.setFlags(Intent.FLAG_ACTIVITY_NEW_TASK);</span><br></pre></td></tr></table></figure>
<p>简单说来</p>
<ul>
<li>启动模式为<strong>standard</strong>或<strong>singleTop</strong>时，Activity 一般在同一个栈中。</li>
<li>启动模式为<strong>singleTask</strong>或<strong>singleInstance</strong>时，一般会产生新的任务栈。</li>
</ul>
<h3 id="Task和Back-Stack"><a href="#Task和Back-Stack" class="headerlink" title="Task和Back Stack"></a><strong>Task和Back Stack</strong></h3><p>默认情况下，某个<strong>Application</strong>中所有<strong>activity</strong>都处在同一个<strong>Task</strong>中。但二者并没有严格的约束条件，这里有两种情况：</p>
<ul>
<li>两个<strong>Application</strong>中的<strong>activity</strong>可以处在同一个<strong>Task</strong>中。即 <strong>task 是可以跨应用的，这正是task存在的一个重要原因</strong>。</li>
<li>一个<strong>Application</strong>中的<strong>activity</strong>也可以处于多个<strong>Task</strong>中。</li>
</ul>
<p>例如在应用中的一个Activity A中使用系统邮件，会启动系统邮件程序的一个Activity B。这两个activity是存在于不同app中的，但是被系统放在一个task中,这样能保证程序回退到原有程序中。</p>
<p>设备Home界面是大多数tasks的起始点。<strong>当用户点击程序在Home上的启动图标时，这个程序的task就转入前台。如果程序没有打开，那么之前不存在task，一个新的task将被创建并且程序的”main” 活动将被打开并被推入栈中；如果程序已经打开，则已经存在Task，就恢复显示栈顶的活动。</strong></p>
<p><strong>当目前的activity启动另外一个activity时，新的activity被压入栈中作为栈顶并且获取到了focus。前面的那个activity则进入stopped状态，此时系统会保留它的UI状态以便恢复。当用户点击back按钮时，栈顶的activity从栈顶退出并被destroyed，之前处于stopped状态的activity则进入resume状态(其保存的UI状态得到恢复).</strong></p>
<p><img src="http://hukai.me/images/articles/diagram_backstack.png" alt="1"></p>
<p>如果用户持续点击back按钮，那么在栈中的每一个activity都会做退栈并显示之前activity的动作, 直到用户退回到Home界面(或者是用户开始task的地方)。<strong>当所有的activities都从栈中被移除之后，这个task也就消失了。</strong></p>
<p>一个task是一个紧密结合的单元，处于后台的task中的所有活动都处于stopped状态，只有task转移到前台，栈顶的活动显示。<strong>众多tasks都可以一并在后台被Hold住，然而系统为了恢复内存而有可能销毁这些栈中的activities。</strong></p>
<p><strong>此时activity的状态信息则会丢失. 但系统仍然为那个activity在back stack中保留了位置, 但是当这个activity成为栈顶activity时, 系统必须recreate它(而不是resume它)，这时需要使用者主动实现onSaveInstanceState()回调方法来保存恢复所需的信息。</strong></p>
<blockquote>
<p>在activity中调用 moveTaskToBack (boolean nonRoot)方法即可将activity 退到后台，注意不是finish()退出。</p>
</blockquote>
<h3 id="启动模式"><a href="#启动模式" class="headerlink" title="启动模式"></a><a href="http://ltlovezh.com/2016/08/28/Activity启动模式一/" target="_blank" rel="noopener">启动模式</a></h3><p><strong>每个活动的创建有两步：以下对四种启动模式的分析都从这两步进行</strong></p>
<p>1.判断是否创建新任务栈，即<strong>新Task</strong>。<br>2.判断是否创建新活动，即<strong>新 Activity</strong>。</p>
<p><strong>活动如何创建</strong>主要受两个因素影响：<strong>taskAffinity属性</strong>与<strong>启动模式</strong>。</p>
<p>a.taskAffinity 属性意味着 activity 更倾向归属于哪一个task，可以认为它指定了<strong>activity</strong>所在的<strong>task</strong>名称，这一属性是活动处在不同的<code>Task</code>中的<strong>必要不充分条件</strong>。使用<strong>taskAffinity</strong>属性的一些原则是：</p>
<p>1.如果不设置某活动的<strong>taskAffinity</strong>属性，则该属性值与启动它的活动相同。第一个活动的该属性为应用的包名。<br>2.<strong>taskAffinity</strong>属性并不能唯一决定活动所在的栈，还要受到<strong>启动模式</strong>影响。</p>
<p><strong>举例</strong>:假设某个APP内的活动启动顺序为：<strong>a-b-c-d</strong>。如果采用默认配置，则abcd四个活动都将处在名称为包名的 Task 中。</p>
<p><strong>b.启动模式</strong><br>设置活动和 Task 的关系。<strong>一共有四种启动模式：为</strong>standard<strong>，</strong>singleTop<strong>，</strong>singleTask<strong>，</strong>singleInstance。</p>
<h4 id="Standard-默认模式"><a href="#Standard-默认模式" class="headerlink" title="Standard(默认模式)"></a><strong>Standard(默认模式)</strong></h4><p>1.taskAffinity 属性无效。即使设置也并不会创建新 Task ，活动所处的 task 与启动它的活动永远保持一致。</p>
<p>2.活动的创建百无禁忌，不需要任何检查就创建新的活动实例，因为<strong>能够重复创建活动实例</strong>。</p>
<h4 id="SingleTop"><a href="#SingleTop" class="headerlink" title="SingleTop"></a><strong>SingleTop</strong></h4><ol>
<li>taskAffinity 属性同样无效。</li>
</ol>
<p>2.与标准模式的区别在于第二步， SingleTop 模式对活动的创建做了一个<strong>较弱的约束</strong>，即<strong>不允许创建与栈顶重复的活动实例</strong>。会检查<strong>活动返回栈的栈顶活动</strong>是否是待启动的活动类，如果是则不会创建活动实例。</p>
<p>如当前活动栈是<code>a-b-c-d</code>。如果再启动<code>d</code>，仍是<code>a-b-c-d</code>；启动<code>a</code>，将是<code>a-b-c-d-a</code>。</p>
<h4 id="SingleTask"><a href="#SingleTask" class="headerlink" title="SingleTask"></a><strong>SingleTask</strong></h4><p>前两种模式中， taskAffinity 属性都是无效的，不会对新活动所处的 task 产生影响。 singleTask 模式下， taskAffinity 属性终于获得用武的机会，将对<strong>task</strong>产生影响。</p>
<p>1.在新活动<strong>c</strong>创建时，先查看是否存在与其<strong>taskAffinity</strong>属性相同的<strong>task</strong>。</p>
<ul>
<li>如果存在，不会创建新<strong>task</strong>。</li>
<li>如果不存在，则创建以<strong>taskAffinity</strong>属性为名的新<strong>task</strong>。</li>
</ul>
<p>如果不设置<strong>taskAffinity</strong>属性，则该属性值与启动它的活动一致，此时不会产生新的<strong>task</strong>。</p>
<p>2.再在选中的<strong>task</strong>中查找有无活动<strong>c</strong>实例。</p>
<ul>
<li><strong>有则将该task中c实例之上的活动全部出栈，使得该实例处在栈顶;</strong></li>
<li>没有则在栈顶上新建活动<code>c</code>.</li>
</ul>
<h4 id="SingleInstance"><a href="#SingleInstance" class="headerlink" title="SingleInstance"></a><strong>SingleInstance</strong></h4><p>SingleInstance 模式中，<strong>taskAffinity 属性再次失效</strong>，活动总会在新 Task 中启动。</p>
<p>1.不管怎么设置<strong>taskAffinity</strong>属性，活动总是会在<strong>新的任务task</strong>中运行。</p>
<p>2.以 SingleInstance 模式启动的活动<strong>在整个系统中是单例的</strong>。如果单例 task 中存在了一个实例，那么会把已存在的任务调度到前台，<strong>且会调用该Activity的onNewIntent方法</strong>。</p>
<p>以 SingleInstance 模式启动的 Activity <strong>具有独占性</strong>，即它会<strong>独自占用一个task</strong>，<strong>被他开启的任何 Activity 都会运行在其他task中</strong>, 这一点与 singletask 模式有所区别。</p>
<h4 id="使用技巧-如何退出APP"><a href="#使用技巧-如何退出APP" class="headerlink" title="使用技巧:如何退出APP?"></a>使用技巧:如何退出APP?</h4><p>性能分析工具 dumpsys可以查看感兴任务栈信息</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">//1. 列出dumpsys所有支持命令</span><br><span class="line">adb shell dumpsys | grep <span class="string">"DUMP OF SERVICE"</span></span><br><span class="line">adb shell dumpsys activity  //检测Activity任务栈</span><br></pre></td></tr></table></figure>
<p>命令得到的信息很多，可以获取</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">ACTIVITY MANAGER RECENT TASKS (dumpsys activity recents)  </span><br><span class="line">Recent tasks:  </span><br><span class="line">* Recent #0: TaskRecord&#123;33618f06 #10871 A=com.lxt.toast U=0 sz=2&#125;  * </span><br><span class="line">Recent #1: TaskRecord&#123;38898108 #10872 A=com.qihoo360.mobilesafe U=0 sz=0&#125;ACTIVITY MANAGER ACTIVITIES (dumpsys activity activities)Display #0 (activities from top to bottom):  </span><br><span class="line">Stack #1:    Task id #10871      TaskRecord&#123;33618f06 #10871 A=com.lxt.toast U=0 sz=2&#125;      Intent &#123; act=android.intent.action.MAIN cat=[android.intent.category.LAUNCHER] flg=0x10000000 cmp=com.lxt.toast/.MainActivity &#125;        </span><br><span class="line">Hist #1: ActivityRecord&#123;30b1cfcf u0 com.lxt.toast/.Main2Activity t10871&#125;        </span><br><span class="line">Hist #0: ActivityRecord&#123;224a2c28 u0 com.lxt.toast/.MainActivity t10871&#125;    </span><br><span class="line">Task id #10868      TaskRecord&#123;32f0d2c6 #10868 A=com.android.settings U=0 sz=1&#125;  mFocusedActivity: ActivityRecord&#123;30b1cfcf u0 com.lxt.toast/.Main2Activity t10871&#125;  mFocusedStack=ActivityStack&#123;16b5b2d9 stackId=1, 51 tasks&#125; mLastFocusedStack=ActivityStack&#123;16b5b2d9 stackId=1, 51 tasks&#125;  mCurTaskId=10872</span><br></pre></td></tr></table></figure>
<p>singleTask 这个模式有一个重要应用，即所谓的“<strong>优雅的退出APP</strong>”。<strong>将第一个活动设置为singleTask 模式，则在其他活动中向首活动跳转将会将该栈内部的所有活动出栈。</strong></p>
<p>如果某APP中启动活动顺序是A–&gt;B—&gt;C—&gt;D，要从D中退出整个APP。原理是将活动A设置为singleTask 模式，并在该活动中跳转到启动活动A，则A之上的活动将全部出栈，最终结束A即可。</p>
<p>这么做的思路和原理是正确的，但是必须保证ABCD都处在同一个任务栈下才有效。<strong>A只能将和它相同的栈内的活动出栈，而不能将其他任务栈中的活动出栈</strong>。</p>
<blockquote>
<p>更简单的操作是直接使用finishAffinity()方法，<strong>注意该方法会销毁栈</strong>。</p>
</blockquote>
<h3 id="Intent"><a href="#Intent" class="headerlink" title="Intent"></a>Intent</h3><p>Intent 译作“意图”，表示一个对某类数据待执行的操作，可以用来启动安卓的三大组件活动，服务和广播。因为 Intent 将用在跨进程通信中，所以它是一个 Parcelable 类。</p>
<p>Intent 的基本信息包括 action 和 data。 Action 表示动作类型，Data 指定动作操作的数据 Uri。 例如 ACTION_VIEW 是默认动作，表示展示数据给用户，而展示何种数据由类型决定，展示的内容由 Uri 指定，下例表示展示文本数据。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Intent intent = <span class="keyword">new</span> Intent(ACTION_VIEW);</span><br><span class="line">intent.setType(<span class="string">"text/plain"</span>);</span><br><span class="line">startActivity(intent);</span><br></pre></td></tr></table></figure>
<p>发出此 Intent 后，设备内部能够匹配此意图的应用会出现在列表中，即数据展示方式由设备已有的程序决定。<strong>隐式 Intent 的解析机制依赖 IntentFilter ，安卓组件通过设置 IntentFilter 确定自己所能匹配的 Intent 。</strong></p>
<p>Intent 的补充信息包括Categories(对动作信息进行补充)，Type(指定数据的<strong>MIME</strong>类型)，Extras(提供<strong>额外信息</strong>)，</p>
<p>当发出 Intent 后会对 PackageManager 做查询，在 AndroidManifest.xml 配置文件上寻找能够完成匹配的安卓组件。组件中 IntentFilter 所定义的信息要全部一致才算匹配成功，如果定义了多个 category ，至少要匹配其中一个。</p>
<p>安卓组件也可以定义多个 intent-filter ，此时只要有一个匹配成功就能启动组件。</p>
<p>如果设备内没有能够响应 Intent 的程序，则会抛出异常，因此为安全起见可用如下方法预先判断下</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">List&lt;ResolveInfo&gt; resolveInfos = getPackageManager().queryIntentActivities(intent, PackageManager.MATCH_DEFAULT_ONLY);</span><br></pre></td></tr></table></figure>
<blockquote>
<p>PackageManager.MATCH_DEFAULT_ONLY表示只匹配设置了CATEGORY_DEFAULT的活动。</p>
</blockquote>
<p>标记位 Flags 控制动作的执行方式，它与具体的组件有关。最常见的标记位多是与活动组件由关的，以<code>FLAG_ACTIVITY</code>开头。</p>
<p><strong>1.FLAG_ACTIVITY_SINGLE_TOP</strong>表示<strong>SINGLE_TOP</strong>启动方式</p>
<p><strong>2.FLAG_ACTIVITY_NO_ANIMATION</strong>防止活动启动时使用转场动画。</p>
<p><strong>3.FLAG_ACTIVITY_TASK_ON_HOME</strong> 活动将在主屏幕所在栈上新栈，此时点击后退，将回退到主屏幕上。</p>
<p><strong>4.FLAG_ACTIVITY_CLEAR_TASK</strong> 此前的活动栈将销毁，所启动的活动将成为新栈的根，需要配合<code>FLAG_ACTIVITY_NEW_TASK</code>使用。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">intent.setFlags(Intent.FLAG_ACTIVITY_NEW_TASK);</span><br><span class="line">intent.addFlags(Intent.FLAG_ACTIVITY_CLEAR_TASK);</span><br></pre></td></tr></table></figure>
<h4 id="PendingIntent"><a href="#PendingIntent" class="headerlink" title="PendingIntent"></a>PendingIntent</h4><p><code>PendingIntent</code>表示一个<strong>延时意图</strong>，亦是<code>Parcelable</code>对象，<strong>因为是跨进程实现，即便启动进程销毁，IIntentSender对象依然存在在另一个进程中。这造成一个问题，使用该对象时如果进程已经有一个PendingIntent对象存在，应该如何处理？</strong></p>
<p><strong>1.不管怎样首先要判断两个PendingIntent是否相等？</strong></p>
<p>一个错误是创建多个仅仅”extra”不同的<code>PendingIntent</code>对象，这些实际上相同的。使用下列方法可以进行相等性判断</p>
<figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Intent#filterEquals(Intent)</span><br></pre></td></tr></table></figure>
<p><strong>2.发送时如果要创建不同的PendingIntent对象，可以更改getActivity方法中的请求码。</strong></p>
<p><strong>3.发送时如果要创建相同的PendingIntent对象，可以使用FLAG_UPDATE_CURRENT /FLAG_CANCEL_CURRENT标记位。</strong></p>
<ul>
<li><code>FLAG_ONE_SHOT</code> <code>PendingIntent</code>只使用一次</li>
<li><code>FLAG_NO_CREATE</code> <code>PendingIntent</code>如果不存在，不再创建</li>
<li><code>FLAG_CANCEL_CURRENT</code> 如果<code>PendingIntent</code>存在，取消创建新的 ，如果发送的intent仅仅在extra 数据不同，可以使用该标记位创建新的</li>
<li><code>FLAG_UPDATE_CURRENT</code> 如果<code>PendingIntent</code>存在，替代它的<code>extra data</code></li>
</ul>
<h2 id="几个常用的API"><a href="#几个常用的API" class="headerlink" title="几个常用的API"></a>几个常用的API</h2><p>关于栈</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">getTaskId</span><span class="params">()</span></span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">isTaskRoot</span><span class="params">()</span> </span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">moveTaskToBack</span><span class="params">(<span class="keyword">boolean</span> nonRoot)</span> <span class="comment">//隐藏栈，实际是是回到桌面</span></span></span><br></pre></td></tr></table></figure>
<p>创建和关闭</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">recreate</span><span class="params">()</span>；  </span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">finish</span><span class="params">()</span></span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">finishAffinity</span><span class="params">()</span><span class="comment">//关闭同一个栈内的活动public void finishAfterTransition() //等待动画完成</span></span></span><br></pre></td></tr></table></figure>
        
      
    </div>

    
    
    
      <footer class="post-footer">
          <div class="post-eof"></div>
        
      </footer>
  </div>
  
  
  
  </article>

    
  </div>

  
  <nav class="pagination">
    <a class="extend prev" rel="prev" href="/"><i class="fa fa-angle-left" aria-label="上一页"></i></a><a class="page-number" href="/">1</a><span class="page-number current">2</span><a class="page-number" href="/page/3/">3</a><a class="extend next" rel="next" href="/page/3/"><i class="fa fa-angle-right" aria-label="下一页"></i></a>
  </nav>


          </div>
          

        </div>
          
  
  <div class="sidebar-toggle">
    <div class="sidebar-toggle-line-wrap">
      <span class="sidebar-toggle-line sidebar-toggle-line-first"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-middle"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-last"></span>
    </div>
  </div>

  <aside class="sidebar">
    <div class="sidebar-inner">

      <ul class="sidebar-nav motion-element">
        <li class="sidebar-nav-toc">
          文章目录
        </li>
        <li class="sidebar-nav-overview">
          站点概览
        </li>
      </ul>

      <!--noindex-->
      <div class="post-toc-wrap sidebar-panel">
      </div>
      <!--/noindex-->

      <div class="site-overview-wrap sidebar-panel">
        <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
    <img class="site-author-image" itemprop="image"
      src="/images/1.jpg"
      alt="xiang">
  <p class="site-author-name" itemprop="name">xiang</p>
  <div class="site-description" itemprop="description">谨守而勿失，是谓反其真</div>
</div>
  <nav class="site-state motion-element">
      <div class="site-state-item site-state-posts">
        
          <a href="/archives/">
        
          <span class="site-state-item-count">22</span>
          <span class="site-state-item-name">日志</span>
        </a>
      </div>
    
      
      
      <div class="site-state-item site-state-categories">
        
          
            <a href="/categories/">
          
        
        <span class="site-state-item-count">8</span>
        <span class="site-state-item-name">分类</span>
        </a>
      </div>
    
  </nav>
  <div class="links-of-author motion-element">
      <span class="links-of-author-item">
      
      
        
      
      
        
      
        <a href="https://github.com/liuxiangtian" title="GitHub &rarr; https://github.com/liuxiangtian" rel="noopener" target="_blank"><i class="fa fa-fw fa-github"></i>GitHub</a>
      </span>
    
      <span class="links-of-author-item">
      
      
        
      
      
        
      
        <a href="http://www.zhihu.com/people/liu-xiang-tian-74" title="zhihu &rarr; http://www.zhihu.com/people/liu-xiang-tian-74" rel="noopener" target="_blank"><i class="fa fa-fw fa-globe"></i>zhihu</a>
      </span>
    
  </div>



      </div>

    </div>
  </aside>
  <div id="sidebar-dimmer"></div>


      </div>
    </main>

    <footer id="footer" class="footer">
      <div class="footer-inner">
        <div class="copyright">&copy; <span itemprop="copyrightYear">2019</span>
  <span class="with-love" id="animate">
    <i class="fa fa-user"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">刘祥</span>
    <span class="post-meta-divider">|</span>
    <span class="post-meta-item-icon">
      <i class="fa fa-area-chart"></i>
    </span>
    <span title="站点总字数">191k</span>
    <span class="post-meta-divider">|</span>
    <span class="post-meta-item-icon">
      <i class="fa fa-coffee"></i>
    </span>
    <span title="站点阅读时长">2:53</span>
</div>



        












        
      </div>
    </footer>
  </div>

  


  <script src="/lib/anime.min.js?v=3.1.0"></script>
  <script src="/lib/velocity/velocity.min.js?v=1.2.1"></script>
  <script src="/lib/velocity/velocity.ui.min.js?v=1.2.1"></script>
<script src="/js/utils.js?v=7.4.0"></script><script src="/js/motion.js?v=7.4.0"></script>
<script src="/js/schemes/pisces.js?v=7.4.0"></script>

<script src="/js/next-boot.js?v=7.4.0"></script><script src="/js/bookmark.js?v=7.4.0"></script><!-- hexo-inject:begin --><!-- hexo-inject:end -->



  





















  

  
    
      
    
      
    
      
    
      
    
      
    
      
    
      
    
      
    
      
    
      
    
  

  

  

</body>
</html>
