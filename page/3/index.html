<!DOCTYPE html>





<html lang="zh-CN,ja,en,default">
<head>
  <!-- hexo-inject:begin --><!-- hexo-inject:end --><meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=2">
<meta name="theme-color" content="#222">
<meta name="generator" content="Hexo 3.9.0">
  <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon-next.png?v=7.4.0">
  <link rel="icon" type="image/png" sizes="32x32" href="/images/favicon-32x32-next.png?v=7.4.0">
  <link rel="icon" type="image/png" sizes="16x16" href="/images/favicon-16x16-next.png?v=7.4.0">
  <link rel="mask-icon" href="/images/logo.svg?v=7.4.0" color="#222">

<link rel="stylesheet" href="/css/main.css?v=7.4.0">


<link rel="stylesheet" href="/lib/font-awesome/css/font-awesome.min.css?v=4.7.0">


<script id="hexo-configurations">
  var NexT = window.NexT || {};
  var CONFIG = {
    root: '/',
    scheme: 'Gemini',
    version: '7.4.0',
    exturl: false,
    sidebar: {"position":"left","display":"hide","offset":12,"onmobile":false},
    copycode: {"enable":false,"show_result":false,"style":null},
    back2top: {"enable":true,"sidebar":false,"scrollpercent":false},
    bookmark: {"enable":true,"color":"#222","save":"auto"},
    fancybox: false,
    mediumzoom: false,
    lazyload: false,
    pangu: false,
    algolia: {
      appID: '',
      apiKey: '',
      indexName: '',
      hits: {"per_page":10},
      labels: {"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}
    },
    localsearch: {"enable":false,"trigger":"auto","top_n_per_article":1,"unescape":false,"preload":false},
    path: '',
    motion: {"enable":true,"async":false,"transition":{"post_block":"fadeIn","post_header":"slideDownIn","post_body":"slideDownIn","coll_header":"slideLeftIn","sidebar":"slideUpIn"}},
    translation: {
      copy_button: '复制',
      copy_success: '复制成功',
      copy_failure: '复制失败'
    },
    sidebarPadding: 40
  };
</script>

  <meta name="description" content="谨守而勿失，是谓反其真">
<meta property="og:type" content="website">
<meta property="og:title" content="lxt">
<meta property="og:url" content="http://yoursite.com/page/3/index.html">
<meta property="og:site_name" content="lxt">
<meta property="og:description" content="谨守而勿失，是谓反其真">
<meta property="og:locale" content="zh-CN">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="lxt">
<meta name="twitter:description" content="谨守而勿失，是谓反其真">
  <link rel="canonical" href="http://yoursite.com/page/3/">


<script id="page-configurations">
  // https://hexo.io/docs/variables.html
  CONFIG.page = {
    sidebar: "",
    isHome: true,
    isPost: false,
    isPage: false,
    isArchive: false
  };
</script>

  <title>lxt</title>
  








  <noscript>
  <style>
  .use-motion .brand,
  .use-motion .menu-item,
  .sidebar-inner,
  .use-motion .post-block,
  .use-motion .pagination,
  .use-motion .comments,
  .use-motion .post-header,
  .use-motion .post-body,
  .use-motion .collection-header { opacity: initial; }

  .use-motion .logo,
  .use-motion .site-title,
  .use-motion .site-subtitle {
    opacity: initial;
    top: initial;
  }

  .use-motion .logo-line-before i { left: initial; }
  .use-motion .logo-line-after i { right: initial; }
  </style>
</noscript><!-- hexo-inject:begin --><!-- hexo-inject:end -->

</head>

<body itemscope itemtype="http://schema.org/WebPage" lang="zh-CN">
  <!-- hexo-inject:begin --><!-- hexo-inject:end --><div class="container use-motion">
    <div class="headband"></div>

    <header id="header" class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-container">
  <div class="site-meta">

    <div>
      <a href="/" class="brand" rel="start">
        <span class="logo-line-before"><i></i></span>
        <span class="site-title">lxt</span>
        <span class="logo-line-after"><i></i></span>
      </a>
    </div>
  </div>

  <div class="site-nav-toggle">
    <button aria-label="切换导航栏">
      <span class="btn-bar"></span>
      <span class="btn-bar"></span>
      <span class="btn-bar"></span>
    </button>
  </div>
</div>


<nav class="site-nav">
  
  <ul id="menu" class="menu">
      
      
      
        
        <li class="menu-item menu-item-home">
      
    

    <a href="/" rel="section"><i class="menu-item-icon fa fa-fw fa-home"></i> <br>首页</a>

  </li>
      
      
      
        
        <li class="menu-item menu-item-tags">
      
    

    <a href="/tags/" rel="section"><i class="menu-item-icon fa fa-fw fa-tags"></i> <br>标签</a>

  </li>
      
      
      
        
        <li class="menu-item menu-item-categories">
      
    

    <a href="/categories/" rel="section"><i class="menu-item-icon fa fa-fw fa-th"></i> <br>分类</a>

  </li>
      
      
      
        
        <li class="menu-item menu-item-archives">
      
    

    <a href="/archives/" rel="section"><i class="menu-item-icon fa fa-fw fa-archive"></i> <br>归档</a>

  </li>
  </ul>

</nav>
</div>
    </header>

    
  <div class="back-to-top">
    <i class="fa fa-arrow-up"></i>
    <span>0%</span>
  </div>
  <div class="reading-progress-bar"></div>
  <a class="book-mark-link book-mark-link-fixed" href="#"></a>


    <main id="main" class="main">
      <div class="main-inner">
        <div class="content-wrap">
            

          <div id="content" class="content">
            
  <div id="posts" class="posts-expand">
        <article itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block home">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2017/08/04/android/View/动画一：常规动画/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="xiang">
      <meta itemprop="description" content="谨守而勿失，是谓反其真">
      <meta itemprop="image" content="/images/1.jpg">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="lxt">
    </span>
      <header class="post-header">
        <h1 class="post-title" itemprop="name headline">
            
            <a href="/2017/08/04/android/View/动画一：常规动画/" class="post-title-link" itemprop="url">动画一：常规动画</a>
          
        </h1>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              
                
              

              <time title="创建时间：2017-08-04 21:26:26" itemprop="dateCreated datePublished" datetime="2017-08-04T21:26:26+08:00">2017-08-04</time>
            </span>
          
            

            
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="fa fa-calendar-check-o"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2019-09-18 16:15:57" itemprop="dateModified" datetime="2019-09-18T16:15:57+08:00">2019-09-18</time>
              </span>
            
          
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing"><a href="/categories/android/" itemprop="url" rel="index"><span itemprop="name">android</span></a></span>

                
                
                  ，
                
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing"><a href="/categories/android/View/" itemprop="url" rel="index"><span itemprop="name">View</span></a></span>

                
                
              
            </span>
          

          
          <br>
            <span class="post-meta-item" title="本文字数">
              <span class="post-meta-item-icon">
                <i class="fa fa-file-word-o"></i>
              </span>
              
                <span class="post-meta-item-text">本文字数：</span>
              
              <span>11k</span>
            </span>
          
            <span class="post-meta-item" title="阅读时长">
              <span class="post-meta-item-icon">
                <i class="fa fa-clock-o"></i>
              </span>
              
                <span class="post-meta-item-text">阅读时长 &asymp;</span>
              
              <span>10 分钟</span>
            </span>
          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h2 id="属性动画-android-animation"><a href="#属性动画-android-animation" class="headerlink" title="属性动画(android.animation)"></a>属性动画(android.animation)</h2><h3 id="插值器-Interpolator"><a href="#插值器-Interpolator" class="headerlink" title="插值器(Interpolator)"></a>插值器(Interpolator)</h3><p>Interpolator 是可以使用 XML 来定义和解析的，它的作用是根据输入产生一个 [0， 1]之间的值</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">TimeInterpolator</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">float</span> <span class="title">getInterpolation</span><span class="params">(<span class="keyword">float</span> input)</span></span>; <span class="comment">//输入和输出区间都是[0, 1] </span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>Interpolator 有各种子类，最简单的是线性的 LinearInterpolator ，各种子类的公式如下</p>
<ul>
<li>$LinearInterpolator : a(t) = t $</li>
<li>$AccelerateInterpolator : a (t) = t*t $</li>
<li>$DecelerateInterpolator : a (t) =1 - (1-t)*(1-t) $</li>
<li>$AccelerateDecelerateInterpolator : a (t) =\frac{cos((t+1)*\pi }{2} + 0.5 $</li>
<li>$AnticipateInterpolator : a(t) = t <em>t</em> ((tension + 1) * t - tension)$ 越来越快</li>
<li>$BounceInterpolator ：$分段函数，呈弹跳效果</li>
<li>$CycleInterpolator ： a (t) = sin(2<em>\pi</em>cycles<em>t) $ \</em>将时间映射成正弦曲线，呈振动式效果，这一点实际非常有用，如果时间给500ms，那么就是半周期，数值复0，适合与View的animate方法联合使用。*</li>
<li>$LookupTableInterpolator : $通过查表来产生结果值</li>
</ul>
<blockquote>
<p>插值器在属性动画中用于时间轴的变换。</p>
</blockquote>
<h3 id="估值器-TypeEvaluator"><a href="#估值器-TypeEvaluator" class="headerlink" title="估值器(TypeEvaluator)"></a>估值器(TypeEvaluator)</h3><p>TypeEvaluator 类用来根据起始值和时间坐标计算中间值。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">TypeEvaluator</span>&lt;<span class="title">T</span>&gt; </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> T <span class="title">evaluate</span><span class="params">(<span class="keyword">float</span> fraction, T startValue, T endValue)</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>典型的估值器实现如 IntEvaluator，RectEvaluator，ArgbEvaluator 等均是线性实现。</p>
<p><strong>通过自定义估值器可以实现属性动画。例如自定义一个改变控件高度的属性动画</strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//1.创建估值器，注意要改的属性是 LayoutParams.height。</span></span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> Integer <span class="title">evaluate</span><span class="params">(<span class="keyword">float</span> fraction, Integer startValue, Integer endValue)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">int</span> num = <span class="keyword">super</span>.evaluate(fraction, startValue, endValue);</span><br><span class="line">  ViewGroup.LayoutParams params = view.getLayoutParams();</span><br><span class="line">  params.height = num;</span><br><span class="line">  v.setLayoutParams(params);</span><br><span class="line">  <span class="keyword">return</span> num;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//2.创建属性动画</span></span><br><span class="line">ValueAnimator.ofObject(<span class="keyword">new</span> MyEvalutor(<span class="keyword">this</span>), <span class="number">0f</span>, <span class="number">1f</span>).start();</span><br></pre></td></tr></table></figure>
<blockquote>
<p>使用估计器比添加 AnimatorUpdateListener 接口要简洁一些。</p>
</blockquote>
<h3 id="Property-与-PropertyValuesHolder"><a href="#Property-与-PropertyValuesHolder" class="headerlink" title="Property 与 PropertyValuesHolder"></a>Property 与 PropertyValuesHolder</h3><p>Property`类表示属性，所以它要表示键值对，对于键，必须是 String 类型，其值表示属性名；对于值，需要一个对象(Class：T) 来提供，数据类型为V，使用 get/set 方法可以从对象中读取和设置属性值。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="class"><span class="keyword">class</span> <span class="title">Property</span>&lt;<span class="title">T</span>, <span class="title">V</span>&gt; </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> String mName;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> Class&lt;V&gt; mType;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">set</span><span class="params">(T object, V value)</span></span>;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">abstract</span> V <span class="title">get</span><span class="params">(T object)</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>以 View 中的”alpha”属性为例，View 对象提供 alpha 属性，其值的格式是 float。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> Property&lt;View, Float&gt; ALPHA = <span class="keyword">new</span> FloatProperty&lt;View&gt;(<span class="string">"alpha"</span>) &#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setValue</span><span class="params">(View object, <span class="keyword">float</span> value)</span> </span>&#123;</span><br><span class="line">        object.setAlpha(value);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Float <span class="title">get</span><span class="params">(View object)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> object.getAlpha();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>PropertyValuesHolder 是对属性 Property 的包装，合成了Property ，属性名称以及属性值集合等，并通过反射(Method)来修改属性值。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> PropertyValuesHolder <span class="title">ofInt</span><span class="params">(Property&lt;?, Integer&gt; property, <span class="keyword">int</span>... values)</span> </span>&#123; </span><br><span class="line">    <span class="comment">//Keyframe 是 time/value 的键值对</span></span><br><span class="line">    mKeyframes = KeyframeSet.ofInt(values); </span><br><span class="line">    mPropertyName = property.getName();</span><br><span class="line">    mProperty = property;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> IntPropertyValuesHolder(property, values);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><strong>传入的多个属性值被转为 Keyframe 集合，且设置了属性名，值类型被确定为 int，通过 Property 对象可以应用属性值。只是缺少一个对象来提供和接受 int 类型的值。</strong></p>
<ul>
<li>PropertyValuesHolder 还可以用 Object 对象来构造。</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> PropertyValuesHolder <span class="title">ofObject</span><span class="params">(String propertyName, TypeEvaluator evaluator,</span></span></span><br><span class="line"><span class="function"><span class="params">        Object... values)</span> </span>&#123;</span><br><span class="line">    PropertyValuesHolder pvh = <span class="keyword">new</span> PropertyValuesHolder(propertyName);</span><br><span class="line">    pvh.setObjectValues(values);</span><br><span class="line">    pvh.setEvaluator(evaluator);</span><br><span class="line">    <span class="keyword">return</span> pvh;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这里对象将被转换为 ObjectKeyframe，只不过属性值由Object对象提供。</p>
<p>PropertyValuesHolder 的重要职责是完成真正的步进计算</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">calculateValue</span><span class="params">(<span class="keyword">float</span> fraction)</span> </span>&#123;</span><br><span class="line">    Object value = mKeyframes.getValue(fraction);</span><br><span class="line">    mAnimatedValue = mConverter == <span class="keyword">null</span> ? value : mConverter.convert(value);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="值动画-ValueAnimator-和对象动画-ObjectAnimator"><a href="#值动画-ValueAnimator-和对象动画-ObjectAnimator" class="headerlink" title="值动画(ValueAnimator)和对象动画(ObjectAnimator)"></a>值动画(ValueAnimator)和对象动画(ObjectAnimator)</h3><p>ValueAnimator 的主要域如下</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">long</span> mStartTime;</span><br><span class="line">PropertyValuesHolder[] mValues; <span class="comment">//属性集合</span></span><br><span class="line">HashMap&lt;String, PropertyValuesHolder&gt; mValuesMap;  <span class="comment">//属性查找表</span></span><br><span class="line">ArrayList&lt;AnimatorUpdateListener&gt; mUpdateListeners;</span><br></pre></td></tr></table></figure>
<p>ValueAnimator 在构造时即是通过 PropertyValuesHolder 来完成的。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> ValueAnimator <span class="title">ofPropertyValuesHolder</span><span class="params">(PropertyValuesHolder... values)</span> </span>&#123;</span><br><span class="line">    ValueAnimator anim = <span class="keyword">new</span> ValueAnimator();</span><br><span class="line">    mValuesMap = <span class="keyword">new</span> HashMap&lt;String, PropertyValuesHolder&gt;(numValues);</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; numValues; ++i) &#123;</span><br><span class="line">        PropertyValuesHolder valuesHolder = values[i];</span><br><span class="line">        mValuesMap.put(valuesHolder.getPropertyName(), valuesHolder);</span><br><span class="line">    &#125;    </span><br><span class="line">    <span class="keyword">return</span> anim;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>使用 ofInt 方法构造的 PropertyValuesHolder 属性名为空。对于 ARGB 颜色而言需要 Evaluator。</p>
<p>ObjectAnimator 比 ValueAnimator 就多了一个对象，可以使用反射来提供和接收数值。······················</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> WeakReference&lt;Object&gt; mTarget;</span><br></pre></td></tr></table></figure>
<p>当属性动画启动后的处理如下</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">PropertyValuesHolder[] mValues;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">animateValue</span><span class="params">(<span class="keyword">float</span> fraction)</span> </span>&#123;</span><br><span class="line">    fraction = mInterpolator.getInterpolation(fraction);</span><br><span class="line">    <span class="keyword">int</span> numValues = mValues.length;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; numValues; ++i) &#123;</span><br><span class="line">        mValues[i].calculateValue(fraction);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//mUpdateListeners 回调</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="状态列表动画-StateListAnimator"><a href="#状态列表动画-StateListAnimator" class="headerlink" title="状态列表动画(StateListAnimator)"></a>状态列表动画(StateListAnimator)</h3><p>StateListAnimator 这种动画可以使得 View 在状态切换时启动属性动画，你可以只有使用</p>
<figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">com.lxt.toast.text.FadeText</span>    <span class="attr">android:stateListAnimator</span>=<span class="string">"@animator/test"</span>/&gt;</span></span><br></pre></td></tr></table></figure>
<p>也可以用代码</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">setStateListAnimator(AnimatorInflater.loadStateListAnimator(getContext(), R.animator.test));</span><br></pre></td></tr></table></figure>
<p>所用的 StateListAnimator 可以用XML来定义，标签是 selector。</p>
<figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">selector</span> <span class="attr">xmlns:android</span>=<span class="string">"http://schemas.android.com/apk/res/android"</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">item</span> <span class="attr">android:state_pressed</span>=<span class="string">"true"</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">set</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">objectAnimator</span> <span class="attr">android:propertyName</span>=<span class="string">"translationX"</span></span></span><br><span class="line"><span class="tag">                            <span class="attr">android:duration</span>=<span class="string">"1000"</span></span></span><br><span class="line"><span class="tag">                            <span class="attr">android:valueTo</span>=<span class="string">"200"</span></span></span><br><span class="line"><span class="tag">                            <span class="attr">android:valueType</span>=<span class="string">"floatType"</span>/&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">set</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">item</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">item</span></span></span><br><span class="line"><span class="tag">          <span class="attr">android:state_pressed</span>=<span class="string">"false"</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">set</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">objectAnimator</span> <span class="attr">android:propertyName</span>=<span class="string">"translationX"</span></span></span><br><span class="line"><span class="tag">                            <span class="attr">android:duration</span>=<span class="string">"1000"</span></span></span><br><span class="line"><span class="tag">                            <span class="attr">android:valueTo</span>=<span class="string">"0"</span></span></span><br><span class="line"><span class="tag">                            <span class="attr">android:valueType</span>=<span class="string">"floatType"</span>/&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">set</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">item</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">selector</span>&gt;</span></span><br></pre></td></tr></table></figure>
<h3 id="AnimatedVectorDrawableCompat"><a href="#AnimatedVectorDrawableCompat" class="headerlink" title="AnimatedVectorDrawableCompat"></a>AnimatedVectorDrawableCompat</h3><p>VectorDrawable 在XML解析时会将 path 字符串解析成 VFullPath 对象，包括 PathDataNode 数组和一些绘制信息，由此构建节点树，绘制时先将节点树绘制在缓存 Bitmap 上。</p>
<p>这里谈谈它的动画效果类 AnimatedVectorDrawableCompat，如果要兼容低版本，在XML中使用 <code>app:srcCompat</code>来引用。</p>
<p><strong>1.首先定义VectorDrawable，重点是给 path 标记 name</strong></p>
<figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">vector</span> <span class="attr">xmlns:android</span>=<span class="string">"http://schemas.android.com/apk/res/android"</span></span></span><br><span class="line"><span class="tag">        <span class="attr">android:width</span>=<span class="string">"24dp"</span></span></span><br><span class="line"><span class="tag">        <span class="attr">android:height</span>=<span class="string">"24dp"</span></span></span><br><span class="line"><span class="tag">        <span class="attr">android:viewportHeight</span>=<span class="string">"24.0"</span></span></span><br><span class="line"><span class="tag">        <span class="attr">android:viewportWidth</span>=<span class="string">"24.0"</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">path</span></span></span><br><span class="line"><span class="tag">        <span class="attr">android:name</span>=<span class="string">"end"</span></span></span><br><span class="line"><span class="tag">        <span class="attr">android:fillColor</span>=<span class="string">"#FF000000"</span></span></span><br><span class="line"><span class="tag">        <span class="attr">android:pathData</span>=<span class="string">"M12,12m-3.2,0a3.2,3.2 0,1 1,6.4 0a3.2,3.2 0,1 1,-6.4 0"</span>/&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">path</span></span></span><br><span class="line"><span class="tag">        <span class="attr">android:name</span>=<span class="string">"star"</span></span></span><br><span class="line"><span class="tag">        <span class="attr">android:fillColor</span>=<span class="string">"#FF000000"</span></span></span><br><span class="line"><span class="tag">        <span class="attr">android:pathData</span>=<span class="string">"M9,2L7.17,4H4c-1.1,0 -2,0.9 -2,2v12c0,1.1 0.9,2 2,2h16c1.1,0 2,-0.9 2,-2V6c0,-1.1 -0.9,-2 -2,-2h-3.17L15,2H9zm3,15c-2.76,0 -5,-2.24 -5,-5s2.24,-5 5,-5 5,2.24 5,5 -2.24,5 -5,5z"</span>/&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">vector</span>&gt;</span></span><br></pre></td></tr></table></figure>
<p><strong>2.定义属性动画，注意 trimPathStart 和 trimPathEnd 这两个属性</strong></p>
<figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&lt;?xml version="1.0" encoding="utf-8"?&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">set</span> <span class="attr">xmlns:android</span>=<span class="string">"http://schemas.android.com/apk/res/android"</span></span></span><br><span class="line"><span class="tag">     <span class="attr">android:ordering</span>=<span class="string">"sequentially"</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">objectAnimator</span></span></span><br><span class="line"><span class="tag">        <span class="attr">android:duration</span>=<span class="string">"1000"</span></span></span><br><span class="line"><span class="tag">        <span class="attr">android:propertyName</span>=<span class="string">"trimPathStart"</span></span></span><br><span class="line"><span class="tag">        <span class="attr">android:valueFrom</span>=<span class="string">"1"</span></span></span><br><span class="line"><span class="tag">        <span class="attr">android:valueTo</span>=<span class="string">"0"</span>/&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">objectAnimator</span></span></span><br><span class="line"><span class="tag">        <span class="attr">android:duration</span>=<span class="string">"1000"</span></span></span><br><span class="line"><span class="tag">        <span class="attr">android:propertyName</span>=<span class="string">"trimPathEnd"</span></span></span><br><span class="line"><span class="tag">        <span class="attr">android:valueFrom</span>=<span class="string">"1"</span></span></span><br><span class="line"><span class="tag">        <span class="attr">android:valueTo</span>=<span class="string">"0"</span>/&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">set</span>&gt;</span></span><br></pre></td></tr></table></figure>
<p><strong>3.合成动画Drawable</strong></p>
<figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">animated-vector</span> <span class="attr">xmlns:android</span>=<span class="string">"http://schemas.android.com/apk/res/android"</span>                 <span class="attr">android:drawable</span>=<span class="string">"@drawable/ic_menu_camera"</span>&gt;</span>    <span class="tag">&lt;<span class="name">target</span>        <span class="attr">android:name</span>=<span class="string">"star"</span>  //<span class="attr">path</span> 的 <span class="attr">name</span>        <span class="attr">android:animation</span>=<span class="string">"@animator/alpha"</span>/&gt;</span> // 使用的属性动画    <span class="tag">&lt;<span class="name">target</span>        <span class="attr">android:name</span>=<span class="string">"end"</span>        <span class="attr">android:animation</span>=<span class="string">"@animator/alpha"</span>/&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">animated-vector</span>&gt;</span></span><br></pre></td></tr></table></figure>
<p>最后调用动画</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">(AnimatedVectorDrawableCompat) fab.getDrawable().start();</span><br></pre></td></tr></table></figure>
<h3 id="AnimatorSet"><a href="#AnimatorSet" class="headerlink" title="AnimatorSet"></a>AnimatorSet</h3><p>AnimatorSet 可以多个属性动画设置播放顺序，如顺序播放，并行播放以及延迟播放，其原理是形成这些动画之间的依赖关系。</p>
<p>例如顺序播放的实现如下</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">playSequentially</span><span class="params">(Animator... items)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; items.length - <span class="number">1</span>; ++i) &#123;</span><br><span class="line">         play(items[i]).before(items[i + <span class="number">1</span>]);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>play 方法并不是播放，而是将 Animator 转为 Node 类，Node 定义了其父节点，兄弟节点和子节点集合，以便形成依赖关系</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">Node</span> <span class="keyword">implements</span> <span class="title">Cloneable</span> </span>&#123;</span><br><span class="line">    Animator mAnimation;</span><br><span class="line">    ArrayList&lt;Node&gt; mChildNodes = <span class="keyword">null</span>;</span><br><span class="line">    ArrayList&lt;Node&gt; mSiblings;</span><br><span class="line">    ArrayList&lt;Node&gt; mParents;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>before 方法会在儿子节点集合中添加代表下一个动画的 Node 节点。</p>
<p>并行播放的实现如下</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">playTogether</span><span class="params">(Animator... items)</span> </span>&#123;</span><br><span class="line">    Builder builder = play(items[<span class="number">0</span>]);</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; items.length; ++i) &#123;</span><br><span class="line">        builder.with(items[i]);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>with 方法会在兄弟节点集合中添加代表下一个动画的 Node 节点。</p>
<p>至于 after 方法自然就是添加到父节点集合中去了，此外 after 方法还能够设置延迟，这是通过插入一个时长为 delay 的空动画来实现的。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> Builder <span class="title">after</span><span class="params">(<span class="keyword">long</span> delay)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// setup dummy ValueAnimator just to run the clock</span></span><br><span class="line">    ValueAnimator anim = ValueAnimator.ofFloat(<span class="number">0f</span>, <span class="number">1f</span>);</span><br><span class="line">    anim.setDuration(delay);</span><br><span class="line">    after(anim);</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">this</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>在构建有向图的时候会使用DFS算法初始化依赖树，使用Build的这几个方法能够随心所欲的构建起动画播放顺序。</p>
<h3 id="显露动画-RevealAnimator"><a href="#显露动画-RevealAnimator" class="headerlink" title="显露动画(RevealAnimator)"></a>显露动画(RevealAnimator)</h3><p>ViewAnimationUtils 这个工具类可以用来创建显露动画，这是经过优化的一种动画，可以产生波纹效果。它是一种属性动画，其扩展应用很广泛，这个留在实践部分讲。创建方法如下</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> Animator <span class="title">createCircularReveal</span><span class="params">(View view,</span></span></span><br><span class="line"><span class="function"><span class="params">        <span class="keyword">int</span> centerX,  <span class="keyword">int</span> centerY, <span class="keyword">float</span> startRadius, <span class="keyword">float</span> endRadius)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> RevealAnimator(view, centerX, centerY, startRadius, endRadius);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<blockquote>
<p>注意波纹效果仅在View区域内。</p>
</blockquote>
<h2 id="补间动画-android-view-animation"><a href="#补间动画-android-view-animation" class="headerlink" title="补间动画(android.view.animation)"></a>补间动画(android.view.animation)</h2><p>系统定义的 Animation 确实只有四种，但完全可以通过自定义来扩展。自定义 Animation 需要重写下列方法，如直接改写控件尺寸</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">applyTransformation</span><span class="params">(<span class="keyword">float</span> interpolatedTime, Transformation t)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> newWidth = mStartWidth + (<span class="keyword">int</span>) ((mWidth - mStartWidth) * interpolatedTime);</span><br><span class="line">    mView.getLayoutParams().width = newWidth;</span><br><span class="line">    mView.requestLayout();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><strong>系统定义的 Animation 如 AlphaAnimation 是通过 Transformation 类来完成变换的，不过其功能有限，这里通过引入 View 直接修改参数。</strong></p>
<blockquote>
<p>各种动画的参数值得注意，如 使用百分比。</p>
</blockquote>
<h3 id="布局动画-LayoutAnimationController"><a href="#布局动画-LayoutAnimationController" class="headerlink" title="布局动画(LayoutAnimationController)"></a>布局动画(LayoutAnimationController)</h3><p><strong>布局动画为 ViewGroup 所独有，它能够使得各个View依次按照延迟播放动画</strong>，其构建方法如下</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">LayoutAnimationController</span><span class="params">(Animation animation, <span class="keyword">float</span> delay)</span></span>;</span><br></pre></td></tr></table></figure>
<p>其参数在 View 的布局参数中，<code>AnimationParameters</code> 中包含动画的延迟，默认按照 View 的序号生成。</p>
<p>实际通过延迟发送也能达到这种效果。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; size; i++) &#123;</span><br><span class="line">    <span class="keyword">final</span> <span class="keyword">double</span> delay = <span class="number">3</span> * <span class="number">500</span> * (i / size);</span><br><span class="line">    <span class="keyword">new</span> Handler().postDelayed(animation, delay);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="属性动画的常规使用套路"><a href="#属性动画的常规使用套路" class="headerlink" title="属性动画的常规使用套路"></a>属性动画的常规使用套路</h2><p><strong>某些控件的绘制依赖于一个参数 process(float) 的变化，对其使用属性动画是一个常规套路，能取得什么效果主要取决于 开发者的想象力。</strong><a href="https://github.com/81813780/AVLoadingIndicatorView" target="_blank" rel="noopener">AVLoadingIndicatorView</a>和<a href="https://github.com/nntuyen/mkloader" target="_blank" rel="noopener">MkLoader</a>库就是典型代表。</p>
<p><img src="https://github.com/81813780/AVLoadingIndicatorView/raw/master/screenshots/avi.gif" alt="img"> <img src="https://github.com/nntuyen/mkloader/raw/master/screenshot/screenshot.gif" alt="img"></p>
<ul>
<li>以 ClassicSpinner 的实现为例，基本效果是画8个圆，动画效果是分别播放一个属性动画，但设置延迟，造成透明度不同。</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">ValueAnimator fadeAnimator = ValueAnimator.ofInt(<span class="number">126</span>, <span class="number">255</span>, <span class="number">126</span>);</span><br><span class="line">fadeAnimator.setRepeatCount(ValueAnimator.INFINITE);</span><br><span class="line">fadeAnimator.setDuration(<span class="number">1000</span>);</span><br><span class="line">fadeAnimator.setStartDelay(index * <span class="number">120</span>);</span><br></pre></td></tr></table></figure>
<blockquote>
<p>这里将圆形抽象成Circle类，以便于使用动画。</p>
</blockquote>
<ul>
<li><code>FishSpinner</code>的绘制是5个圆，依次旋转一定角度。动画效果为360度的旋转，视觉效果即通过延迟来达到。</li>
</ul>
<h3 id="更复杂的使用：分段绘制"><a href="#更复杂的使用：分段绘制" class="headerlink" title="更复杂的使用：分段绘制"></a>更复杂的使用：分段绘制</h3><p><strong>将几个 process 控制的绘制过程拼接起来，可以达到更炫的效果。</strong><a href="https://github.com/Ajian-studio/GADownloading" target="_blank" rel="noopener">GADownloading</a>和<a href="https://github.com/android-cjj/JJSearchViewAnim" target="_blank" rel="noopener">JJSearchViewAnim</a>是分段绘制的典型。</p>
<p><img src="https://camo.githubusercontent.com/82e22c4fd86e8de5bcd0ccf4bdcc9dc1a0b7119f/687474703a2f2f7777312e73696e61696d672e636e2f6d773639302f37656630316663616777316632677a797973796772673230616e303568337a622e676966" alt="img"> <img src="https://camo.githubusercontent.com/0856e588a240305d7699a94e1bd9781cbf7e53e1/687474703a2f2f7777312e73696e61696d672e636e2f6d773639302f376566303166636167773166326b66783531366c33673230623530356c6161332e676966" alt="img"></p>
<h2 id="暴露动画的应用"><a href="#暴露动画的应用" class="headerlink" title="暴露动画的应用"></a>暴露动画的应用</h2><p><a href="https://github.com/XunMengWinter/CircularAnim" target="_blank" rel="noopener">CircularAnim</a> 是一个扩展暴露动画的典型例子，<strong>要点在于计算中心点位置和始终半径。</strong></p>
<p><img src="https://cdn.dribbble.com/users/62319/screenshots/1945593/shot.gif" alt="Login &amp; Home Screen ui ux invision app prototyping iphone material gif ae animation mobile login"></p>
<p><strong>注意中心点位置是相对于 view 的坐标位置，可以在view区域之外。这样如果要以另一个View B为动画的中心，就需要计算B的中心点相对与View左上点的位置，并要确保动画半径容纳原 View。</strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span>[] mCL = <span class="keyword">new</span> <span class="keyword">int</span>[<span class="number">2</span>];</span><br><span class="line">mContentLayout.getLocationOnScreen(mCL);</span><br><span class="line"><span class="keyword">int</span>[] mAL = <span class="keyword">new</span> <span class="keyword">int</span>[<span class="number">2</span>];</span><br><span class="line">view.getLocationOnScreen(mAL);</span><br><span class="line"><span class="keyword">int</span> cX = mAL[<span class="number">0</span>] + view.getWidth()/<span class="number">2</span>-mCL[<span class="number">0</span>];</span><br><span class="line"><span class="keyword">int</span> cY = mAL[<span class="number">1</span>] + view.getHeight()/<span class="number">2</span>-mCL[<span class="number">1</span>];</span><br></pre></td></tr></table></figure>
<p><strong>如果要实现全屏效果，可以在 DecorView 上添加一个 ImageView 来完成动画，ImageView 可以任意设置图片或颜色效果，要注意在动画结束后删除这个 ImageView 。</strong></p>
<p>至于图中的效果，是通过隐藏一个ProgressBar来完成的，将TextView的收缩半径设置为ProgressBar的一半高度，动画完成后隐藏 TextView，显示 ProgressBar 即可。</p>
<h3 id="更复杂的暴露动画效果：RippleLayout"><a href="#更复杂的暴露动画效果：RippleLayout" class="headerlink" title="更复杂的暴露动画效果：RippleLayout"></a><a href="https://github.com/liuguangqiang/RippleLayout" target="_blank" rel="noopener">更复杂的暴露动画效果：RippleLayout</a></h3><p>暴露动画实际也是属性动画，将它和其它属性动画结合能产生一些视觉效果。</p>
<p><img src="https://github.com/liuguangqiang/RippleLayout/raw/master/arts/ripple2.gif" alt="RippleLayout"></p>
<p>这里图片上的效果可以分成几部分</p>
<p><strong>1.点击活动A的按钮，开始触发波纹效果，动画结束之后启动活动B</strong></p>
<p><strong>2.活动B的布局分为上下两层，分别执行TransitionY动画。</strong></p>
<p>与之类似，点击返回键，将反向播放内容布局动画和波纹动画。</p>
<h3 id="入屏动画"><a href="#入屏动画" class="headerlink" title="入屏动画"></a><a href="https://github.com/geftimov/android-player" target="_blank" rel="noopener">入屏动画</a></h3><p><img src="https://github.com/geftimov/android-player/raw/master/art/sample_one.gif" alt="img"></p>
<p>这是一个属性动画的封装库，能够流式的使用属性动画，但无法取消以前的动画，只能用作入屏动画。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">PropertyAction fabAction = PropertyAction.newPropertyAction(fab).scaleX(<span class="number">0</span>).scaleY(<span class="number">0</span>).duration(<span class="number">750</span>).build();</span><br><span class="line">Player.init().</span><br><span class="line">        animate(headerAction).</span><br><span class="line">        then().</span><br><span class="line">        animate(fabAction).</span><br><span class="line">        then().</span><br><span class="line">        animate(bottomAction).</span><br><span class="line">        play();</span><br></pre></td></tr></table></figure>
<h3 id="FabulousFilter"><a href="#FabulousFilter" class="headerlink" title="FabulousFilter"></a><a href="https://github.com/Krupen/FabulousFilter" target="_blank" rel="noopener">FabulousFilter</a></h3><p><img src="https://raw.githubusercontent.com/Krupen/FabulousFilter/master/concept.gif" alt="img"></p>

        
      
    </div>

    
    
    
      <footer class="post-footer">
          <div class="post-eof"></div>
        
      </footer>
  </div>
  
  
  
  </article>

    
        <article itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block home">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2017/07/26/android/View/与 ImageView 有关的知识点/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="xiang">
      <meta itemprop="description" content="谨守而勿失，是谓反其真">
      <meta itemprop="image" content="/images/1.jpg">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="lxt">
    </span>
      <header class="post-header">
        <h1 class="post-title" itemprop="name headline">
            
            <a href="/2017/07/26/android/View/与 ImageView 有关的知识点/" class="post-title-link" itemprop="url">与 ImageView 有关的知识点</a>
          
        </h1>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              
                
              

              <time title="创建时间：2017-07-26 12:18:29" itemprop="dateCreated datePublished" datetime="2017-07-26T12:18:29+08:00">2017-07-26</time>
            </span>
          
            

            
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="fa fa-calendar-check-o"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2019-09-18 14:56:46" itemprop="dateModified" datetime="2019-09-18T14:56:46+08:00">2019-09-18</time>
              </span>
            
          
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing"><a href="/categories/android/" itemprop="url" rel="index"><span itemprop="name">android</span></a></span>

                
                
                  ，
                
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing"><a href="/categories/android/View/" itemprop="url" rel="index"><span itemprop="name">View</span></a></span>

                
                
              
            </span>
          

          
          <br>
            <span class="post-meta-item" title="本文字数">
              <span class="post-meta-item-icon">
                <i class="fa fa-file-word-o"></i>
              </span>
              
                <span class="post-meta-item-text">本文字数：</span>
              
              <span>7.6k</span>
            </span>
          
            <span class="post-meta-item" title="阅读时长">
              <span class="post-meta-item-icon">
                <i class="fa fa-clock-o"></i>
              </span>
              
                <span class="post-meta-item-text">阅读时长 &asymp;</span>
              
              <span>7 分钟</span>
            </span>
          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h2 id="ImageView"><a href="#ImageView" class="headerlink" title="ImageView"></a>ImageView</h2><p><strong>ImageView 的核心功能是显示 Drawable</strong>，因此其核心方法是</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setImageDrawable</span><span class="params">(@Nullable Drawable drawable)</span></span></span><br></pre></td></tr></table></figure>
<p><strong>传入新的 Drawable 对象后，会配置其各种属性，包括 level，state，染色，Bounds等。</strong></p>
<p>onDraw 方法就是对 Drawable 对象的绘制，但有两点要注意</p>
<ul>
<li>Matrix 通过左乘对 canvas 产生影响 ,可以用于图片处理</li>
<li>mCropToPadding 通过 canvas 的 clipRect 方法将对显示区域做截取， 并将 padding 纳入 Drawable 的Bound计算</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">canvas.save();</span><br><span class="line"><span class="keyword">if</span> (mCropToPadding) &#123;</span><br><span class="line">    canvas.clipRect(scrollX + mPaddingLeft, scrollY + mPaddingTop,</span><br><span class="line">            scrollX + mRight - mLeft - mPaddingRight,</span><br><span class="line">            scrollY + mBottom - mTop - mPaddingBottom);</span><br><span class="line">&#125;</span><br><span class="line">canvas.translate(mPaddingLeft, mPaddingTop);</span><br><span class="line">canvas.concat(mDrawMatrix);</span><br><span class="line">mDrawable.draw(canvas);</span><br><span class="line">canvas.restoreToCount(saveCount);</span><br></pre></td></tr></table></figure>
<blockquote>
<p>如果设置了 mCropToPadding 为 true，则滚动ImageView</p>
</blockquote>
<h3 id="ImageButton与-FloatingActionButton"><a href="#ImageButton与-FloatingActionButton" class="headerlink" title="ImageButton与 FloatingActionButton"></a>ImageButton与 FloatingActionButton</h3><p>子类 ImageButton 虽然名为 “Button”，却不是 TextView，而是 ImageView，只不过它用了与 Button 相同的背景</p>
<figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">item</span> <span class="attr">name</span>=<span class="string">"background"</span>&gt;</span>@drawable/btn_default<span class="tag">&lt;/<span class="name">item</span>&gt;</span></span><br></pre></td></tr></table></figure>
<p>子类 FloatingActionButton 的特别之处在于它强制定义了背景 Drawable，其默认配置如下</p>
<figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">style</span> <span class="attr">name</span>=<span class="string">"Widget.Design.FloatingActionButton"</span> <span class="attr">parent</span>=<span class="string">"android:Widget"</span>&gt;</span></span><br><span class="line"><span class="xml">    <span class="tag">&lt;<span class="name">item</span> <span class="attr">name</span>=<span class="string">"android:background"</span>&gt;</span>@drawable/design_fab_background<span class="tag">&lt;/<span class="name">item</span>&gt;</span> //白色的圆形 shapedrawable</span></span><br><span class="line"><span class="xml">    <span class="tag">&lt;<span class="name">item</span> <span class="attr">name</span>=<span class="string">"backgroundTint"</span>&gt;</span>?attr/colorAccent<span class="tag">&lt;/<span class="name">item</span>&gt;</span> // 背景的渲染色是 colorAccent</span></span><br><span class="line"><span class="xml">    <span class="tag">&lt;<span class="name">item</span> <span class="attr">name</span>=<span class="string">"fabSize"</span>&gt;</span>normal<span class="tag">&lt;/<span class="name">item</span>&gt;</span></span></span><br><span class="line"><span class="xml">    <span class="tag">&lt;<span class="name">item</span> <span class="attr">name</span>=<span class="string">"elevation"</span>&gt;</span>@dimen/design_fab_elevation<span class="tag">&lt;/<span class="name">item</span>&gt;</span>					  // 6dp</span></span><br><span class="line"><span class="xml">    <span class="tag">&lt;<span class="name">item</span> <span class="attr">name</span>=<span class="string">"pressedTranslationZ"</span>&gt;</span>@dimen/design_fab_translation_z_pressed<span class="tag">&lt;/<span class="name">item</span>&gt;</span> // 6dp</span></span><br><span class="line"><span class="xml">    <span class="tag">&lt;<span class="name">item</span> <span class="attr">name</span>=<span class="string">"rippleColor"</span>&gt;</span>?attr/colorControlHighlight<span class="tag">&lt;/<span class="name">item</span>&gt;</span></span></span><br><span class="line"><span class="xml">    <span class="tag">&lt;<span class="name">item</span> <span class="attr">name</span>=<span class="string">"borderWidth"</span>&gt;</span>@dimen/design_fab_border_width<span class="tag">&lt;/<span class="name">item</span>&gt;</span>				   // 0.5dp</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">style</span>&gt;</span></span><br></pre></td></tr></table></figure>
<p>然而实际的背景并不是简单地 ShapeDrawable，还要考虑描边和ripple的效果，其实现在不同的版本各不相同。</p>
<h3 id="绘制形状的改造"><a href="#绘制形状的改造" class="headerlink" title="绘制形状的改造"></a>绘制形状的改造</h3><p><a href="https://github.com/hdodenhof/CircleImageView" target="_blank" rel="noopener">圆形控件:CircleImageView</a>库实现了圆形图片，实际是重新实现了 ImageView 的绘制方法，它的绘制原理是从 Drawable 中提取出位图 Bitmap 对象，而后使用其作为 BitmapShader 的像素源，绘制圆形图片。</p>
<p>它的具体实现如下</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">onDraw</span><span class="params">(Canvas canvas)</span> </span>&#123;</span><br><span class="line">  </span><br><span class="line">    <span class="comment">//1.获取 Drawable</span></span><br><span class="line">    Drawable drawable = getDrawable();</span><br><span class="line">  </span><br><span class="line">    <span class="comment">//2.提取 Bitmap</span></span><br><span class="line">    Bitmap bitmap = Bitmap.createBitmap(drawable.getIntrinsicWidth(), drawable.getIntrinsicHeight(), ARGB_8888);</span><br><span class="line">    Canvas c = <span class="keyword">new</span> Canvas(bitmap);</span><br><span class="line">    drawable.setBounds(<span class="number">0</span>, <span class="number">0</span>, c.getWidth(), c.getHeight());</span><br><span class="line">    drawable.draw(c);</span><br><span class="line">    <span class="comment">//3.生成 BitmapShader 以配置 Paint</span></span><br><span class="line">    BitmapShader bitmapShader = <span class="keyword">new</span> BitmapShader(bitmap, CLAMP, CLAMP);</span><br><span class="line">    Paint bitmapPaint = <span class="keyword">new</span> Paint(Paint.ANTI_ALIAS_FLAG);</span><br><span class="line">    bitmapPaint.setShader(bitmapShader);</span><br><span class="line">  </span><br><span class="line">    <span class="comment">//4.计算尺寸和位置，完成最后绘制</span></span><br><span class="line">    <span class="keyword">int</span> width = getWidth() - getPaddingLeft() - getPaddingRight();</span><br><span class="line">    <span class="keyword">int</span> height = getHeight() - getPaddingTop() - getPaddingBottom();</span><br><span class="line">    <span class="keyword">int</span> radius = Math.min(width / <span class="number">2</span>, height / <span class="number">2</span>);</span><br><span class="line">    <span class="keyword">int</span> centerX = getPaddingLeft() + width / <span class="number">2</span>;</span><br><span class="line">    <span class="keyword">int</span> centerY = getPaddingTop() + height / <span class="number">2</span>;</span><br><span class="line">    canvas.drawCircle(centerX, centerY, radius, bitmapPaint);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<blockquote>
<p>实际上这也可以通过 canvas 的 clipPath 方法来实现，但截取操作在底层开销比较大，宜使用 Shader 方法。</p>
<p>v4 包中的 CircleImageView 专门用作下拉刷新控件，它的背景 Drawable 设置为圆形的 ShapeDrawable，内容 Drawable 设置为带动画效果的箭头 Drawable。</p>
</blockquote>
<p><a href="https://github.com/vinc3m1/RoundedImageView" target="_blank" rel="noopener">RoundedImageView</a>库实现圆角图片，其实现原理与上面的 CircleImageView 类似，以(0,0,200,200)为区域，半径为 20 的圆角矩形为例，最终实现方法是</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">draw</span><span class="params">(@NonNull Canvas canvas)</span> </span>&#123;</span><br><span class="line">  BitmapShader bitmapShader = <span class="keyword">new</span> BitmapShader(mBitmap, mTileModeX, mTileModeY);</span><br><span class="line">  <span class="comment">//...</span></span><br><span class="line">  canvas.drawRoundRect(mDrawableRect, radius, radius, mBitmapPaint);</span><br><span class="line">  redrawBitmapForSquareCorners(canvas);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<img src="/2017/07/26/android/View/与%20ImageView%20有关的知识点/6874.png">
<p>只是绘制由圆形变成了圆角矩形而已，但是如何只绘制单个原角呢？这里的做法是重绘，例如左上角，重绘的区域即(0,0,20,20)的矩形，将这部分的位图重绘出来就行了。如果是边界，则重绘线段。</p>
<blockquote>
<p>这里的问题是发生了重绘，在有三个圆角的情况下最为糟糕，因此应该避免这种情况。如果自己实现，可以将矩形区域划分的细一些，以便一次绘制完毕。<strong>也可以采用 Shape 的做法，通过构建路径的方式来实现。</strong></p>
</blockquote>
<h3 id="绘制内容的添加"><a href="#绘制内容的添加" class="headerlink" title="绘制内容的添加"></a>绘制内容的添加</h3><p>绘制内容的添加即在 ImageView 之上进行扩展绘制。</p>
<p><a href="https://github.com/HeZaiJin/SlantedTextView" target="_blank" rel="noopener">SlantedTextView</a>库的效果可以采用额外绘制的方法实现。</p>
<img src="/2017/07/26/android/View/与%20ImageView%20有关的知识点/screenshot.png">
<p><a href="https://github.com/zagum/Android-SwitchIcon" target="_blank" rel="noopener">SwitchIcon</a>库的效果如下</p>
<img src="/2017/07/26/android/View/与%20ImageView%20有关的知识点/sample.gif">
<p>该库所做的额外绘制稍显复杂，包括</p>
<ul>
<li>绘制斜线状态</li>
<li>达成动画效果</li>
<li>颜色渲染</li>
</ul>
<p>1.斜线是通过 Paint 绘制 Line 来实现的，其起始点在</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">dashXStart = getPaddingLeft() + <span class="number">0.5f</span> * SIN_45 * dashThickness;</span><br><span class="line">dashYStart = getPaddingTop() + <span class="number">1.5f</span> * SIN_45 * dashThickness;</span><br></pre></td></tr></table></figure>
<p>结束点在</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">dashEnd.x = (<span class="keyword">int</span>) (dashXStart + width - delta1);</span><br><span class="line">dashEnd.y = (<span class="keyword">int</span>) (dashYStart + height - delta2);</span><br></pre></td></tr></table></figure>
<p>这样斜线就是从左上向右下逐渐延伸的。</p>
<p>2.斜线的延伸由参数 friction 控制，除此之外，friction 还控制渲染的颜色，透明度的变化。这里原本的 drawable 变色是通过构建新的 PorterDuffColorFilter 来完成的，而斜线的颜色是通过Paint来设置的。</p>
<p>3.这里还有最后一个问题：就是斜线和原 Drawable 的重叠，其解决方法如下</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">onDraw</span><span class="params">(Canvas canvas)</span> </span>&#123;</span><br><span class="line">  drawDash(canvas);</span><br><span class="line">  canvas.clipPath(clipPath, Region.Op.XOR); </span><br><span class="line">  <span class="keyword">super</span>.onDraw(canvas);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这里 clipPath 覆盖斜线，并略微大于斜线，值得注意的是区域截取的方式采用的是 XOR，这保证了Canvas 将在斜线区域之外绘制原 Drawable。</p>
<h3 id="动画效果"><a href="#动画效果" class="headerlink" title="动画效果"></a>动画效果</h3><p><a href="https://github.com/Q42/AndroidScrollingImageView" target="_blank" rel="noopener">AndroidScrollingImageView</a>这种效果实际是视差造成的，动的是背景图，实际绘制的是多个 Bitmap，通过设置 offset 参数造成偏移效果，并通过控制此值形成动画效果。最终效果实际上与背景素材有关，不同的素材可以设置不同的回退速度。</p>
<img src="/2017/07/26/android/View/与%20ImageView%20有关的知识点/sample_app.png">
<p><a href="https://github.com/flavioarfaria/KenBurnsView" target="_blank" rel="noopener">KenBurnsView</a> 库实现 Ken Burns 效果，即景深效果，</p>
<img src="/2017/07/26/android/View/与%20ImageView%20有关的知识点/anim.gif">
<p>首先确定控件的尺寸和Bitmap尺寸是不一致的，后者要大于前者。在 Bitmap 尺寸范围内截取一个空间尺寸大小的区域，同时显示区域用动画移位过去，就是 Ken Burns 效果。</p>
<p>效果的实现与位置形状矩阵 Matrix 有关，这里需要将ScaleType类型设置为MATRIX</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">super</span>.setScaleType(ImageView.ScaleType.MATRIX);</span><br></pre></td></tr></table></figure>
<p>这里移位采用 Matrix 来完成，动画由 mProcess 参数来控制。</p>
<h3 id="图像处理"><a href="#图像处理" class="headerlink" title="图像处理"></a>图像处理</h3><p>图像处理主要依赖于颜色矩阵(ColorMatrix)来实现。</p>
<h4 id="ColorMatrix"><a href="#ColorMatrix" class="headerlink" title="ColorMatrix"></a>ColorMatrix</h4><p>ColorMatrix 是一个 4*5 的矩阵，4行分别代表red，green，blue和alpha向量，默认是单位阵。在实现上采用的是float数组来存储这些数据。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ColorMatrix</span> </span>&#123;    </span><br><span class="line">	<span class="keyword">private</span> <span class="keyword">final</span> <span class="keyword">float</span>[] mArray = <span class="keyword">new</span> <span class="keyword">float</span>[<span class="number">20</span>];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>最简单的操作像素颜色变化的方法是 setScale，它只改变了对角线的上的数据，这样颜色的各个分量独立的进行变化</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setScale</span><span class="params">(<span class="keyword">float</span> rScale, <span class="keyword">float</span> gScale, <span class="keyword">float</span> bScale, <span class="keyword">float</span> aScale)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">final</span> <span class="keyword">float</span>[] a = mArray;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">19</span>; i &gt; <span class="number">0</span>; --i) &#123;</span><br><span class="line">        a[i] = <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    a[<span class="number">0</span>] = rScale;</span><br><span class="line">    a[<span class="number">6</span>] = gScale;</span><br><span class="line">    a[<span class="number">12</span>] = bScale;</span><br><span class="line">    a[<span class="number">18</span>] = aScale;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="StyleImageView-库可以进行图像的处理。"><a href="#StyleImageView-库可以进行图像的处理。" class="headerlink" title="StyleImageView 库可以进行图像的处理。"></a><a href="https://github.com/chengdazhi/StyleImageView" target="_blank" rel="noopener">StyleImageView</a> 库可以进行图像的处理。</h4><img src="/2017/07/26/android/View/与%20ImageView%20有关的知识点/style_sample.gif">
<p>图像Bitmap由像素构成，像素又包括对比度(Contrast)，亮度(Brightness)，纯度(saturation)等参数，图片的重叠还涉及混合模式(Mode)。修改这些信息主要通过颜色矩阵(ColorMatrix)来完成。</p>
<p>关于构建 marix 的方法如下</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">float</span>[] calculateMatrix(<span class="keyword">int</span> mode, <span class="keyword">int</span> brightness, <span class="keyword">float</span> contrast, <span class="keyword">float</span> saturation) &#123;</span><br><span class="line">    <span class="keyword">return</span> applyBrightnessAndContrast(getMatrixByMode(mode, saturation), brightness, contrast);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">float</span>[] applyBrightnessAndContrast(<span class="keyword">float</span>[] matrix, <span class="keyword">int</span> brightness, <span class="keyword">float</span> contrast) &#123;</span><br><span class="line">    <span class="keyword">float</span> t = (<span class="number">1.0F</span> - contrast) / <span class="number">2.0F</span> * <span class="number">255.0F</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">3</span>; i++) &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j = i * <span class="number">5</span>; j &lt; i * <span class="number">5</span> + <span class="number">3</span>; j++) &#123;</span><br><span class="line">            matrix[j] *= contrast;</span><br><span class="line">        &#125;</span><br><span class="line">        matrix[<span class="number">5</span> * i + <span class="number">4</span>] += t + brightness;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> matrix;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>正常情况下直接改变像素颜色</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">final</span> <span class="keyword">float</span>[] matrix = calculateMatrix(mode, brightness, contrast, saturation);</span><br><span class="line">drawableHolder.getDrawable().setColorFilter(<span class="keyword">new</span> ColorMatrixColorFilter(<span class="keyword">new</span> ColorMatrix(matrix)));</span><br></pre></td></tr></table></figure>
<p>如果要在改变时形成动画，则需要利用颜色矩阵中的float数组作为起始值，并利用值动画来更新。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">updateStyle</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">final</span> <span class="keyword">float</span>[] matrix = calculateMatrix(mode, brightness, contrast, saturation);</span><br><span class="line">    <span class="keyword">if</span> (enableAnimation) &#123;</span><br><span class="line">        animateMatrix(oldMatrix, matrix, <span class="keyword">new</span> AnimatorListenerAdapter() &#123;</span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onAnimationEnd</span><span class="params">(Animator animation)</span> </span>&#123;</span><br><span class="line">                <span class="keyword">super</span>.onAnimationEnd(animation);</span><br><span class="line">                setDrawableStyleByMatrix(matrix);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">animateMatrix</span><span class="params">(<span class="keyword">final</span> <span class="keyword">float</span>[] startMatrix, <span class="keyword">final</span> <span class="keyword">float</span>[] endMatrix, AnimatorListenerAdapter onAnimationEndListener)</span> </span>&#123;</span><br><span class="line">    animator = ValueAnimator.ofFloat(<span class="number">0F</span>, <span class="number">1F</span>).setDuration(animationDuration);</span><br><span class="line">    animator.addUpdateListener(<span class="keyword">new</span> ValueAnimator.AnimatorUpdateListener() &#123;</span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onAnimationUpdate</span><span class="params">(ValueAnimator valueAnimator)</span> </span>&#123;</span><br><span class="line">            <span class="keyword">float</span>[] result = <span class="keyword">new</span> <span class="keyword">float</span>[<span class="number">20</span>];</span><br><span class="line">            <span class="keyword">float</span> fraction = valueAnimator.getAnimatedFraction();</span><br><span class="line">            <span class="keyword">float</span> progress = interpolator.getInterpolation(fraction);</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">20</span>; i++) &#123;</span><br><span class="line">                result[i] = (startMatrix[i] * (<span class="number">1</span> - progress)) + (endMatrix[i] * progress);</span><br><span class="line">            &#125;</span><br><span class="line">            drawableHolder.getDrawable().setColorFilter(<span class="keyword">new</span> ColorMatrixColorFilter(<span class="keyword">new</span> ColorMatrix(matrix))); </span><br><span class="line">        &#125;</span><br><span class="line">    &#125;);</span><br><span class="line">    animator.addListener(onAnimationEndListener);</span><br><span class="line">    animator.start();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

        
      
    </div>

    
    
    
      <footer class="post-footer">
          <div class="post-eof"></div>
        
      </footer>
  </div>
  
  
  
  </article>

    
        <article itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block home">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2017/07/24/android/View/与 Drawable 相关的知识点/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="xiang">
      <meta itemprop="description" content="谨守而勿失，是谓反其真">
      <meta itemprop="image" content="/images/1.jpg">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="lxt">
    </span>
      <header class="post-header">
        <h1 class="post-title" itemprop="name headline">
            
            <a href="/2017/07/24/android/View/与 Drawable 相关的知识点/" class="post-title-link" itemprop="url">与 Drawable 相关的知识点</a>
          
        </h1>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              
                
              

              <time title="创建时间：2017-07-24 14:28:29" itemprop="dateCreated datePublished" datetime="2017-07-24T14:28:29+08:00">2017-07-24</time>
            </span>
          
            

            
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="fa fa-calendar-check-o"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2019-09-18 14:49:20" itemprop="dateModified" datetime="2019-09-18T14:49:20+08:00">2019-09-18</time>
              </span>
            
          
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing"><a href="/categories/android/" itemprop="url" rel="index"><span itemprop="name">android</span></a></span>

                
                
                  ，
                
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing"><a href="/categories/android/View/" itemprop="url" rel="index"><span itemprop="name">View</span></a></span>

                
                
              
            </span>
          

          
          <br>
            <span class="post-meta-item" title="本文字数">
              <span class="post-meta-item-icon">
                <i class="fa fa-file-word-o"></i>
              </span>
              
                <span class="post-meta-item-text">本文字数：</span>
              
              <span>11k</span>
            </span>
          
            <span class="post-meta-item" title="阅读时长">
              <span class="post-meta-item-icon">
                <i class="fa fa-clock-o"></i>
              </span>
              
                <span class="post-meta-item-text">阅读时长 &asymp;</span>
              
              <span>10 分钟</span>
            </span>
          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h2 id="Drawable"><a href="#Drawable" class="headerlink" title="Drawable"></a>Drawable</h2><p>Drawable 是绘制的基础单元，但它没有事件机制，不想 View 那么复杂。Drawable 的基本机制或属性包括</p>
<ul>
<li><strong>使用 Bound 和 Padding 确定绘制的范围</strong> , 且 <strong>Drawable 必须确定 Bound</strong></li>
<li>使用 Outline 确定轮廓，默认情况下与 Bound 相同</li>
<li><strong>使用 State 记录状态</strong></li>
<li><strong>使用 Level(0-10000) 赋予一定的动态性，如定义变化中的进度条等</strong></li>
<li>使用 Callback 回调接口实现动画效果，与 View 的 invalidate() 方法配合使用</li>
<li><strong>绘制机制，需要实现抽象的 draw 方法</strong></li>
</ul>
<p>例如子类 BitmapDrawable 的绘制方法是绘制 Bitmap，且通过Bitmap来确定 Bound 和 Outline，其额外的属性(如抗锯齿等)均通过设置 Paint 对象和 Shader 对象来生效。</p>
<p>再比如子类 ColorDrawable 的本质是使用指定颜色绘制矩形。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">draw</span><span class="params">(Canvas canvas)</span> </span>&#123;</span><br><span class="line">    mPaint.setColor(mColorState.mUseColor);</span><br><span class="line">    canvas.drawRect(getBounds(), mPaint);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<blockquote>
<p>这些 Drawable 也可以用 XML 文件定义的，系统最终要使用 XML解析器将其解析成 Drawable 对象。</p>
</blockquote>
<p>关于绘制，Drawable 还有以下效果设置</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@IntRange</span>(from=<span class="number">0</span>,to=<span class="number">255</span>) <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">getAlpha</span><span class="params">()</span></span>;		<span class="comment">//1.透明度</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setXfermode</span><span class="params">(@Nullable Xfermode mode)</span></span>;   <span class="comment">//2. Xfermode</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="keyword">void</span> <span class="title">setColorFilter</span><span class="params">(@Nullable ColorFilter colorFilter)</span></span>;   <span class="comment">//3.ColorFilter</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setTint</span><span class="params">(@ColorInt <span class="keyword">int</span> tintColor)</span></span>;   <span class="comment">//4.染色</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setTintList</span><span class="params">(@Nullable ColorStateList tint)</span>   <span class="comment">//4.染色 ColorStateList</span></span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setHotspot</span><span class="params">(<span class="keyword">float</span> x, <span class="keyword">float</span> y)</span></span>;   <span class="comment">//5.热点</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setHotspotBounds</span><span class="params">(<span class="keyword">int</span> left, <span class="keyword">int</span> top, <span class="keyword">int</span> right, <span class="keyword">int</span> bottom)</span></span>;  <span class="comment">//5.热点区域 </span></span><br><span class="line"><span class="keyword">public</span> <span class="meta">@Nullable</span> <span class="function">Region <span class="title">getTransparentRegion</span><span class="params">()</span></span>;   <span class="comment">//6.透明区域</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="meta">@PixelFormat</span>.<span class="function">Opacity <span class="keyword">int</span> <span class="title">getOpacity</span><span class="params">()</span></span>;    <span class="comment">//7.设置像素格式，如是否包含表示透明度的bit</span></span><br><span class="line"><span class="keyword">public</span> <span class="meta">@NonNull</span> <span class="function">Drawable <span class="title">getCurrent</span><span class="params">()</span></span>;    <span class="comment">//8.在 Drawable 容器中获取 Drawable</span></span><br></pre></td></tr></table></figure>
<h3 id="GradientDrawable与ShapeDrawable"><a href="#GradientDrawable与ShapeDrawable" class="headerlink" title="GradientDrawable与ShapeDrawable"></a>GradientDrawable与ShapeDrawable</h3><p>GradientDrawable 可以绘制四种类型，并带有渐变和圆角特征，它与ShapeDrawable类似。</p>
<p>ShapeDrawable 即绘制“形状”，其绘制实际是“形状”对象(Shape)来代理</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">draw</span><span class="params">(Canvas canvas)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">final</span> Rect r = getBounds();</span><br><span class="line">    <span class="keyword">final</span> ShapeState state = mShapeState;</span><br><span class="line">    <span class="keyword">final</span> Paint paint = state.mPaint;</span><br><span class="line">    <span class="keyword">final</span> <span class="keyword">int</span> count = canvas.save();</span><br><span class="line">    canvas.translate(r.left, r.top);</span><br><span class="line">    shape.draw(canvas, paint);</span><br><span class="line">    canvas.restoreToCount(count);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>Shape 的基本形状是 RectShape ，其绘制实现如下</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">draw</span><span class="params">(Canvas canvas, Paint paint)</span> </span>&#123;</span><br><span class="line">    canvas.drawRect(mRect, paint);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>如果设置了 corners 标签，则使用子类 PaintDrawable 来解析</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setCornerRadii</span><span class="params">(<span class="keyword">float</span>[] radii)</span> </span>&#123;</span><br><span class="line">    setShape(<span class="keyword">new</span> RoundRectShape(radii, <span class="keyword">null</span>, <span class="keyword">null</span>));</span><br><span class="line">    invalidateSelf();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><strong>可见四角是通过圆角矩形这个形状(RoundRectShape)来实现的， 这个将在 Path 中详细讲。</strong></p>
<h3 id="DrawableWrapper"><a href="#DrawableWrapper" class="headerlink" title="DrawableWrapper"></a>DrawableWrapper</h3><p>DrawableWrapper 表示对单个 Drawable 的包装，类似于装饰器模式。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="class"><span class="keyword">class</span> <span class="title">DrawableWrapper</span> <span class="keyword">extends</span> <span class="title">Drawable</span> <span class="keyword">implements</span> <span class="title">Drawable</span>.<span class="title">Callback</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> DrawableWrapperState mState;</span><br><span class="line">    <span class="keyword">private</span> Drawable mDrawable;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>对 DrawableWrapper 的设置实际上都在处理被包装的 Drawable，包括最终的绘制</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">draw</span><span class="params">(@NonNull Canvas canvas)</span> </span>&#123;</span><br><span class="line">    mDrawable.draw(canvas);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li>InsetDrawable 实际是通过 padding 来实现缩进的。</li>
<li>ScaleDrawable 实际会按照比例重新计算 Bound</li>
<li>RotateDrawable 很容易想到旋转是通过 canvas 来实现的。</li>
<li><strong>ClipDrawable 主要要指定剪切的方向和 level，其绘制与 level 有关，需要该值计算出边界，再用canvas 的 clipRect() 方法来裁剪它。</strong></li>
</ul>
<h3 id="DrawableContainer"><a href="#DrawableContainer" class="headerlink" title="DrawableContainer"></a>DrawableContainer</h3><p>DrawableContainer 表示 Drawable 的集合，但只显示一张，同样是装饰器模式。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">draw</span><span class="params">(Canvas canvas)</span> </span>&#123;</span><br><span class="line">        mCurrDrawable.draw(canvas);</span><br><span class="line">        mLastDrawable.draw(canvas);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>关于如何在众多 Drawable 中选择一张，DrawableContainer 有如下子类</p>
<ol>
<li><strong>LevelListDrawable</strong></li>
</ol>
<figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">level-list</span> <span class="attr">xmlns:android</span>=<span class="string">"http://schemas.android.com/apk/res/android"</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">item</span> <span class="attr">android:drawable</span>=<span class="string">"@drawable/checked"</span> <span class="attr">android:minLevel</span>=<span class="string">"0"</span> <span class="attr">android:maxLevel</span>=<span class="string">"100"</span> /&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">item</span> <span class="attr">android:drawable</span>=<span class="string">"@drawable/checked"</span> <span class="attr">android:minLevel</span>=<span class="string">"100"</span> <span class="attr">android:maxLevel</span>=<span class="string">"200"</span> /&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">level-list</span>&gt;</span></span><br></pre></td></tr></table></figure>
<p>LevelListDrawable 中挑选的标准是 level 值的大小，每一个 Drawable 对象指定一个范围，显示 level 值落入范围的 Drawable 对象。</p>
<ol>
<li><strong>StateListDrawable</strong> 同理显示状态相符的 Drawable 对象。</li>
<li><strong>AnimationDrawabl</strong>e 即帧动画，用多个 Drawable 对象产生动画效果。</li>
</ol>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">start</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    mAnimating = <span class="keyword">true</span>;</span><br><span class="line">    <span class="keyword">if</span> (!mRunning) &#123;</span><br><span class="line">        selectDrawable(frame); </span><br><span class="line">        scheduleSelf(<span class="keyword">this</span>, SystemClock.uptimeMillis() + mAnimationState.mDurations[frame]);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这里帧会进行帧的步进，并触发 drawable 的动画刷新机制，直到播放完成。</p>
<h3 id="LayerDrawable"><a href="#LayerDrawable" class="headerlink" title="LayerDrawable"></a>LayerDrawable</h3><p>LayerDrawable 维持一个 Drawable 数组，并全部显示，但下标最大的那个显示最完全，构造方法如下</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">LayerDrawable</span><span class="params">(@NonNull Drawable[] layers)</span></span></span><br></pre></td></tr></table></figure>
<p>绘制方法如下</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">draw</span><span class="params">(Canvas canvas)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">final</span> ChildDrawable[] array = mLayerState.mChildren;</span><br><span class="line">    <span class="keyword">final</span> <span class="keyword">int</span> N = mLayerState.mNum;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; N; i++) &#123;</span><br><span class="line">        <span class="keyword">final</span> Drawable dr = array[i].mDrawable;</span><br><span class="line">        <span class="keyword">if</span> (dr != <span class="keyword">null</span>) &#123;</span><br><span class="line">            dr.draw(canvas);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这样可以通过为某一层设置 Padding 来进行层叠显示，如果设置合理，可以显示全部的 Drawable 。</p>
<h4 id="TransitionDrawable"><a href="#TransitionDrawable" class="headerlink" title="TransitionDrawable"></a><strong>TransitionDrawable</strong></h4><p><strong>TransitionDrawable 是一个仅有两层的LayerDrawable，可以在切换时播放动画，一般用作切换动画。</strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">startTransition</span><span class="params">(<span class="keyword">int</span> durationMillis)</span> </span>&#123;</span><br><span class="line">    mFrom = <span class="number">0</span>;</span><br><span class="line">    mTo = <span class="number">255</span>;</span><br><span class="line">    mAlpha = <span class="number">0</span>;</span><br><span class="line">    mDuration = mOriginalDuration = durationMillis;</span><br><span class="line">    mReverse = <span class="keyword">false</span>;</span><br><span class="line">    mTransitionState = TRANSITION_STARTING;</span><br><span class="line">    invalidateSelf();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>该方法设置的动画是关于透明度的，且起始值是255和0，如果要启用交叉透明效果，首先设置</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setCrossFadeEnabled</span><span class="params">(<span class="keyword">boolean</span> enabled)</span></span></span><br></pre></td></tr></table></figure>
<p>在绘制方法 draw 中通过时间的流逝计算 alpha 值</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">float</span> normalized = (<span class="keyword">float</span>)(SystemClock.uptimeMillis() - mStartTimeMillis) / mDuration;</span><br><span class="line">done = normalized &gt;= <span class="number">1.0f</span>;</span><br><span class="line">normalized = Math.min(normalized, <span class="number">1.0f</span>);</span><br><span class="line">mAlpha = (<span class="keyword">int</span>) (mFrom  + (mTo - mFrom) * normalized);</span><br></pre></td></tr></table></figure>
<p>如果时间流逝完，就将第1张显示出来，且停止刷新和动画，否则显示第0张。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (done) &#123;</span><br><span class="line">    <span class="keyword">if</span> (!crossFade || alpha == <span class="number">0</span>) &#123;</span><br><span class="line">        array[<span class="number">0</span>].mDrawable.draw(canvas);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (alpha == <span class="number">0xFF</span>) &#123;</span><br><span class="line">        array[<span class="number">1</span>].mDrawable.draw(canvas);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>如果时间没有流逝完，配置二者的透明度，并继续刷新出动画效果。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">array[<span class="number">0</span>].mDrawable.setAlpha(<span class="number">255</span> - alpha);</span><br><span class="line">array[<span class="number">1</span>].mDrawable.setAlpha(alpha);</span><br></pre></td></tr></table></figure>
<h4 id="RippleDrawable"><a href="#RippleDrawable" class="headerlink" title="RippleDrawable"></a>RippleDrawable</h4><p>最简单的添加 Ripple 效果的方法是采用如下属性</p>
<figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">android:background="?attr/selectableItemBackground"</span><br></pre></td></tr></table></figure>
<p>RippleDrawable 的XML标签为 ripple。</p>
<figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">ripple</span> <span class="attr">xmlns:android</span>=<span class="string">"http://schemas.android.com/apk/res/android"</span></span></span><br><span class="line"><span class="tag">    <span class="attr">android:color</span>=<span class="string">"@color/colorAccent"</span>             //触摸波纹颜色</span></span><br><span class="line"><span class="tag">    <span class="attr">android:radius</span>=<span class="string">"30dp"</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">item</span> <span class="attr">android:drawable</span>=<span class="string">"@android:color/white"</span>  //蒙版颜色</span></span><br><span class="line"><span class="tag">          <span class="attr">android:id</span>=<span class="string">"@android:id/mask"</span> /&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">item</span> <span class="attr">android:drawable</span>=<span class="string">"@color/colorPrimary"</span> /&gt;</span> //View 默认颜色</span><br><span class="line"><span class="tag">&lt;/<span class="name">ripple</span>&gt;</span></span><br></pre></td></tr></table></figure>
<p>注意这里有三种颜色，注意<strong>ripple下的color标签将被解析成 ColorStateList 类，这样 RippleDrawable 将可以对状态改变做出波纹效果的响应</strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">RippleDrawable</span><span class="params">(@NonNull ColorStateList color, @Nullable Drawable content,</span></span></span><br><span class="line"><span class="function"><span class="params">        @Nullable Drawable mask)</span> </span>&#123;</span><br><span class="line">    addLayer(content, <span class="keyword">null</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>);</span><br><span class="line">    addLayer(mask, <span class="keyword">null</span>, android.R.id.mask, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>从构造方法可以看出，子类 RippleDrawable 包含两个 Drawable：content 和 mask，后者的 id 是 android.R.id.mask。</p>
<p>当状态改变发生时，将构建 RippleForeground[] 和 RippleBackground 以备绘制。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">boolean</span> <span class="title">onStateChange</span><span class="params">(<span class="keyword">int</span>[] stateSet)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">final</span> <span class="keyword">boolean</span> changed = <span class="keyword">super</span>.onStateChange(stateSet);</span><br><span class="line">    <span class="keyword">boolean</span> enabled = <span class="keyword">false</span>;</span><br><span class="line">    <span class="keyword">boolean</span> pressed = <span class="keyword">false</span>;</span><br><span class="line">    <span class="keyword">boolean</span> focused = <span class="keyword">false</span>;</span><br><span class="line">    <span class="keyword">boolean</span> hovered = <span class="keyword">false</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> state : stateSet) &#123;</span><br><span class="line">        <span class="keyword">if</span> (state == R.attr.state_enabled) &#123;</span><br><span class="line">            enabled = <span class="keyword">true</span>;</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (state == R.attr.state_focused) &#123;</span><br><span class="line">            focused = <span class="keyword">true</span>;</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (state == R.attr.state_pressed) &#123;</span><br><span class="line">            pressed = <span class="keyword">true</span>;</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (state == R.attr.state_hovered) &#123;</span><br><span class="line">            hovered = <span class="keyword">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    setRippleActive(enabled &amp;&amp; pressed);</span><br><span class="line">    setBackgroundActive(hovered || focused || (enabled &amp;&amp; pressed), focused || hovered);</span><br><span class="line">    <span class="keyword">return</span> changed;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>draw 绘制的方法先绘制内容，而后绘制 ripple 效果。</p>
<p>1.绘制内容是正常的 Drawable 绘制，但避免绘制 mask 这一层</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">drawContent</span><span class="params">(Canvas canvas)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// Draw everything except the mask.</span></span><br><span class="line">    <span class="keyword">final</span> ChildDrawable[] array = mLayerState.mChildren;</span><br><span class="line">    <span class="keyword">final</span> <span class="keyword">int</span> count = mLayerState.mNum;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; count; i++) &#123;</span><br><span class="line">        <span class="keyword">if</span> (array[i].mId != R.id.mask) &#123;</span><br><span class="line">            array[i].mDrawable.draw(canvas);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>2.绘制背景以及 Ripple 效果。</p>
<p>Ripple 效果是使用 Shader 来实现的，并将 mask 层绘制到同尺寸的 Bitmap 上去。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">final</span> <span class="keyword">int</span> color = mState.mColor.getColorForState(getState(), Color.BLACK);</span><br><span class="line"><span class="keyword">final</span> <span class="keyword">int</span> halfAlpha = (Color.alpha(color) / <span class="number">2</span>) &lt;&lt; <span class="number">24</span>;</span><br><span class="line"><span class="keyword">final</span> Paint p = getRipplePaint();</span><br><span class="line">p.setColor(halfAlpha);</span><br><span class="line">p.setShader(mMaskShader);</span><br><span class="line">mBackground.draw(canvas, p);</span><br><span class="line">mRipple.draw(canvas, p);</span><br></pre></td></tr></table></figure>
<h2 id="重新认识-Canvas，Path和Paint"><a href="#重新认识-Canvas，Path和Paint" class="headerlink" title="重新认识 Canvas，Path和Paint"></a>重新认识 Canvas，Path和Paint</h2><h3 id="Canvas"><a href="#Canvas" class="headerlink" title="Canvas"></a>Canvas</h3><p>Canvas 记录绘制命令，使用下列方法能够将命令入栈</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">save</span><span class="params">()</span></span>;</span><br></pre></td></tr></table></figure>
<p>而后再将命令出栈，这样就恢复到了 save 时的状态，其中的命令和状态改变就被丢弃</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">restore</span><span class="params">()</span></span>;</span><br></pre></td></tr></table></figure>
<p>Canvas 的各种命令不再多说，只谈一个应该注意的方法</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">clipRect</span><span class="params">(@NonNull Rect rect)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">clipRect</span><span class="params">(@NonNull Rect rect, @NonNull Region.Op op)</span></span>;</span><br></pre></td></tr></table></figure>
<p>这个方法将截取某个区域来显示，其中 Op 表示区域间的叠加方式。</p>
<p>依靠 canvas.clipRect 方法实现的一个典型的例子是 <a href="https://github.com/hongyangAndroid/ColorTrackView" target="_blank" rel="noopener">ColorTrackView</a></p>
<img src="/2017/07/24/android/View/与%20Drawable%20相关的知识点/sc.gif">
<p>核心代码非常简单如下</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">canvas.drawText(<span class="string">"秦时明月汉时关"</span>, centerX, centerY, mPaint);</span><br><span class="line">canvas.clipRect(<span class="number">0</span>, <span class="number">0</span>, getBounds().width()*ratio, getBounds().height());</span><br><span class="line">canvas.drawText(<span class="string">"秦时明月汉时关"</span>, centerX, centerY, mColorPaint);</span><br><span class="line">invalidateSelf();</span><br></pre></td></tr></table></figure>
<h3 id="Path"><a href="#Path" class="headerlink" title="Path"></a>Path</h3><p>Canvas 的另一个方法 clipPath 能实现的效果更多</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">clipPath</span><span class="params">(@NonNull Path path)</span></span></span><br></pre></td></tr></table></figure>
<img src="/2017/07/24/android/View/与%20Drawable%20相关的知识点/crop_inside.png">
<p>上图中的 ArcNavigationView 就是通过创造 Path 绘制出来的，利用这一点可以将控件改造成任意形状，这里以经典的圆形图片为例，只需要重写绘制方法就可以了</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">onDraw</span><span class="params">(Canvas canvas)</span> </span>&#123;</span><br><span class="line">    canvas.clipPath(mPath);</span><br><span class="line">    <span class="keyword">super</span>.onDraw(canvas);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><strong>唯一值得注意的是 Path 的建立位置是不能放在构造方法中的，这个时刻是不能获得控件尺寸的，因此应该将其放在 layout 方法中</strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">onLayout</span><span class="params">(<span class="keyword">boolean</span> changed, <span class="keyword">int</span> left, <span class="keyword">int</span> top, <span class="keyword">int</span> right, <span class="keyword">int</span> bottom)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">super</span>.onLayout(changed, left, top, right, bottom);</span><br><span class="line">    <span class="keyword">if</span>(changed)&#123;</span><br><span class="line">        mPath = <span class="keyword">new</span> Path();</span><br><span class="line">        <span class="keyword">int</span> width = getWidth();</span><br><span class="line">        <span class="keyword">int</span> height = getHeight();</span><br><span class="line">        <span class="keyword">int</span> radius = Math.min(width/<span class="number">2</span>, height/<span class="number">2</span>);</span><br><span class="line">        mPath.addCircle(getWidth()/<span class="number">2</span>, getHeight()/<span class="number">2</span>, radius, Path.Direction.CW);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>Path 的构建方法包括</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">moveTo</span><span class="params">(<span class="keyword">float</span> x, <span class="keyword">float</span> y)</span></span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">lineTo</span><span class="params">(<span class="keyword">float</span> x, <span class="keyword">float</span> y)</span></span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">quadTo</span><span class="params">(<span class="keyword">float</span> x1, <span class="keyword">float</span> y1, <span class="keyword">float</span> x2, <span class="keyword">float</span> y2)</span></span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">cubicTo</span><span class="params">(<span class="keyword">float</span> x1, <span class="keyword">float</span> y1, <span class="keyword">float</span> x2, <span class="keyword">float</span> y2, <span class="keyword">float</span> x3, <span class="keyword">float</span> y3)</span></span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">arcTo</span><span class="params">(<span class="keyword">float</span> left, <span class="keyword">float</span> top, <span class="keyword">float</span> right, <span class="keyword">float</span> bottom, <span class="keyword">float</span> startAngle, <span class="keyword">float</span> sweepAngle, <span class="keyword">boolean</span> forceMoveTo)</span></span></span><br></pre></td></tr></table></figure>
<p>Path 也可以通过添加形状来构建</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">addRect</span><span class="params">(<span class="keyword">float</span> left, <span class="keyword">float</span> top, <span class="keyword">float</span> right, <span class="keyword">float</span> bottom, Direction dir)</span> <span class="comment">// 使用OP.UNION</span></span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">addOval</span><span class="params">(<span class="keyword">float</span> left, <span class="keyword">float</span> top, <span class="keyword">float</span> right, <span class="keyword">float</span> bottom, Direction dir)</span></span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">addCircle</span><span class="params">(<span class="keyword">float</span> x, <span class="keyword">float</span> y, <span class="keyword">float</span> radius, Direction dir)</span></span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">addArc</span><span class="params">(<span class="keyword">float</span> left, <span class="keyword">float</span> top, <span class="keyword">float</span> right, <span class="keyword">float</span> bottom, <span class="keyword">float</span> start, <span class="keyword">float</span> sweep)</span>  </span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">addRoundRect</span><span class="params">(<span class="keyword">float</span> left, <span class="keyword">float</span> top, <span class="keyword">float</span> right, <span class="keyword">float</span> bottom, <span class="keyword">float</span> rx, <span class="keyword">float</span> ry, Direction dir)</span>  </span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">addPath</span><span class="params">(Path src, <span class="keyword">float</span> dx, <span class="keyword">float</span> dy)</span></span></span><br></pre></td></tr></table></figure>
<p><strong>Path 内部包含区域(Region)，如何合并两个 Path 包括如下方式</strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">enum</span> Op &#123;</span><br><span class="line">    DIFFERENCE, <span class="comment">// PathA - PathB</span></span><br><span class="line">    INTERSECT, <span class="comment">// 二者的交集</span></span><br><span class="line">    UNION, <span class="comment">// PathA + PathB</span></span><br><span class="line">    XOR, <span class="comment">// UNION - INTERSECT</span></span><br><span class="line">    REVERSE_DIFFERENCE <span class="comment">// PathB - PathA</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>Path 的另一个主要方法是路径偏移</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">offset</span><span class="params">(<span class="keyword">float</span> dx, <span class="keyword">float</span> dy)</span></span></span><br></pre></td></tr></table></figure>
<h3 id="Paint"><a href="#Paint" class="headerlink" title="Paint"></a>Paint</h3><p>1.获取文字区域 Rect</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">getTextBounds</span><span class="params">(String text, <span class="keyword">int</span> start, <span class="keyword">int</span> end, Rect bounds)</span></span></span><br></pre></td></tr></table></figure>
<p>2.获取文字路径 Path</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">getTextPath</span><span class="params">(String text, <span class="keyword">int</span> start, <span class="keyword">int</span> end, <span class="keyword">float</span> x, <span class="keyword">float</span> y, Path path)</span></span></span><br></pre></td></tr></table></figure>
<blockquote>
<p>使用画笔获取文字路径后，可以使用 Path 的偏移方法调整其位置。</p>
</blockquote>
<p>3.画笔的众多 flag 效果，如添加下划线效果</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setUnderlineText</span><span class="params">(<span class="keyword">boolean</span> underlineText)</span></span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> STRIKE_THRU_TEXT_FLAG </span>= <span class="number">0x10</span>;</span><br></pre></td></tr></table></figure>
<p>4.字体参数 FontMetrics，使用 ascent+descent 可以获得偏移量</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">FontMetrics</span> </span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">float</span>   top;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">float</span>   ascent; <span class="comment">//baseline到字顶，负值</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">float</span>   descent; <span class="comment">//baseline到字底，正值</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">float</span>   bottom;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">float</span>   leading;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>5.获得文本宽度</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">float</span> <span class="title">measureText</span><span class="params">(String text)</span></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> measureText(text, <span class="number">0</span>, text.length());</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//设置最大文本宽度</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">breakText</span><span class="params">(String text, <span class="keyword">boolean</span> measureForwards, loat maxWidth, <span class="keyword">float</span>[] measuredWidth)</span> </span>&#123;&#125;</span><br></pre></td></tr></table></figure>

        
      
    </div>

    
    
    
      <footer class="post-footer">
          <div class="post-eof"></div>
        
      </footer>
  </div>
  
  
  
  </article>

    
        <article itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block home">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2017/07/23/android/View/与 TextView 相关的知识点/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="xiang">
      <meta itemprop="description" content="谨守而勿失，是谓反其真">
      <meta itemprop="image" content="/images/1.jpg">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="lxt">
    </span>
      <header class="post-header">
        <h1 class="post-title" itemprop="name headline">
            
            <a href="/2017/07/23/android/View/与 TextView 相关的知识点/" class="post-title-link" itemprop="url">与 TextView 相关的知识点</a>
          
        </h1>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              
                
              

              <time title="创建时间：2017-07-23 14:28:29" itemprop="dateCreated datePublished" datetime="2017-07-23T14:28:29+08:00">2017-07-23</time>
            </span>
          
            

            
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="fa fa-calendar-check-o"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2019-09-18 14:38:01" itemprop="dateModified" datetime="2019-09-18T14:38:01+08:00">2019-09-18</time>
              </span>
            
          
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing"><a href="/categories/android/" itemprop="url" rel="index"><span itemprop="name">android</span></a></span>

                
                
                  ，
                
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing"><a href="/categories/android/View/" itemprop="url" rel="index"><span itemprop="name">View</span></a></span>

                
                
              
            </span>
          

          
          <br>
            <span class="post-meta-item" title="本文字数">
              <span class="post-meta-item-icon">
                <i class="fa fa-file-word-o"></i>
              </span>
              
                <span class="post-meta-item-text">本文字数：</span>
              
              <span>9.4k</span>
            </span>
          
            <span class="post-meta-item" title="阅读时长">
              <span class="post-meta-item-icon">
                <i class="fa fa-clock-o"></i>
              </span>
              
                <span class="post-meta-item-text">阅读时长 &asymp;</span>
              
              <span>9 分钟</span>
            </span>
          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h2 id="TextView以及其子类"><a href="#TextView以及其子类" class="headerlink" title="TextView以及其子类"></a>TextView以及其子类</h2><p>先说两个小知识</p>
<p><strong>1.TextView 实现跑马灯效果</strong></p>
<figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">TextView</span></span></span><br><span class="line"><span class="tag">    <span class="attr">android:singleLine</span>=<span class="string">"true"</span>            // 必须</span></span><br><span class="line"><span class="tag">    <span class="attr">android:marqueeRepeatLimit</span>=<span class="string">"marquee_forever"</span>  //是否永远循环</span></span><br><span class="line"><span class="tag">    <span class="attr">android:focusable</span>=<span class="string">"true"</span>             // 必须</span></span><br><span class="line"><span class="tag">    <span class="attr">android:focusableInTouchMode</span>=<span class="string">"true"</span>  // 必须 </span></span><br><span class="line"><span class="tag">    <span class="attr">android:ellipsize</span>=<span class="string">"marquee"</span>"/&gt;</span>       // 必须</span><br></pre></td></tr></table></figure>
<p><strong>2.TextView 的字体设置</strong><br>字体设置可以在 fonts.xml 文件中查找，其定义如下</p>
<figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">family</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">nameset</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">name</span>&gt;</span>cursive<span class="tag">&lt;/<span class="name">name</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">nameset</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">fileset</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">file</span>&gt;</span>DancingScript-Regular.ttf<span class="tag">&lt;/<span class="name">file</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">file</span>&gt;</span>DancingScript-Bold.ttf<span class="tag">&lt;/<span class="name">file</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">fileset</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">family</span>&gt;</span></span><br></pre></td></tr></table></figure>
<p>使用时指定名称就可以了</p>
<figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">app:family="casual"  //这是一个 string 类型的属性</span><br></pre></td></tr></table></figure>
<p>读取该值后可以创建字体</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Typeface.create(mFamily, Typeface.NORMAL)</span><br></pre></td></tr></table></figure>
<h3 id="TextView的绘制：Layout"><a href="#TextView的绘制：Layout" class="headerlink" title="TextView的绘制：Layout"></a>TextView的绘制：Layout</h3><p>TextView 在绘制时会先绘制四边的 drawable 。</p>
<figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">android:drawableLeft="@drawable/left"</span><br><span class="line">android:drawableTop="@drawable/top"</span><br><span class="line">android:drawableBottom="@drawable/bottom"</span><br><span class="line">android:drawableRight="@drawable/right"</span><br></pre></td></tr></table></figure>
<p>其余的绘制工作就交给 Layout 类了，正常情况下采用 StaticLayout，而 EditText 采用 DynamicLayout。</p>
<p>Layout 负责文本的布局和绘制，绘制效果取决于构造它的诸多参数</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> text the text to render</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> paint the default paint for the layout.  Styles can override</span></span><br><span class="line"><span class="comment"> * various attributes of the paint.</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> width the wrapping width for the text.</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> align whether to left, right, or center the text.  Styles can</span></span><br><span class="line"><span class="comment"> * override the alignment.</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> spacingMult factor by which to scale the font size to get the</span></span><br><span class="line"><span class="comment"> * default line spacing</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> spacingAdd amount to add to the default line spacing</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">protected</span> <span class="title">Layout</span><span class="params">(CharSequence text, TextPaint paint,</span></span></span><br><span class="line"><span class="function"><span class="params">                 <span class="keyword">int</span> width, Alignment align, TextDirectionHeuristic textDir,</span></span></span><br><span class="line"><span class="function"><span class="params">                 <span class="keyword">float</span> spacingMult, <span class="keyword">float</span> spacingAdd)</span></span></span><br></pre></td></tr></table></figure>
<p>绘制方法包括两步，即按行绘制文本即行背景。</p>
<p>Layout 有很多获取和设置布局的信息，如</p>
<p><strong>1.获得某画笔类TextPaint下的文本宽度</strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">float</span> <span class="title">getDesiredWidth</span><span class="params">(CharSequence source, <span class="keyword">int</span> start, <span class="keyword">int</span> end, TextPaint paint)</span></span></span><br></pre></td></tr></table></figure>
<p><strong>2.获得文本行数以及某一行的信息</strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">getLineCount</span><span class="params">()</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">getLineTop</span><span class="params">(<span class="keyword">int</span> line)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">getLineDescent</span><span class="params">(<span class="keyword">int</span> line)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="keyword">int</span> <span class="title">getLineStart</span><span class="params">(<span class="keyword">int</span> line)</span></span>;</span><br></pre></td></tr></table></figure>
<p>实际上完全可以覆盖掉默认的绘制方法，利用Layout实现绘制效果，如</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">onDraw</span><span class="params">(Canvas canvas)</span> </span>&#123;</span><br><span class="line">    <span class="comment">//super.onDraw(canvas);</span></span><br><span class="line">    Layout layout = getLayout();</span><br><span class="line">    <span class="keyword">int</span> count = layout.getLineCount();</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; count; i++) &#123;</span><br><span class="line">        <span class="keyword">float</span> lineLeft = layout.getLineLeft(i);</span><br><span class="line">        <span class="keyword">float</span> lineBaseline = layout.getLineBaseline(i);</span><br><span class="line">        String lineText = getText().subSequence(lineStart, lineEnd).toString();</span><br><span class="line">        canvas.drawText(lineText, lineLeft, lineBaseline, getPaint());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<blockquote>
<p>这个效果和默认的绘制效果至少看上去完全一致(实际丢失了对marquee标记的处理)，使用 Layout 还能够达成更多效果。</p>
</blockquote>
<h3 id="EditText"><a href="#EditText" class="headerlink" title="EditText"></a>EditText</h3><p>EditText 实际上完完全全就是 TextView，只不过它采用的样式如下</p>
<figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">style</span> <span class="attr">name</span>=<span class="string">"Widget.EditText"</span>&gt;</span></span><br><span class="line"><span class="xml">    <span class="tag">&lt;<span class="name">item</span> <span class="attr">name</span>=<span class="string">"focusable"</span>&gt;</span>true<span class="tag">&lt;/<span class="name">item</span>&gt;</span></span></span><br><span class="line"><span class="xml">    <span class="tag">&lt;<span class="name">item</span> <span class="attr">name</span>=<span class="string">"focusableInTouchMode"</span>&gt;</span>true<span class="tag">&lt;/<span class="name">item</span>&gt;</span></span></span><br><span class="line"><span class="xml">    <span class="tag">&lt;<span class="name">item</span> <span class="attr">name</span>=<span class="string">"clickable"</span>&gt;</span>true<span class="tag">&lt;/<span class="name">item</span>&gt;</span></span></span><br><span class="line"><span class="xml">    <span class="tag">&lt;<span class="name">item</span> <span class="attr">name</span>=<span class="string">"background"</span>&gt;</span>?attr/editTextBackground<span class="tag">&lt;/<span class="name">item</span>&gt;</span></span></span><br><span class="line"><span class="xml">    <span class="tag">&lt;<span class="name">item</span> <span class="attr">name</span>=<span class="string">"textAppearance"</span>&gt;</span>?attr/textAppearanceMediumInverse<span class="tag">&lt;/<span class="name">item</span>&gt;</span></span></span><br><span class="line"><span class="xml">    <span class="tag">&lt;<span class="name">item</span> <span class="attr">name</span>=<span class="string">"textColor"</span>&gt;</span>?attr/editTextColor<span class="tag">&lt;/<span class="name">item</span>&gt;</span></span></span><br><span class="line"><span class="xml">    <span class="tag">&lt;<span class="name">item</span> <span class="attr">name</span>=<span class="string">"gravity"</span>&gt;</span>center_vertical<span class="tag">&lt;/<span class="name">item</span>&gt;</span></span></span><br><span class="line"><span class="xml">    <span class="tag">&lt;<span class="name">item</span> <span class="attr">name</span>=<span class="string">"breakStrategy"</span>&gt;</span>simple<span class="tag">&lt;/<span class="name">item</span>&gt;</span></span></span><br><span class="line"><span class="xml">    <span class="tag">&lt;<span class="name">item</span> <span class="attr">name</span>=<span class="string">"hyphenationFrequency"</span>&gt;</span>normal<span class="tag">&lt;/<span class="name">item</span>&gt;</span></span></span><br><span class="line"><span class="tag">&lt;/<span class="name">style</span>&gt;</span></span><br></pre></td></tr></table></figure>
<p>其背景 drawable 在正常状态下是白色的.9图（@drawable/textfield_default），通过设置如下属性 TextView 亦可以选择文本供剪贴板使用</p>
<figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">android:textIsSelectable="true"</span><br></pre></td></tr></table></figure>
<p>TextView 和 EditText 所得的文本为 EditText 类，这是一个继承了很多文本处理接口的类，功能强大，例如可以设置过滤器 InputFilter，数字输入框，号码框就是靠其实现的。</p>
<blockquote>
<p>AutoCompleteTextView 继承 EditText ，本是一个带 PopupWindow(带 ListView) 的 EditText，获取焦点时显示 PopupWindow。</p>
</blockquote>
<h3 id="Button"><a href="#Button" class="headerlink" title="Button"></a>Button</h3><p>Button 实际上也完完全全就是 TextView，只不过它使用了默认的样式，改变了外观，所采用的样式可以在 themes 文件中找到，如下</p>
<figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">style</span> <span class="attr">name</span>=<span class="string">"Widget.Button"</span>&gt;</span></span><br><span class="line"><span class="xml">    <span class="tag">&lt;<span class="name">item</span> <span class="attr">name</span>=<span class="string">"background"</span>&gt;</span>@drawable/btn_default<span class="tag">&lt;/<span class="name">item</span>&gt;</span></span></span><br><span class="line"><span class="xml">    <span class="tag">&lt;<span class="name">item</span> <span class="attr">name</span>=<span class="string">"focusable"</span>&gt;</span>true<span class="tag">&lt;/<span class="name">item</span>&gt;</span></span></span><br><span class="line"><span class="xml">    <span class="tag">&lt;<span class="name">item</span> <span class="attr">name</span>=<span class="string">"clickable"</span>&gt;</span>true<span class="tag">&lt;/<span class="name">item</span>&gt;</span></span></span><br><span class="line"><span class="xml">    <span class="tag">&lt;<span class="name">item</span> <span class="attr">name</span>=<span class="string">"textAppearance"</span>&gt;</span>?attr/textAppearanceSmallInverse<span class="tag">&lt;/<span class="name">item</span>&gt;</span></span></span><br><span class="line"><span class="xml">    <span class="tag">&lt;<span class="name">item</span> <span class="attr">name</span>=<span class="string">"textColor"</span>&gt;</span>@color/primary_text_light<span class="tag">&lt;/<span class="name">item</span>&gt;</span></span></span><br><span class="line"><span class="xml">    <span class="tag">&lt;<span class="name">item</span> <span class="attr">name</span>=<span class="string">"gravity"</span>&gt;</span>center_vertical|center_horizontal<span class="tag">&lt;/<span class="name">item</span>&gt;</span></span></span><br><span class="line"><span class="tag">&lt;/<span class="name">style</span>&gt;</span></span><br></pre></td></tr></table></figure>
<p>其中影响按钮外观最大的就是背景 Drawable，默认情况下为一个 SelectDrawable，在正常状态下是灰色的.9图(位于res\drawable-mdpi.btn_default_normal.9.png)，并在不同的状态/主题下采用不同颜色的.9图。</p>
<p><strong>android 默认提供了很多按钮的 style</strong>，如</p>
<figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">style="?android:attr/imageButtonStyle"</span><br></pre></td></tr></table></figure>
<h4 id="CompoundButton"><a href="#CompoundButton" class="headerlink" title="CompoundButton"></a>CompoundButton</h4><p>CompoundButton 是一种特殊的 Button，从功能上将它只有两种状态，即是否 isChecked；从实现上看，它采用了新 Drawable 来表示 checked 状态，并重写了 onDraw 方法。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">onDraw</span><span class="params">(Canvas canvas)</span> </span>&#123;</span><br><span class="line">	<span class="comment">//1.首先绘制 TextView 和 背景 Drawable</span></span><br><span class="line">    <span class="keyword">super</span>.onDraw(canvas);</span><br><span class="line">    buttonDrawable.setBounds(left, top, right, bottom);</span><br><span class="line">    <span class="comment">//2.再绘制 buttonDrawable，注意这里的 trick，要处理 scrollX/scrollY</span></span><br><span class="line">    <span class="keyword">if</span> (buttonDrawable != <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="keyword">final</span> <span class="keyword">int</span> scrollX = mScrollX;</span><br><span class="line">        <span class="keyword">final</span> <span class="keyword">int</span> scrollY = mScrollY;</span><br><span class="line">        <span class="keyword">if</span> (scrollX == <span class="number">0</span> &amp;&amp; scrollY == <span class="number">0</span>) &#123;</span><br><span class="line">            buttonDrawable.draw(canvas);</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            canvas.translate(scrollX, scrollY);</span><br><span class="line">            buttonDrawable.draw(canvas);</span><br><span class="line">            canvas.translate(-scrollX, -scrollY);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>因此我们知道改变 CompoundButton 既可以改变其外观，在XML上属性为</p>
<figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">android:button="@null" // 即buttonDrawable为空</span><br></pre></td></tr></table></figure>
<p>在 java 代码上</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setButtonDrawable</span><span class="params">(@DrawableRes <span class="keyword">int</span> resId)</span></span></span><br></pre></td></tr></table></figure>
<p>子类 CheckBox玩玩全全就是 CompoundButton，另一个子类 Switch 则较为复杂。</p>
<p>发生点击事件后处理如下</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">performClick</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    toggle();</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">super</span>.performClick();</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">toggle</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    setChecked(!mChecked);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="Switch"><a href="#Switch" class="headerlink" title="Switch"></a>Switch</h4><p>Switch 上除了 button 参数，另有两个 drawable，底层的叫 “track”，上层的叫“thumb”，上层面积是底层的一半左右，通过遮盖和移位来表示 checked 状态。此外 checked 时的文本叫做 “textOn”，而反之叫做 “textOff”。</p>
<blockquote>
<p>注意此时 Button Drawable 依然有效。</p>
</blockquote>
<p>在实现上，除了重写 onDraw 方法外，还要处理 “thumb” 区域的触摸事件，以完成状态切换。</p>
<p>因为“thumb” 是飘在 “track”上左右移动的，因此切换的动画是用属性动画完成的。</p>
<h2 id="一些与-Text-相关的库"><a href="#一些与-Text-相关的库" class="headerlink" title="一些与 Text 相关的库"></a>一些与 Text 相关的库</h2><h3 id="集大成者-HTextView"><a href="#集大成者-HTextView" class="headerlink" title="集大成者 : HTextView"></a><a href="https://github.com/hanks-zyh/HTextView" target="_blank" rel="noopener"><strong>集大成者 : HTextView</strong></a></h3><p>HTextView 这个库实现的效果华丽，代码的风格和扩展性也非常好，而且作者将不同的效果仅仅分包，引入某种效果的体积极小，实在是不可多得的优质库。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="class"><span class="keyword">class</span> <span class="title">HTextView</span> <span class="keyword">extends</span> <span class="title">TextView</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="keyword">void</span> <span class="title">setProgress</span><span class="params">(<span class="keyword">float</span> progress)</span></span>;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="keyword">void</span> <span class="title">animateText</span><span class="params">(CharSequence text)</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<img src="/2017/07/23/android/View/与%20TextView%20相关的知识点/demo7.gif">
<p>1.Line 效果实质是在文本之外定点，描边，画线，这是附加性质的绘制。</p>
<img src="/2017/07/23/android/View/与%20TextView%20相关的知识点/fade.gif">
<p>2.Fade 效果是自发绘制文本，这里要利用 TextView 中 Layout 这个类。首先**均匀的挑出透明的字符位置，组成 alphaList。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">drawFrame</span><span class="params">(Canvas canvas)</span> </span>&#123;</span><br><span class="line">    Layout layout = mHTextView.getLayout();</span><br><span class="line">    <span class="keyword">int</span> gapIndex = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; layout.getLineCount(); i++) &#123;</span><br><span class="line">        <span class="keyword">int</span> lineStart = layout.getLineStart(i);</span><br><span class="line">        <span class="keyword">int</span> lineEnd = layout.getLineEnd(i);</span><br><span class="line">        <span class="keyword">float</span> lineLeft = layout.getLineLeft(i);</span><br><span class="line">        <span class="keyword">float</span> lineBaseline = layout.getLineBaseline(i);</span><br><span class="line">        String lineText = mText.subSequence(lineStart, lineEnd).toString();</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> c = <span class="number">0</span>; c &lt; lineText.length(); c++) &#123;</span><br><span class="line">            <span class="keyword">int</span> alpha = alphaList.get(gapIndex);</span><br><span class="line">            mPaint.setAlpha((<span class="keyword">int</span>) ((<span class="number">255</span> - alpha) * progress + alpha));</span><br><span class="line">            String str = lineText.substring(j, j+<span class="number">1</span>);</span><br><span class="line">            canvas.drawText(str, lineLeft, lineBaseline, mPaint);</span><br><span class="line">            lineLeft += getPaint().measureText(str);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>
<blockquote>
<p>这里要准确测量每一个字符的宽度。</p>
</blockquote>
<img src="/2017/07/23/android/View/与%20TextView%20相关的知识点/typer.gif">
<p>3.打字机效果的实现十分简单</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setProgress</span><span class="params">(<span class="keyword">float</span> progress)</span> </span>&#123;</span><br><span class="line">    setText(mText.subSequence(<span class="number">0</span>, (<span class="keyword">int</span>) (mText.length() * progress)));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<img src="/2017/07/23/android/View/与%20TextView%20相关的知识点/rainbow.gif">
<p>4.彩虹效果：通过操作Shader的矩阵完成染色。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">onDraw</span><span class="params">(Canvas canvas)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (mMatrix == <span class="keyword">null</span>) &#123;</span><br><span class="line">        mMatrix = <span class="keyword">new</span> Matrix();</span><br><span class="line">    &#125;</span><br><span class="line">    mTranslate += colorSpeed;</span><br><span class="line">    mMatrix.setTranslate(mTranslate, <span class="number">0</span>);</span><br><span class="line">    mLinearGradient.setLocalMatrix(mMatrix);</span><br><span class="line">    <span class="keyword">super</span>.onDraw(canvas);</span><br><span class="line">    postInvalidateDelayed(<span class="number">100</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<img src="/2017/07/23/android/View/与%20TextView%20相关的知识点/demo3.gif">
<p>5.Scale 效果：利用 Layout 重新定义了绘制方法，以重绘新旧字符串。重复的字符移位，其余的收缩。以下两种情况亦然。</p>
<img src="/2017/07/23/android/View/与%20TextView%20相关的知识点/demo6.gif">
<h3 id="Shimmer"><a href="#Shimmer" class="headerlink" title="Shimmer"></a><a href="https://github.com/facebook/shimmer-android" target="_blank" rel="noopener">Shimmer</a></h3><img src="/2017/07/23/android/View/与%20TextView%20相关的知识点/shimmer.gif">
<p>一般情况下闪光效果和 HTextView 一样是采用渐变的效果达成的，对画笔进行设置，使渐变的位置发生偏移，即产生闪光效果。这里只需要改变 Paint 取像素的方式即可</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">mGradient.setLocalMatrix(mMatrix);</span><br><span class="line">getPaint().setShader(mGradient);</span><br></pre></td></tr></table></figure>
<blockquote>
<p>这里将原生画笔的像素提供方式改变了，它只与绘制的内容文本有关，与背景没有干扰。如果要取消闪光效果，可以将其设为null。</p>
</blockquote>
<p>但要达到较好的效果还需要</p>
<p>1.仔细的设置渐变的参数，渐变的设置如下</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">mGradient = <span class="keyword">new</span> LinearGradient(getWidth(), <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>,</span><br><span class="line">        <span class="keyword">new</span> <span class="keyword">int</span>[]&#123;</span><br><span class="line">                getCurrentTextColor(), </span><br><span class="line">                <span class="number">0xFFFFFFFF</span>, </span><br><span class="line">                getCurrentTextColor()&#125;,</span><br><span class="line">        <span class="keyword">new</span> <span class="keyword">float</span>[]&#123;<span class="number">0</span>, <span class="number">0.5f</span>, <span class="number">1</span>&#125;, </span><br><span class="line">        Shader.TileMode.CLAMP);</span><br></pre></td></tr></table></figure>
<p>2.处理矩阵的变化已达到动画效果。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">mMatrix.setTranslate((mProcess-<span class="number">0.5f</span>)*getMeasuredWidth(), <span class="number">0</span>);<span class="comment">//这里要回退半个屏幕距离，和渐变的设置有关</span></span><br><span class="line">mMGradient.setLocalMatrix(mMatrix);</span><br><span class="line"><span class="keyword">super</span>.onDraw(canvas);</span><br></pre></td></tr></table></figure>
<p><strong>facebook的这个 Shimmer 库可贵的是将闪光效果扩展到布局上去了，其实他的做法也是通过Shader，但首先要将 布局内容转为 Bitmap，再在绘制 Bitmap 的时候应用上述这一套。</strong></p>
<h3 id="ReadMoreTextView"><a href="#ReadMoreTextView" class="headerlink" title="ReadMoreTextView"></a><a href="https://github.com/bravoborja/ReadMoreTextView" target="_blank" rel="noopener">ReadMoreTextView</a></h3><img src="/2017/07/23/android/View/与%20TextView%20相关的知识点/expanded.png">
<p>这里文本设置两种模式：显示完全和保留显示(最多显示240字)；</p>
<p>ReadMoreTextView 是利用 ClickSpan 来设置最后的提示文本，<a href="https://github.com/Manabu-GT/ExpandableTextView" target="_blank" rel="noopener">ExpandableTextView</a>这个库则是另外的思路，它本质上是一个 Linear 布局，需要重新计算尺寸，以及在点击事件发生时播放动画。相比之下前者的实现更简洁，但在切换时没有实现动画效果。</p>
<p>实现这个效果，我们要重写如下方法</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setText</span><span class="params">(CharSequence text, BufferType type)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">super</span>.setText(getDisplayText(text), type);</span><br><span class="line">    setMovementMethod(LinkMovementMethod.getInstance());<span class="comment">//使得TextView能够响应动作</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>使用 SpannableStringBuilder 来改造原来的 text</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> CharSequence <span class="title">getDisplayText</span><span class="params">(<span class="keyword">final</span> CharSequence text)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> len = text.length();</span><br><span class="line">    <span class="keyword">if</span> (len &lt; <span class="number">240</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> text;</span><br><span class="line">    &#125;</span><br><span class="line">    SpannableStringBuilder builder = generateText(text, isShowMore);</span><br><span class="line">    builder.setSpan(<span class="keyword">new</span> ClickableSpan() &#123;</span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onClick</span><span class="params">(View widget)</span> </span>&#123;</span><br><span class="line">                isShowMore = !isShowMore;</span><br><span class="line">                setText(text);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;, start, end, Spanned.SPAN_EXCLUSIVE_INCLUSIVE);</span><br><span class="line">    &#125; ;</span><br><span class="line">    <span class="keyword">return</span> builder;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="字体设置"><a href="#字体设置" class="headerlink" title="字体设置"></a><a href="https://github.com/chrisjenx/Calligraphy" target="_blank" rel="noopener">字体设置</a></h3><img src="/2017/07/23/android/View/与%20TextView%20相关的知识点/screenshot.png">
<figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">TextView</span> <span class="attr">fontPath</span>=<span class="string">"fonts/MyFont.ttf"</span>/&gt;</span></span><br></pre></td></tr></table></figure>
<p>这里 TextView 可以使用新的标签，这是通过代理 Context 来实现的，这里主要是改造 LayoutInflater 。改造 Factory2 和 Factory完成。</p>

        
      
    </div>

    
    
    
      <footer class="post-footer">
          <div class="post-eof"></div>
        
      </footer>
  </div>
  
  
  
  </article>

    
        <article itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block home">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2017/07/06/android/View/滑动与触摸/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="xiang">
      <meta itemprop="description" content="谨守而勿失，是谓反其真">
      <meta itemprop="image" content="/images/1.jpg">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="lxt">
    </span>
      <header class="post-header">
        <h1 class="post-title" itemprop="name headline">
            
            <a href="/2017/07/06/android/View/滑动与触摸/" class="post-title-link" itemprop="url">滑动与触摸</a>
          
        </h1>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              
                
              

              <time title="创建时间：2017-07-06 21:26:26" itemprop="dateCreated datePublished" datetime="2017-07-06T21:26:26+08:00">2017-07-06</time>
            </span>
          
            

            
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="fa fa-calendar-check-o"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2019-09-18 15:52:50" itemprop="dateModified" datetime="2019-09-18T15:52:50+08:00">2019-09-18</time>
              </span>
            
          
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing"><a href="/categories/android/" itemprop="url" rel="index"><span itemprop="name">android</span></a></span>

                
                
                  ，
                
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing"><a href="/categories/android/View/" itemprop="url" rel="index"><span itemprop="name">View</span></a></span>

                
                
              
            </span>
          

          
          <br>
            <span class="post-meta-item" title="本文字数">
              <span class="post-meta-item-icon">
                <i class="fa fa-file-word-o"></i>
              </span>
              
                <span class="post-meta-item-text">本文字数：</span>
              
              <span>16k</span>
            </span>
          
            <span class="post-meta-item" title="阅读时长">
              <span class="post-meta-item-icon">
                <i class="fa fa-clock-o"></i>
              </span>
              
                <span class="post-meta-item-text">阅读时长 &asymp;</span>
              
              <span>15 分钟</span>
            </span>
          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <p>滑动事件和触摸机制的结合有一定的套路，但也比较的复杂。其套路大概是在 ACTION_MOVE 动作时进行拖动，到了 ACTION_UP 动作进行释放，其中夹杂着一些处理动作坐标，id，速度，touchslop ，scroll 清理等琐碎的事件，<strong>但最核心和复杂的地方还是在于处理好触摸事件的传递</strong>。</p>
<h2 id="ViewDragHelper"><a href="#ViewDragHelper" class="headerlink" title="ViewDragHelper"></a>ViewDragHelper</h2><p>ViewDragHelper 类干预了容器的触摸事件机制，是一个非常好的研究对象。具体干预可以分为两个阶段</p>
<ul>
<li>拖动阶段：此时使用ViewCompat.offset 方法进行移动。</li>
<li>释放阶段：非必须，依赖于 Scoller 类来实现。</li>
</ul>
<p>ViewDragHelper 的工作实际非常简单，即获取点击点下的子控件，并随着手指滑动它，手势离开时释放，Callback 可以提供一些参数和信息，也包括处理一些回调。</p>
<p>在处理滑动的时候有两个细节要注意</p>
<p><strong>1.如何判断和获取滑动的步进距离？</strong></p>
<p>ACTION_MOVE事件下的实际步进距离 dx/dy 为两次动作的差值，一般都设定不能超过 touchslop。</p>
<p>此外dx/dy 的取值不能按照真实值，而是以 touchslop 为准，以保持滑动过程的平稳。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//相当于给本来紊乱的数据流加了一个滑动滤波器，使其归于平稳</span></span><br><span class="line"><span class="keyword">if</span> (Math.abs(dx) &gt;= touchSlop) &#123;</span><br><span class="line">    dx = (dx &gt; <span class="number">0</span>) ? touchSlop : -touchSlop;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span> (Math.abs(dy) &gt;= touchSlop) &#123;</span><br><span class="line">    dy = (dy &gt; <span class="number">0</span>) ? touchSlop : -touchSlop;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><strong>2.如何确定实际移动距离？</strong></p>
<p>有了可用的步进距离，还需要看控件是不是实际需要移动这么多距离，移动时CapureView的位置有三个取值</p>
<ul>
<li><p>旧值 int oldLeft = toCapture.getLeft();</p>
</li>
<li><p>期望值 int targetLeft = oldLeft + (int) dx;</p>
</li>
<li><p><strong>实际值 int clampedX = mCallback.clampViewPositionHorizontal(oldLeft , dx);</strong></p>
</li>
</ul>
<p>clampViewPositionHorizontal 方法是必须实现的，否则控件只能移动到(0，0)坐标处。</p>
<h3 id="深入触摸事件处理的实现"><a href="#深入触摸事件处理的实现" class="headerlink" title="深入触摸事件处理的实现"></a>深入触摸事件处理的实现</h3><p>现在深入讨论下在如下简单使用的情况下，ViewDragHelper 是如何进行触摸事件处理的？</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">onInterceptTouchEvent</span><span class="params">(MotionEvent ev)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> dragHelper.shouldInterceptTouchEvent(ev);</span><br><span class="line">&#125;</span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">onTouchEvent</span><span class="params">(MotionEvent ev)</span> </span>&#123;</span><br><span class="line">    dragHelper.processTouchEvent(ev);</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>首先明确拦截方法是以状态是否为拖动状态(即STATE_DRAGGING) 为判据的。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">shouldInterceptTouchEvent</span><span class="params">(MotionEvent ev)</span> </span>&#123;</span><br><span class="line">    <span class="comment">//...</span></span><br><span class="line">    <span class="keyword">return</span> mDragState == STATE_DRAGGING;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>正常点击(即状态为STATE_IDLE，点击动作为 ACTION_DOWN) 时，此方法并不去捕捉View，也不修改状态，自然也就拦截无效，事件向下传递；<strong>这时要想生效，只能祈祷下面的控件不要处理事件，使得事件能够传回到 onTouchEvent 方法中进行View的捕捉，并修改状态为 STATE_DRAGGING。</strong></p>
<p><strong>这样当动作转为 ACTION_MOVE 后，拦截机制虽然判定为真，但却没有机会执行了，而是直接执行 onTouchEvent 方法进行拖动，直到释放为止。</strong></p>
<p>这里有两个引申问题</p>
<p><strong>1.实际上拦截方法什么都没干，去掉拦截方法，也一样能够实现拖动效果。如果子控件拦截了事件(如设置了监听器)，那么 ViewDragHelper 的这种简单使用方法就失效了，不会产生拖动效果。</strong></p>
<p>2.那么拦截事件的意义是什么呢？</p>
<p><strong>当释放控件或处在释放状态(即STATE_SETTLING)时，发生触摸时，拦截方法将发挥作用，此时会主动进行捕捉View和修改状态，触摸事件被拦截在这一层，其主要意义在于截断了子控件的事件处理</strong>。</p>
<p><strong>此外在动作处于 ACTION_MOVE 时，也会尝试截断事件处理流程。</strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//1.计算每一个手指</span></span><br><span class="line"><span class="keyword">final</span> <span class="keyword">int</span> pointerCount = ev.getPointerCount();</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; pointerCount; i++) &#123;</span><br><span class="line">  </span><br><span class="line">    <span class="keyword">final</span> <span class="keyword">int</span> pointerId = ev.getPointerId(i);</span><br><span class="line">    <span class="keyword">final</span> <span class="keyword">float</span> x = ev.getX(i);</span><br><span class="line">    <span class="keyword">final</span> <span class="keyword">float</span> y = ev.getY(i);</span><br><span class="line">    <span class="keyword">final</span> <span class="keyword">float</span> dx = x - mInitialMotionX[pointerId];</span><br><span class="line">    <span class="keyword">final</span> <span class="keyword">float</span> dy = y - mInitialMotionY[pointerId];</span><br><span class="line">    <span class="keyword">final</span> View toCapture = findTopChildUnder((<span class="keyword">int</span>) x, (<span class="keyword">int</span>) y);</span><br><span class="line">    <span class="comment">//2，滑动距离要超过 TouchSlop</span></span><br><span class="line">    <span class="keyword">final</span> <span class="keyword">boolean</span> pastSlop = toCapture != <span class="keyword">null</span> &amp;&amp; checkTouchSlop(toCapture, dx, dy);</span><br><span class="line">    <span class="keyword">if</span> (pastSlop) &#123;</span><br><span class="line">        <span class="comment">//3. 实际想要滑动的距离 newLeft和newTop</span></span><br><span class="line">        <span class="keyword">final</span> <span class="keyword">int</span> oldLeft = toCapture.getLeft();</span><br><span class="line">        <span class="keyword">final</span> <span class="keyword">int</span> targetLeft = oldLeft + (<span class="keyword">int</span>) dx;</span><br><span class="line">        <span class="keyword">final</span> <span class="keyword">int</span> newLeft = mCallback.clampViewPositionHorizontal(toCapture,</span><br><span class="line">                targetLeft, (<span class="keyword">int</span>) dx);</span><br><span class="line">        <span class="keyword">final</span> <span class="keyword">int</span> oldTop = toCapture.getTop();</span><br><span class="line">        <span class="keyword">final</span> <span class="keyword">int</span> targetTop = oldTop + (<span class="keyword">int</span>) dy;</span><br><span class="line">        <span class="keyword">final</span> <span class="keyword">int</span> newTop = mCallback.clampViewPositionVertical(toCapture, targetTop,</span><br><span class="line">                (<span class="keyword">int</span>) dy);</span><br><span class="line">        <span class="comment">//4.水平和垂直滑动范围 horizontalDragRange和verticalDragRange</span></span><br><span class="line">        <span class="keyword">final</span> <span class="keyword">int</span> horizontalDragRange = mCallback.getViewHorizontalDragRange(</span><br><span class="line">                toCapture);</span><br><span class="line">        <span class="keyword">final</span> <span class="keyword">int</span> verticalDragRange = mCallback.getViewVerticalDragRange(toCapture);</span><br><span class="line">        <span class="comment">//5. 屏蔽掉不能滑动的情况</span></span><br><span class="line">        <span class="keyword">if</span> ((horizontalDragRange == <span class="number">0</span> || horizontalDragRange &gt; <span class="number">0</span></span><br><span class="line">                &amp;&amp; newLeft == oldLeft) &amp;&amp; (verticalDragRange == <span class="number">0</span></span><br><span class="line">                || verticalDragRange &gt; <span class="number">0</span> &amp;&amp; newTop == oldTop)) &#123;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//6.一旦某一个手指的动作符合标准，尝试捕捉View和拦截</span></span><br><span class="line">    <span class="keyword">if</span> (pastSlop &amp;&amp; tryCaptureViewForDrag(toCapture, pointerId)) &#123;</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这部分代码只在子控件获取到控制权时才发挥作用，其效果就是把控制权夺取回来。前面已经说过，如果子控件设置了点击事件监听器，ViewDragHelper 默认就无法拦截和处理了，你可以做以下配置解决这个问题，使得子控件的点击事件和滑动同时生效。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">getViewHorizontalDragRange</span><span class="params">(View child)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">getViewVerticalDragRange</span><span class="params">(View child)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>只要上述两个方法有一个不返还 0 就可以完成事件的截断。只是也要避免以下的极端情况</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">clampViewPositionHorizontal</span><span class="params">(View child, <span class="keyword">int</span> left, <span class="keyword">int</span> dx)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> left-dx;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<blockquote>
<p>最后还应该注意到，这种简单实现中，onTouchEvent 方法则永远进行处理，这意味着其上的控件永远无法得到处理机会，除非提前使用拦截方法完成拦截。</p>
</blockquote>
<h3 id="释放后的滚动"><a href="#释放后的滚动" class="headerlink" title="释放后的滚动"></a>释放后的滚动</h3><p>当ACTION_UP和ACTION_CANCEL事件发生时，将进行控件的释放，即</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">releaseViewForPointerUp</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    mVelocityTracker.computeCurrentVelocity(<span class="number">1000</span>, mMaxVelocity);</span><br><span class="line">    <span class="keyword">final</span> <span class="keyword">float</span> xvel = clampMag(</span><br><span class="line">            VelocityTrackerCompat.getXVelocity(mVelocityTracker, mActivePointerId),</span><br><span class="line">            mMinVelocity, mMaxVelocity);</span><br><span class="line">    <span class="keyword">final</span> <span class="keyword">float</span> yvel = clampMag(</span><br><span class="line">            VelocityTrackerCompat.getYVelocity(mVelocityTracker, mActivePointerId),</span><br><span class="line">            mMinVelocity, mMaxVelocity);</span><br><span class="line">    dispatchViewReleased(xvel, yvel);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这里将调用onViewReleased回调方法，并将状态设置回 STATE_IDLE。</p>
<p>在回调方法里可以主动释放控件，该效果基于ScrollerCompat 实现，需要smoothSlideViewTo方法与continueSettling 方法配合使用。例如</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//callback 中的回调方法</span></span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onViewReleased</span><span class="params">(View releasedChild, <span class="keyword">float</span> xvel, <span class="keyword">float</span> yvel)</span> </span>&#123;</span><br><span class="line">    mHelper.smoothSlideViewTo(releasedChild, <span class="number">100</span>, <span class="number">300</span>); <span class="comment">//移动到一个点上</span></span><br><span class="line">    <span class="comment">//dragHelper.flingCapturedView(0, 200, 200, 400); 返回到一个区域内</span></span><br><span class="line">    invalidate();</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//容器内</span></span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">computeScroll</span><span class="params">()</span> </span>&#123;</span><br><span class="line">   <span class="keyword">if</span> (mLeftDragger.continueSettling(<span class="keyword">true</span>)) &#123;</span><br><span class="line">       ViewCompat.postInvalidateOnAnimation(<span class="keyword">this</span>);</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这里 smoothSlideViewTo 方法实际是要 Scroller 实现的，其参数指定了滑动的终点，而起点则是View的左上角(left/top)，至于滑动的时间还与速度速度有关。</p>
<p>这里提一下速度参数的获取和使用</p>
<h4 id="VelocityTracker"><a href="#VelocityTracker" class="headerlink" title="VelocityTracker"></a><strong>VelocityTracker</strong></h4><p>VelocityTracker计算速度的流程如下</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//1，带入动作 MotionEvent</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">addMovement</span><span class="params">(MotionEvent event)</span></span>;</span><br><span class="line"><span class="comment">//2，配置时间单位 1000表示每秒速度，1表示每毫秒速度</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">computeCurrentVelocity</span><span class="params">(<span class="keyword">int</span> units)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">float</span> <span class="title">getYVelocity</span><span class="params">(<span class="keyword">int</span> id)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">float</span> <span class="title">getXVelocity</span><span class="params">(<span class="keyword">int</span> id)</span></span>;</span><br></pre></td></tr></table></figure>
<p>获取速度分量之后的使用与 scroller 有关，即作为滑动的一个参数。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">fling</span><span class="params">(<span class="keyword">int</span> startX, <span class="keyword">int</span> startY, <span class="keyword">int</span> velocityX, <span class="keyword">int</span> velocityY, <span class="keyword">int</span> minX, <span class="keyword">int</span> maxX, <span class="keyword">int</span> minY, <span class="keyword">int</span> maxY)</span></span></span><br></pre></td></tr></table></figure>
<h3 id="额外的细节：边界处理和锁定"><a href="#额外的细节：边界处理和锁定" class="headerlink" title="额外的细节：边界处理和锁定"></a>额外的细节：边界处理和锁定</h3><p>因为四边区域是有交叉的，故而应该采用位运算的标记方式来表示它们。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> EDGE_LEFT = <span class="number">1</span> &lt;&lt; <span class="number">0</span>;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> EDGE_RIGHT = <span class="number">1</span> &lt;&lt; <span class="number">1</span>;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> EDGE_TOP = <span class="number">1</span> &lt;&lt; <span class="number">2</span>;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> EDGE_BOTTOM = <span class="number">1</span> &lt;&lt; <span class="number">3</span>;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> EDGE_ALL = EDGE_LEFT | EDGE_TOP | EDGE_RIGHT | EDGE_BOTTOM;</span><br></pre></td></tr></table></figure>
<p>如何判断点击点(x,y)处于四边之内呢？</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">int</span> <span class="title">getEdgesTouched</span><span class="params">(<span class="keyword">int</span> x, <span class="keyword">int</span> y)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> result = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">if</span> (x &lt; mParentView.getLeft() + mEdgeSize) result |= EDGE_LEFT;</span><br><span class="line">    <span class="keyword">if</span> (y &lt; mParentView.getTop() + mEdgeSize) result |= EDGE_TOP;</span><br><span class="line">    <span class="keyword">if</span> (x &gt; mParentView.getRight() - mEdgeSize) result |= EDGE_RIGHT;</span><br><span class="line">    <span class="keyword">if</span> (y &gt; mParentView.getBottom() - mEdgeSize) result |= EDGE_BOTTOM;</span><br><span class="line">    <span class="keyword">return</span> result;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>在触摸事件处理时，ACTION_MOVE 动作只处理点击点在控件内的事件，此时是无法使用边界的；只有在 ACTION_DOWN 动作时才能进行拦截，处理代码如下</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">final</span> <span class="keyword">int</span> edgesTouched = mInitialEdgesTouched[pointerId];</span><br><span class="line"><span class="keyword">if</span> ((edgesTouched &amp; mTrackingEdges) != <span class="number">0</span>) &#123;</span><br><span class="line">    mCallback.onEdgeTouched(edgesTouched &amp; mTrackingEdges, pointerId);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这里首先要配置 mTrackingEdges 参数。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">viewDragHelper.setEdgeTrackingEnabled(ViewDragHelper.EDGE_ALL);</span><br></pre></td></tr></table></figure>
<p>而后在回调方法中进行捕捉View</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onEdgeTouched</span><span class="params">(<span class="keyword">int</span> edgeFlags, <span class="keyword">int</span> pointerId)</span> </span>&#123;</span><br><span class="line">    dragHelper.tryCaptureViewForDrag(getChildAt(<span class="number">0</span>), pointerId);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这样就改变了事件处理的流程，截断了事件的向下传递，改为容器自己处理。</p>
<h3 id="ViewDragHelper的实践：SwipeBackLayout"><a href="#ViewDragHelper的实践：SwipeBackLayout" class="headerlink" title="ViewDragHelper的实践：SwipeBackLayout"></a>ViewDragHelper的实践：SwipeBackLayout</h3><img src="/2017/07/06/android/View/滑动与触摸/screenshot.png">
<blockquote>
<p>同类型的库还有<a href="https://github.com/anzewei/ParallaxBackLayout" target="_blank" rel="noopener">ParallaxBackLayout</a>。</p>
</blockquote>
<p>使用 ViewDragHelper 可以快速实现一些容器，例如抽屉控件等，这里介绍一个经典的库 SwipeBackLayout，其效果是使得 Activity 能够滑动关闭，达到这种效果需要三步。</p>
<p>1.使用 ViewDragHelper 定义 SwipeBackLayout，其内部只有一个子控件就是 Activity 的 content 控件。</p>
<p>2.在DecorView中插入 SwipeBackLayout 布局，并将原来Activity 的 content 控件加入到此布局中去。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">ViewGroup decor = (ViewGroup) activity.getWindow().getDecorView();</span><br><span class="line">ViewGroup decorChild = (ViewGroup) decor.getChildAt(<span class="number">0</span>);</span><br><span class="line">TypedArray a = activity.getTheme().obtainStyledAttributes(<span class="keyword">new</span> <span class="keyword">int</span>[]&#123;</span><br><span class="line">        android.R.attr.windowBackground</span><br><span class="line">&#125;);</span><br><span class="line"><span class="keyword">int</span> background = a.getResourceId(<span class="number">0</span>, <span class="number">0</span>);</span><br><span class="line">a.recycle();</span><br><span class="line">decorChild.setBackgroundResource(background);</span><br><span class="line"><span class="comment">//decor删去内容控件，添加 SwipeBackLayout，SwipeBackLayout再添加 内容控件</span></span><br><span class="line">decor.removeView(decorChild);</span><br><span class="line">addView(decorChild);</span><br><span class="line">setContentView(decorChild);</span><br><span class="line">decor.addView(<span class="keyword">this</span>);</span><br></pre></td></tr></table></figure>
<p>到此为止，内容控件可以被捕捉和滑动了。</p>
<p><strong>3.实现透明效果</strong></p>
<p>将 window 的背景改为透明</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">mActivity.getWindow().setBackgroundDrawable(<span class="keyword">new</span> ColorDrawable(Color.TRANSPARENT));</span><br></pre></td></tr></table></figure>
<p>正常情况下背景将变成黑色，如果不使用该方法则默认的windowBackground颜色是白色。此时需要采用 translucent 模式，修改主题为</p>
<figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">style</span> <span class="attr">name</span>=<span class="string">"AppTheme"</span> <span class="attr">parent</span>=<span class="string">"Theme.AppCompat.Light.DarkActionBar"</span>&gt;</span></span><br><span class="line"><span class="xml">    <span class="tag">&lt;<span class="name">item</span> <span class="attr">name</span>=<span class="string">"android:windowIsTranslucent"</span>&gt;</span>true<span class="tag">&lt;/<span class="name">item</span>&gt;</span></span></span><br><span class="line"><span class="tag">&lt;/<span class="name">style</span>&gt;</span></span><br></pre></td></tr></table></figure>
<h2 id="嵌套滑动-NestedScroll"><a href="#嵌套滑动-NestedScroll" class="headerlink" title="嵌套滑动(NestedScroll)"></a>嵌套滑动(NestedScroll)</h2><p>嵌套滑动机制解决<strong>主控件</strong>的滑动带动<strong>副控件</strong>做跟随滑动的问题，这其实是很不可思议的一件事，因为事件触摸机制会截断事件的处理，正常情况下一次只能滑动一个控件。</p>
<p>使用嵌套滑动时主要实现主控件的逻辑，即 NestedScrollingParent 接口中的方法，一般是进行主控件的滑动。</p>
<p><strong>在一次嵌套滑动事件中，二者处于问答式交互，其一般流程如下</strong></p>
<p>1.调用 startNestedScroll() 方法，子控件会在控件树上不断上溯寻找能够响应嵌套滑动事件的父容器，一旦确定会调用父控件的 onStartNestedScroll 方法和 onNestedScrollAccepted 方法判断是否响应，一旦父控件响应就会启动嵌套滑动。</p>
<p>2.执行 dispatchNestedPreScroll 方法，触发父控件中的嵌套滑动事件回调，此时可以滑动父控件。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//dx表示限定的滑动距离，consumed记录父容器消费的滑动距离，offsetInWindow距离在屏幕上移动的距离</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">dispatchNestedPreScroll</span><span class="params">(<span class="keyword">int</span> dx, <span class="keyword">int</span> dy, <span class="keyword">int</span>[] consumed, <span class="keyword">int</span>[] offsetInWindow)</span> </span>&#123;</span><br><span class="line">    <span class="comment">//1.如果开启嵌套滑动，且父控件存在，且滑动有效</span></span><br><span class="line">    mView.getLocationInWindow(offsetInWindow);</span><br><span class="line">    <span class="keyword">int</span> startX = offsetInWindow[<span class="number">0</span>];</span><br><span class="line">    <span class="keyword">int</span> startY = offsetInWindow[<span class="number">1</span>];</span><br><span class="line">    </span><br><span class="line">    consumed[<span class="number">0</span>] = <span class="number">0</span>;</span><br><span class="line">    consumed[<span class="number">1</span>] = <span class="number">0</span>;  </span><br><span class="line">    <span class="comment">//2.执行父控件回调</span></span><br><span class="line">    ViewParentCompat.onNestedPreScroll(mNestedScrollingParent, mView, dx, dy, consumed);</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//3.在滑动前后计算了子控件在屏幕上的偏移位置 offsetInWindow，</span></span><br><span class="line">    <span class="comment">//这和父控件的消费量 consumed 是有所差别的，最后返回的结果是父控件是否滑动了</span></span><br><span class="line">    mView.getLocationInWindow(offsetInWindow);</span><br><span class="line">    offsetInWindow[<span class="number">0</span>] -= startX;</span><br><span class="line">    offsetInWindow[<span class="number">1</span>] -= startY; </span><br><span class="line">    <span class="keyword">return</span> consumed[<span class="number">0</span>] != <span class="number">0</span> || consumed[<span class="number">1</span>] != <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这里如果<code>consumed</code>数组中的值不为0，整个方法返回<code>true</code>，表示父控件消费了滑动事件。</p>
<p>3.最后一轮对话 dispatchNestedScroll 方法</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//dxConsumed 是子控件滑动的消费，dxUnconsumed则是留给父容器的未消费距离</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">dispatchNestedScroll</span><span class="params">(dxConsumed, dyConsumed, dxUnconsumed, dyUnconsumed,</span></span></span><br><span class="line"><span class="function"><span class="params">        offsetInWindow)</span></span>;</span><br></pre></td></tr></table></figure>
<p><strong>要使用嵌套滑动，要在触摸事件方法中进行，以便启动该机制；其次要设置父容器的嵌套处理方法。</strong>例如</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onNestedPreScroll</span><span class="params">(View target, <span class="keyword">int</span> dx, <span class="keyword">int</span> dy, <span class="keyword">int</span>[] consumed)</span></span>&#123;</span><br><span class="line">    consumed[<span class="number">1</span>] = dy/<span class="number">2</span>;</span><br><span class="line">    ViewCompat.offsetTopAndBottom(<span class="keyword">this</span>, consumed[<span class="number">1</span>]);    <span class="comment">//父容器消费一半距离</span></span><br><span class="line">    ViewCompat.offsetTopAndBottom(target, -consumed[<span class="number">1</span>]); <span class="comment">//抵消子控件跟随父容器的滚动</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onNestedScroll</span><span class="params">(View target, <span class="keyword">int</span> dxConsumed, <span class="keyword">int</span> dyConsumed,</span></span></span><br><span class="line"><span class="function"><span class="params">                           <span class="keyword">int</span> dxUnconsumed, <span class="keyword">int</span> dyUnconsumed)</span></span>&#123;</span><br><span class="line">    ViewCompat.offsetTopAndBottom(<span class="keyword">this</span>, dyUnconsumed); <span class="comment">//父容器滚动另一半内部滚动距离</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>就会得到一个2倍的视差滚动效果，子控件的滚动速度是父控件的一半。</p>
<p>下面我们先研究 ScrollView 和 NestedScrollView 中是如何使用嵌套滑动的。</p>
<h2 id="ScrollView"><a href="#ScrollView" class="headerlink" title="ScrollView"></a>ScrollView</h2><p>ScrollView 类是一个研究滑动与触摸的绝佳例子，它拦截触摸事件进行上下滚动，而且能够响应嵌套滑动事件。</p>
<p>ScrollView 的拦截是以 mIsBeingDragged 位来判定的，这里有一些简化步骤。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">onInterceptTouchEvent</span><span class="params">(MotionEvent ev)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">final</span> <span class="keyword">int</span> action = ev.getAction();</span><br><span class="line">    <span class="comment">//1.如果 ACTION_MOVE 且 mIsBeingDragged 直接拦截</span></span><br><span class="line">    <span class="keyword">if</span> ((action == MotionEvent.ACTION_MOVE) &amp;&amp; (mIsBeingDragged)) <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">    <span class="comment">//2.先正常拦截，避免阻塞子控件中的事件，只有</span></span><br><span class="line">    <span class="keyword">if</span> (<span class="keyword">super</span>.onInterceptTouchEvent(ev)) <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">    <span class="comment">//3.不能滑动，不拦截</span></span><br><span class="line">    <span class="keyword">if</span> (getScrollY() == <span class="number">0</span> &amp;&amp; !canScrollVertically(<span class="number">1</span>)) <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">  </span><br><span class="line">    <span class="comment">//,,,,,,</span></span><br><span class="line">    <span class="keyword">return</span> mIsBeingDragged;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>我们首先说说，在 ACTION_DOWN 和 ACTION_UP 里进行的初始化和回收工作，注意这两个动作里一定是不进行拦截的。</p>
<p><strong>1.动作 ACTION_DOWN 发生时要注意清理旧的滚动以及开启嵌套滑动。</strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">mScroller.computeScrollOffset();       </span><br><span class="line">mIsBeingDragged = !mScroller.isFinished();<span class="comment">//3.如果滑动完成了，不拦截；仍在滑动，拦截处理</span></span><br><span class="line">startNestedScroll(SCROLL_AXIS_VERTICAL);  <span class="comment">//4.请求嵌套滑动</span></span><br></pre></td></tr></table></figure>
<p>这里按下时控件在滑动中，会拦截事件进行处理，主要是停止正在进行的滑动，并记录数据</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//1.禁止父容器拦截事件，停止滚动，记录数据</span></span><br><span class="line"><span class="keyword">if</span> ((mIsBeingDragged = !mScroller.isFinished())) &#123;</span><br><span class="line">    getParent().requestDisallowInterceptTouchEvent(<span class="keyword">true</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span> (!mScroller.isFinished()) &#123;</span><br><span class="line">    mScroller.abortAnimation(); </span><br><span class="line">&#125;</span><br><span class="line">mLastMotionY = (<span class="keyword">int</span>) ev.getY();</span><br><span class="line">mActivePointerId = ev.getPointerId(<span class="number">0</span>);</span><br><span class="line">startNestedScroll(SCROLL_AXIS_VERTICAL);</span><br></pre></td></tr></table></figure>
<p>要注意的是，这时 mIsBeingDragged 的值为 false，不会发生拦截，事件将向下传递，如果没有人处理，则在 onTouchEvent 方法是这样处理的。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> ((mIsBeingDragged = !mScroller.isFinished())) &#123;</span><br><span class="line">    getParent().requestDisallowInterceptTouchEvent(<span class="keyword">true</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span> (!mScroller.isFinished()) &#123;</span><br><span class="line">    mScroller.abortAnimation();</span><br><span class="line">&#125;</span><br><span class="line">startNestedScroll(SCROLL_AXIS_VERTICAL);</span><br></pre></td></tr></table></figure>
<p>mIsBeingDragged 的值是 mScroller 是否还在滚动。</p>
<p><strong>2.动作 ACTION_UP 发生时，不进行拦截，但又要完成释放回弹和停止嵌套滑动的动作。</strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">mIsBeingDragged = <span class="keyword">false</span>;</span><br><span class="line"><span class="keyword">if</span> (mScroller.springBack(mScrollX, mScrollY, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, getScrollRange())) &#123;</span><br><span class="line">    postInvalidateOnAnimation();</span><br><span class="line">&#125;</span><br><span class="line">stopNestedScroll();</span><br></pre></td></tr></table></figure>
<p><strong>3.最主要的事件处理发生在 动作ACTION_MOVE 中，此时将发生拦截。</strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//1.根据判定条件进行拦截</span></span><br><span class="line"><span class="keyword">if</span> (yDiff &gt; mTouchSlop &amp;&amp; (getNestedScrollAxes() &amp; SCROLL_AXIS_VERTICAL) == <span class="number">0</span>) &#123;</span><br><span class="line">    mIsBeingDragged = <span class="keyword">true</span>;</span><br><span class="line">    mLastMotionY = y; <span class="comment">//更新 mLastMotionY</span></span><br><span class="line">    initVelocityTrackerIfNotExists(); <span class="comment">//更新 VelocityTracker</span></span><br><span class="line">    mVelocityTracker.addMovement(ev);</span><br><span class="line">    mNestedYOffset = <span class="number">0</span>;</span><br><span class="line">    getParent().requestDisallowInterceptTouchEvent(<span class="keyword">true</span>); <span class="comment">//一旦拦截，不许父控件拦截</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><strong>包含嵌套滑动的滚动处理，首先交给父控件进行嵌套滑动，而后子控件自己滚动，最后再交给父控件一次</strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">final</span> <span class="keyword">int</span> y = (<span class="keyword">int</span>) ev.getY(activePointerIndex);</span><br><span class="line"><span class="keyword">int</span> deltaY = mLastMotionY - y;</span><br><span class="line"><span class="keyword">if</span> (dispatchNestedPreScroll(<span class="number">0</span>, deltaY, mScrollConsumed, mScrollOffset)) &#123;</span><br><span class="line">    deltaY -= mScrollConsumed[<span class="number">1</span>]; <span class="comment">//1.deltaY 减去嵌套滑动已消费的距离</span></span><br><span class="line">    vtev.offsetLocation(<span class="number">0</span>, mScrollOffset[<span class="number">1</span>]); </span><br><span class="line">    mNestedYOffset += mScrollOffset[<span class="number">1</span>];<span class="comment">//2.mNestedYOffset 记录嵌套滑动已消费的距离</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span> (!mIsBeingDragged &amp;&amp; Math.abs(deltaY) &gt; mTouchSlop) &#123;</span><br><span class="line">    getParent().requestDisallowInterceptTouchEvent(<span class="keyword">true</span>);</span><br><span class="line">    mIsBeingDragged = <span class="keyword">true</span>;</span><br><span class="line">    <span class="keyword">if</span> (deltaY &gt; <span class="number">0</span>) &#123;</span><br><span class="line">        deltaY -= mTouchSlop;     <span class="comment">//3.控制 deltaY 的数值，使其滑动均匀可控</span></span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        deltaY += mTouchSlop;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span> (mIsBeingDragged) &#123;</span><br><span class="line">    mLastMotionY = y - mScrollOffset[<span class="number">1</span>];</span><br><span class="line">    <span class="keyword">final</span> <span class="keyword">int</span> oldY = mScrollY;</span><br><span class="line">    <span class="keyword">final</span> <span class="keyword">int</span> range = getScrollRange();</span><br><span class="line">    <span class="keyword">final</span> <span class="keyword">int</span> overscrollMode = getOverScrollMode();</span><br><span class="line">    <span class="comment">//4.处理自己的滚动</span></span><br><span class="line">    <span class="keyword">if</span> (overScrollBy(<span class="number">0</span>, deltaY, <span class="number">0</span>, mScrollY, <span class="number">0</span>, range, <span class="number">0</span>, mOverscrollDistance, <span class="keyword">true</span>)</span><br><span class="line">            &amp;&amp; !hasNestedScrollingParent()) &#123;</span><br><span class="line">        mVelocityTracker.clear();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//5.再次发起嵌套滚动 </span></span><br><span class="line">    <span class="keyword">final</span> <span class="keyword">int</span> scrolledDeltaY = mScrollY - oldY;</span><br><span class="line">    <span class="keyword">final</span> <span class="keyword">int</span> unconsumedY = deltaY - scrolledDeltaY;</span><br><span class="line">    <span class="keyword">if</span> (dispatchNestedScroll(<span class="number">0</span>, scrolledDeltaY, <span class="number">0</span>, unconsumedY, mScrollOffset)) &#123;</span><br><span class="line">        mLastMotionY -= mScrollOffset[<span class="number">1</span>];</span><br><span class="line">        vtev.offsetLocation(<span class="number">0</span>, mScrollOffset[<span class="number">1</span>]);</span><br><span class="line">        mNestedYOffset += mScrollOffset[<span class="number">1</span>];</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (canOverscroll) &#123;</span><br><span class="line">        <span class="comment">//6.如果父控件没有消费，则处理覆盖滚动</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="覆盖滚动"><a href="#覆盖滚动" class="headerlink" title="覆盖滚动"></a>覆盖滚动</h4><p>覆盖滚动的触发条件是</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">final</span> <span class="keyword">int</span> overscrollMode = getOverScrollMode();</span><br><span class="line"><span class="keyword">boolean</span> canOverscroll = overscrollMode == OVER_SCROLL_ALWAYS ||</span><br><span class="line">        (overscrollMode == OVER_SCROLL_IF_CONTENT_SCROLLS &amp;&amp; range &gt; <span class="number">0</span>);</span><br></pre></td></tr></table></figure>
<p>这里给出的 getScrollRange 为</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Math.max(<span class="number">0</span>, child.getHeight() - (getHeight() - mPaddingBottom - mPaddingTop));</span><br></pre></td></tr></table></figure>
<p>覆盖滚动的效果是靠 EdgeGlow 实现的。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">final</span> <span class="keyword">int</span> pulledToY = getScrollY() + deltaY;</span><br><span class="line"><span class="keyword">if</span> (pulledToY &lt; <span class="number">0</span>) &#123;</span><br><span class="line">    mEdgeGlowTop.onPull((<span class="keyword">float</span>) deltaY / getHeight(), ev.getX() / getWidth());</span><br><span class="line">    <span class="keyword">if</span> (!mEdgeGlowBottom.isFinished()) &#123;</span><br><span class="line">        mEdgeGlowBottom.onRelease();</span><br><span class="line">    &#125;</span><br><span class="line">&#125; <span class="keyword">else</span> <span class="keyword">if</span> (pulledToY &gt; range) &#123;</span><br><span class="line">    mEdgeGlowBottom.onPull((<span class="keyword">float</span>) deltaY / getHeight(), <span class="number">1</span>.f - ev.getX() / getWidth());</span><br><span class="line">    <span class="keyword">if</span> (!mEdgeGlowTop.isFinished()) &#123;</span><br><span class="line">        mEdgeGlowTop.onRelease();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span> (!mEdgeGlowTop.isFinished() || !mEdgeGlowBottom.isFinished()) &#123;</span><br><span class="line">    postInvalidateOnAnimation();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="嵌套滑动的实践：-NestedScrollView"><a href="#嵌套滑动的实践：-NestedScrollView" class="headerlink" title="嵌套滑动的实践： NestedScrollView"></a>嵌套滑动的实践： NestedScrollView</h4><p>ScrollView 实际已经与 NestedScrollView 大致上一样了，它同时可以作为嵌套滑动的父容器和子控件。我们主要关注它作为父控件时是如何应答的:</p>
<p>1.能够相应的类型是垂直滑动</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">onStartNestedScroll</span><span class="params">(View child, View target, <span class="keyword">int</span> nestedScrollAxes)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> (nestedScrollAxes &amp; ViewCompat.SCROLL_AXIS_VERTICAL) != <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>而且自己作为子控件将事件继续向上分发</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onNestedScrollAccepted</span><span class="params">(View child, View target, <span class="keyword">int</span> nestedScrollAxes)</span> </span>&#123;</span><br><span class="line">    mNestedScrollAxes = axes;</span><br><span class="line">    startNestedScroll(ViewCompat.SCROLL_AXIS_VERTICAL);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>2.第一轮问答</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onNestedPreScroll</span><span class="params">(View target, <span class="keyword">int</span> dx, <span class="keyword">int</span> dy, <span class="keyword">int</span>[] consumed)</span> </span>&#123;</span><br><span class="line">    <span class="comment">//此时 consumed 为 null</span></span><br><span class="line">    mChildHelper.dispatchNestedPreScroll(dx, dy, consumed, <span class="keyword">null</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>从 onNestedPreScroll 方法的实现上看，当它作为父容器要响应嵌套滑动时，它会将事件转发给它的子控件。</p>
<p>3.第二轮问答</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onNestedScroll</span><span class="params">(View target, <span class="keyword">int</span> dxConsumed, <span class="keyword">int</span> dyConsumed, <span class="keyword">int</span> dxUnconsumed, <span class="keyword">int</span> dyUnconsumed)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">final</span> <span class="keyword">int</span> oldScrollY = getScrollY();</span><br><span class="line">    scrollBy(<span class="number">0</span>, dyUnconsumed);</span><br><span class="line">    <span class="keyword">final</span> <span class="keyword">int</span> myConsumed = getScrollY() - oldScrollY;</span><br><span class="line">    <span class="keyword">final</span> <span class="keyword">int</span> myUnconsumed = dyUnconsumed - myConsumed;</span><br><span class="line">    mChildHelper.dispatchNestedScroll(<span class="number">0</span>, myConsumed, <span class="number">0</span>, myUnconsumed, <span class="keyword">null</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><strong>注意在第二轮问答时 NestedScrollView 控件本身发生了滚动，距离为传入的参数 dyUnconsumed，这是发起者消费后的余量。</strong>消费距离实际就是 dyUnconsumed，而未消费距离为0。此后将这一数据向子控件继续分发。</p>

        
      
    </div>

    
    
    
      <footer class="post-footer">
          <div class="post-eof"></div>
        
      </footer>
  </div>
  
  
  
  </article>

    
        <article itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block home">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2017/05/29/android/系统/Broadcast/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="xiang">
      <meta itemprop="description" content="谨守而勿失，是谓反其真">
      <meta itemprop="image" content="/images/1.jpg">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="lxt">
    </span>
      <header class="post-header">
        <h1 class="post-title" itemprop="name headline">
            
            <a href="/2017/05/29/android/系统/Broadcast/" class="post-title-link" itemprop="url">Broadcast</a>
          
        </h1>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              
                
              

              <time title="创建时间：2017-05-29 17:56:36" itemprop="dateCreated datePublished" datetime="2017-05-29T17:56:36+08:00">2017-05-29</time>
            </span>
          
            

            
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="fa fa-calendar-check-o"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2019-09-18 12:47:47" itemprop="dateModified" datetime="2019-09-18T12:47:47+08:00">2019-09-18</time>
              </span>
            
          
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing"><a href="/categories/android/" itemprop="url" rel="index"><span itemprop="name">android</span></a></span>

                
                
                  ，
                
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing"><a href="/categories/android/系统/" itemprop="url" rel="index"><span itemprop="name">系统</span></a></span>

                
                
              
            </span>
          

          
          <br>
            <span class="post-meta-item" title="本文字数">
              <span class="post-meta-item-icon">
                <i class="fa fa-file-word-o"></i>
              </span>
              
                <span class="post-meta-item-text">本文字数：</span>
              
              <span>8.6k</span>
            </span>
          
            <span class="post-meta-item" title="阅读时长">
              <span class="post-meta-item-icon">
                <i class="fa fa-clock-o"></i>
              </span>
              
                <span class="post-meta-item-text">阅读时长 &asymp;</span>
              
              <span>8 分钟</span>
            </span>
          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h2 id="基本原理"><a href="#基本原理" class="headerlink" title="基本原理"></a>基本原理</h2><p>广播的使用包括<strong>注册</strong>和<strong>发送</strong>两步。<strong>注册广播</strong>又分为两种方式</p>
<ul>
<li>在代码中进行动态注册</li>
<li>在XML文件中进行静态注册。</li>
</ul>
<p>不管哪种方式都涉及两个类 BroadcastReceiver 与 IntentFilter。<strong>前者负责处理广播，后者负责匹配广播</strong>。</p>
<blockquote>
<p>因为广播易造成内存泄漏，一般在活动的<code>onResume</code>和<code>onPause</code>方法中<strong>成对的</strong>进行注册和销毁。</p>
</blockquote>
<p>2.<strong>发送广播</strong>本质上是一个后台操作，发送广播的类型包括</p>
<ul>
<li><code>sendBroadcast</code> 发送无序广播，异步执行，效率高，但存在隐患</li>
<li><code>sendOrderedBroadcast</code> 发送有序广播，在某个接收器执行的同时会阻塞其他的接收器</li>
</ul>
<blockquote>
<p>虽然执行广播的进程是一个优先级较高的前台进程，但<code>BroadcastReceiver</code> 对象的生命周期只在 <code>onReceive</code>方法的执行过程中，一旦执行完，对象将销毁。<strong>这一特性决定了如果在广播接收器内部执行异步操作，将无法返回。</strong></p>
</blockquote>
<h3 id="局部广播"><a href="#局部广播" class="headerlink" title="局部广播"></a>局部广播</h3><p><code>LocalBroadcastManager</code>局部广播不需要跨进程，并非使用<code>Binder</code>机制。</p>
<h3 id="粘性广播"><a href="#粘性广播" class="headerlink" title="粘性广播"></a>粘性广播</h3><p>粘性广播在21中被<code>deprecated</code> 了，使用粘性广播首先需要权限</p>
<figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">android.permission.BROADCAST_STICKYXML</span><br></pre></td></tr></table></figure>
<p>使用方法<code>sendStickyBroadcast</code>方法来发送粘性广播</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Intent intent = <span class="keyword">new</span> Intent(<span class="string">"receiver"</span>);</span><br><span class="line">intent.putExtra(<span class="string">"DATA"</span>,<span class="string">"receiver"</span>);</span><br><span class="line">sendStickyBroadcast(intent);</span><br></pre></td></tr></table></figure>
<p>它的行为和正常广播基本一致，在广播接收器取消注册后不会受理广播。唯一有区别的一点是<strong>广播接收器取消注册后，如果发送粘性广播，则Intent将被会缓存到系统中。</strong>这样<strong>再次注册广播接收器时，能从该方法返回值中获取先前的Intent即其中的数据。</strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Intent mIntentSticky = registerReceiver(receiver,filter);</span><br><span class="line">-------------------------</span><br><span class="line"><span class="comment">//s = "receiver"String s = mIntentSticky .getStringExtra("DATA");</span></span><br></pre></td></tr></table></figure>
<p>因此发送粘性广播即便不能被成功接受，也可以保存数据，可见粘性广播的好处是使得广播能够在<strong>注册周期之外感知数据变化</strong>，但损失的是<strong>安全性</strong>，这些数据可以被任意获取与修改。</p>
<h3 id="最佳实践"><a href="#最佳实践" class="headerlink" title="最佳实践"></a>最佳实践</h3><p>使用广播必须要手动注册接收机，可以优化的地方有两点</p>
<p>1.注册和解除配对出现，一般放在 onStart 和 onStop 方法中，其目的是防止内存泄漏。</p>
<p>2.视广播如何处理决定是否在注册时禁用(enable)，以避免无谓的耗电。</p>
<p>首先禁止广播</p>
<figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">receiver</span></span></span><br><span class="line"><span class="tag">    <span class="attr">android:name</span>=<span class="string">".MyReceiver"</span></span></span><br><span class="line"><span class="tag">    <span class="attr">android:enabled</span>=<span class="string">"false"</span></span></span><br><span class="line"><span class="tag">    <span class="attr">android:exported</span>=<span class="string">"true"</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">receiver</span>&gt;</span></span><br></pre></td></tr></table></figure>
<p>在必要时开启，并及时释放</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">PackageManager packageManager = getPackageManager();</span><br><span class="line">ComponentName componentName = <span class="keyword">new</span> ComponentName(<span class="keyword">this</span>, MyReceiver.class);</span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">onStart</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">super</span>.onStart();</span><br><span class="line">    registerReceiver(receiver, filter);</span><br><span class="line">    packageManager.setComponentEnabledSetting(componentName,</span><br><span class="line">            PackageManager.COMPONENT_ENABLED_STATE_ENABLED,</span><br><span class="line">            PackageManager.DONT_KILL_APP);</span><br><span class="line">&#125;</span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">onStop</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">super</span>.onStop();</span><br><span class="line">    unregisterReceiver(receiver);</span><br><span class="line">    packageManager.setComponentEnabledSetting(componentName,</span><br><span class="line">            PackageManager.COMPONENT_ENABLED_STATE_DISABLED,</span><br><span class="line">            PackageManager.DONT_KILL_APP);</span><br></pre></td></tr></table></figure>
<h2 id="广播注册原理"><a href="#广播注册原理" class="headerlink" title="广播注册原理"></a><strong>广播注册原理</strong></h2><p>在 Android 的广播机制中， ActivityManagerService 扮演着广播中心的角色，负责系统中所有广播的注册和发布操作，因此，Android应用程序注册广播接收器的过程就是<strong>把广播接收器注册到ActivityManagerService的过程</strong>。</p>
<p>广播注册实际由<code>ContextImpl</code>的如下方法执行(已作精简)</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> Intent <span class="title">registerReceiverInternal</span><span class="params">(BroadcastReceiver receiver, ..., Context context)</span> </span>&#123;</span><br><span class="line">    IIntentReceiver rd = <span class="keyword">new</span> LoadedApk.ReceiverDispatcher(receiver, context, scheduler, <span class="keyword">null</span>, <span class="keyword">true</span>).getIIntentReceiver();</span><br><span class="line">    <span class="keyword">return</span> ActivityManagerNative.getDefault().registerReceiver(...);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>该方法首先构建 IIntentReceiver 对象接口 ，这是一个<strong>单向</strong>的 Binder 对象，专门负责<strong>执行接收广播</strong>，定义如下</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">oneway <span class="class"><span class="keyword">interface</span> <span class="title">IIntentReceiver</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">performReceive</span><span class="params">(in Intent intent, <span class="keyword">int</span> resultCode, String data,in Bundle extras, <span class="keyword">boolean</span> ordered, <span class="keyword">boolean</span> sticky, <span class="keyword">int</span> sendingUser)</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>而后使用<code>ActivityManagerService</code>类在服务端进行真实的广播注册</p>
<hr>
<p>在研究AMS如何注册广播之前，先做些预备工作</p>
<p>1.<code>ActivityManagerService</code>维持着一个广播过滤器集合</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">HashMap&lt;IBinder, ReceiverList&gt; mRegisteredReceivers</span><br></pre></td></tr></table></figure>
<p>其中<code>key</code>为 IIntentReceivers 对象，而<code>Value</code>为 ReceiverList ，代表一个注册了若干个广播的广播接收机，定义如下</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">ReceiverList</span> <span class="keyword">extends</span> <span class="title">ArrayList</span>&lt;<span class="title">BroadcastFilter</span>&gt;</span>&#123;	</span><br><span class="line">    IIntentReceiver receiver;	</span><br><span class="line">    BroadcastRecord curBroadcast = <span class="keyword">null</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>可见 ReceiverList 是一个集合类，元素为<strong>广播过滤器</strong> BroadcastFilter 。该类是 IntentFilter 的子类。</p>
<p>2.<strong>IntentResolver</strong>类负责<strong>操作广播过滤器</strong>，其中有一个重要的方法是<strong>判断两个 IntentFilter 对象是否相等</strong>。其实现原理是是依次比较<code>Action</code>，<code>Category</code>以及<code>Data</code>是否相等，其中<code>Data</code>的比较又分为多个部分。</p>
<hr>
<p>AMS 中注册广播的方法如下</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> Intent <span class="title">registerReceiver</span><span class="params">(IIntentReceiver receiver, IntentFilter filter, String permission, <span class="keyword">int</span> userId)</span> </span>&#123; </span><br><span class="line">        <span class="comment">//1，收集粘性广播列表</span></span><br><span class="line">	<span class="comment">//2，获取匹配过滤器的所有粘性广播</span></span><br><span class="line">	<span class="comment">//3. 是否使用粘性广播	</span></span><br><span class="line">	Intent sticky = allSticky != <span class="keyword">null</span> ? allSticky.get(<span class="number">0</span>) : <span class="keyword">null</span>; </span><br><span class="line">	<span class="comment">//4，广播注册</span></span><br><span class="line">	<span class="keyword">synchronized</span> (<span class="keyword">this</span>) &#123;</span><br><span class="line">		ReceiverList rl = mRegisteredReceivers.get(receiver.asBinder()); </span><br><span class="line">            <span class="keyword">if</span> (rl == <span class="keyword">null</span>) &#123;</span><br><span class="line">                rl = <span class="keyword">new</span> ReceiverList(<span class="keyword">this</span>, callerApp, callingPid, callingUid,userId, receiver);</span><br><span class="line">				mRegisteredReceivers.put(receiver.asBinder(), rl);</span><br><span class="line">&#125; </span><br><span class="line">            BroadcastFilter bf = <span class="keyword">new</span> BroadcastFilter(filter, rl, callerPackage,permission, callingUid, userId);</span><br><span class="line">            rl.add(bf);</span><br><span class="line">	mReceiverResolver.addFilter(bf);		</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> sticky;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>注册广播的大部分代码是在处理粘性广播，对此只大略叙述</p>
<p>1.首先收集所有的粘性广播<br>2.而后收集能够经过过滤器的粘性广播集合<br>3.如果确实发送的是粘性广播，则返回代表最近的一条粘性广播的<code>Intent</code>。</p>
<p>广播注册的过程是同步的，实际步骤是</p>
<p>1.先从广播过滤器缓存集合中查询是否存在传入的广播接收器，如果没有，则创建 ReceiverList ，并将其存入缓存<br>2.根据参数 IntentFilter 创建过滤器 BroadcastFilter ，并添加到系统解析器 mReceiverResolver中。</p>
<blockquote>
<p><strong>总结</strong>：广播有两个要素<code>BroadcastReceiver</code>与<code>IntentFilter</code>。注册广播时前者生成<code>Binder</code>对象，定义了如何处理广播；后者生成一个新的过滤器。系统内存维持着一个字典集合，不考虑粘性广播，则广播的注册过程是将二者写入这个字典集合中去。</p>
</blockquote>
<h2 id="WakefulBroadcastReceiver"><a href="#WakefulBroadcastReceiver" class="headerlink" title="WakefulBroadcastReceiver"></a>WakefulBroadcastReceiver</h2><h3 id="唤醒锁"><a href="#唤醒锁" class="headerlink" title="唤醒锁"></a><strong>唤醒锁</strong></h3><p>在认识<code>WakefulBroadcastReceiver</code>广播之前先要了解唤醒锁。</p>
<p>安卓使用<code>PowerManager</code>服务来<strong>控制设备电源状态</strong>，设备的接口定义在<code>IPowerManager</code>接口中，可执行的方法如下</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">goToSleep</span><span class="params">(<span class="keyword">long</span> time)</span></span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">wakeUp</span><span class="params">(<span class="keyword">long</span> time)</span> </span></span><br><span class="line"><span class="function"><span class="keyword">boolean</span> <span class="title">isScreenOn</span><span class="params">()</span> </span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">reboot</span><span class="params">(String reason)</span> </span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">shutdown</span><span class="params">(<span class="keyword">boolean</span> confirm, <span class="keyword">boolean</span> wait)</span></span></span><br></pre></td></tr></table></figure>
<p>其中最重要的方法是<strong>创建唤醒锁</strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">WakeLock <span class="title">newWakeLock</span><span class="params">(<span class="keyword">int</span> levelAndFlags, String tag)</span></span></span><br></pre></td></tr></table></figure>
<p><code>WakeLock</code>类即代表唤醒锁，是<code>PowerManager</code>的内部类，<strong>保持该锁会使得设备保持开启状态，无法进入休眠</strong>，必须等待锁的释放。</p>
<p>在上述方法中参数<code>levelAndFlags</code>表示锁的级别与类型，<strong>实际使用中应尽量不使用以及使用最低级别的锁</strong>。</p>
<ul>
<li><code>FULL_WAKE_LOCK</code></li>
<li><code>PARTIAL_WAKE_LOCK</code> 该类型的所会使<strong>CPU保持运行，无视屏幕是否熄灭</strong>，即使按下电源键设备也不能进入休眠。</li>
<li><code>SCREEN_DIM_WAKE_LOCK</code> 屏幕将一直保持较暗的亮度，但不会熄灭。<strong>按下电源键锁将释放</strong>。</li>
<li><code>SCREEN_BRIGHT_WAKE_LOCK</code> 同上</li>
</ul>
<p>在创建唤醒锁之后使用如下方法启用</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">acquire()</span><br></pre></td></tr></table></figure>
<p>释放唤醒锁</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">release()</span><br></pre></td></tr></table></figure>
<blockquote>
<p>使用唤醒锁可以保持屏幕长亮，但更轻量级的做法是对窗口对象使用属性android.view.WindowManager.LayoutParams#FLAG_KEEP_SCREEN_ON。</p>
</blockquote>
<h3 id="WifiLock"><a href="#WifiLock" class="headerlink" title="WifiLock"></a><strong>WifiLock</strong></h3><p>与<code>WakeLock</code>类似的还有<code>WifiLock</code>，该锁保持<code>Wi-Fi</code>射频模块开启。正常模式下<code>Wi-Fi</code>射频模块会自动关闭以节省电量，在下载大文件时可以使用该锁。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">WifiLock <span class="title">createWifiLock</span><span class="params">(<span class="keyword">int</span> lockType, String tag)</span></span></span><br></pre></td></tr></table></figure>
<p>lockType 的可能取值为</p>
<ul>
<li><code>WIFI_MODE_FULL_HIGH_PERF</code> 表示高性能连接，低丢包率，适合传输语音</li>
<li><code>WIFI_MODE_FULL</code></li>
<li><code>WIFI_MODE_SCAN_ONLY</code></li>
</ul>
<h3 id="WakefulBroadcastReceiver-1"><a href="#WakefulBroadcastReceiver-1" class="headerlink" title="WakefulBroadcastReceiver"></a><strong>WakefulBroadcastReceiver</strong></h3><p><strong>WakefulBroadcastReceiver</strong>是一种利用唤醒锁的特殊广播，其目的是确保广播发射到启动服务的过程中，设备始终处于唤醒状态，不会因为进入休眠状态而中止启动服务。类内部保持了唤醒锁集合</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">SparseArray&lt;PowerManager.WakeLock&gt; mActiveWakeLocks;</span><br></pre></td></tr></table></figure>
<p>该广播提供了一个工具方法<code>startWakefulService</code>来启动服务，其实现如下</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> ComponentName <span class="title">startWakefulService</span><span class="params">(Context context, Intent intent)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">synchronized</span> (mActiveWakeLocks) &#123;</span><br><span class="line">        <span class="keyword">int</span> id = mNextId;</span><br><span class="line">        mNextId++;</span><br><span class="line">        <span class="keyword">if</span> (mNextId &lt;= <span class="number">0</span>) &#123;</span><br><span class="line">            mNextId = <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        intent.putExtra(EXTRA_WAKE_LOCK_ID, id);</span><br><span class="line">        ComponentName comp = context.startService(intent);</span><br><span class="line">        PowerManager pm = (PowerManager)context.getSystemService(Context.POWER_SERVICE);</span><br><span class="line">        PowerManager.WakeLock wl = pm.newWakeLock(PowerManager.PARTIAL_WAKE_LOCK,</span><br><span class="line">                <span class="string">"wake:"</span> + comp.flattenToShortString());</span><br><span class="line">        wl.setReferenceCounted(<span class="keyword">false</span>);</span><br><span class="line">        wl.acquire(<span class="number">60</span>*<span class="number">1000</span>);</span><br><span class="line">        mActiveWakeLocks.put(id, wl);</span><br><span class="line">        <span class="keyword">return</span> comp;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><strong>可见在启动服务的时候，将创建一个唤醒锁，并获得60s的唤醒时间，在此期间设备保持唤醒状态。</strong></p>
<p><strong>该广播还提供了completeWakefulIntent方法以便在服务中释放唤醒锁</strong>，其实现如下</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">boolean</span> <span class="title">completeWakefulIntent</span><span class="params">(Intent intent)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">final</span> <span class="keyword">int</span> id = intent.getIntExtra(EXTRA_WAKE_LOCK_ID, <span class="number">0</span>);</span><br><span class="line">    PowerManager.WakeLock wl = mActiveWakeLocks.get(id);</span><br><span class="line">    wl.release();</span><br><span class="line">    mActiveWakeLocks.remove(id);</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="小部件-AppWidgetProvider"><a href="#小部件-AppWidgetProvider" class="headerlink" title="小部件(AppWidgetProvider)"></a>小部件(AppWidgetProvider)</h3><p>小部件是 APP 的简易入口，<strong>宿主APP</strong>与小部件处于不同的进程中，宿主通过广播(AppWidgetProvider)来更新小部件，小部件通过 PedentIndent 与宿主交互。</p>
<p>继承 AppWidgetProvider 类创建一个广播，并注册到清单文件</p>
<figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">receiver</span> <span class="attr">android:name</span>=<span class="string">"ExampleAppWidgetProvider"</span> &gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">intent-filter</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">action</span> <span class="attr">android:name</span>=<span class="string">"android.appwidget.action.APPWIDGET_UPDATE"</span> /&gt;</span> </span><br><span class="line">    <span class="tag">&lt;/<span class="name">intent-filter</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">meta-data</span> <span class="attr">android:name</span>=<span class="string">"android.appwidget.provider"</span></span></span><br><span class="line"><span class="tag">               <span class="attr">android:resource</span>=<span class="string">"@xml/example_appwidget_info"</span> /&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">receiver</span>&gt;</span></span><br></pre></td></tr></table></figure>
<p>有两点要注意</p>
<ul>
<li>必须制定特殊的 action，系统由此判定是小部件</li>
<li>必须提供小部件的配置信息</li>
</ul>
<figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">appwidget-provider</span> <span class="attr">xmlns:android</span>=<span class="string">"http://schemas.android.com/apk/res/android"</span></span></span><br><span class="line"><span class="tag">    <span class="attr">android:minWidth</span>=<span class="string">"40dp"</span></span></span><br><span class="line"><span class="tag">    <span class="attr">android:minHeight</span>=<span class="string">"40dp"</span></span></span><br><span class="line"><span class="tag">    <span class="attr">android:updatePeriodMillis</span>=<span class="string">"86400000"</span></span></span><br><span class="line"><span class="tag">    <span class="attr">android:previewImage</span>=<span class="string">"@drawable/preview"</span> //</span></span><br><span class="line"><span class="tag">    <span class="attr">android:initialLayout</span>=<span class="string">"@layout/example_appwidget"</span></span></span><br><span class="line"><span class="tag">    <span class="attr">android:configure</span>=<span class="string">"com.example.android.ExampleAppWidgetConfigure"</span> </span></span><br><span class="line"><span class="tag">    <span class="attr">android:resizeMode</span>=<span class="string">"horizontal|vertical"</span></span></span><br><span class="line"><span class="tag">    <span class="attr">android:widgetCategory</span>=<span class="string">"home_screen|keyguard"</span></span></span><br><span class="line"><span class="tag">    <span class="attr">android:initialKeyguardLayout</span>=<span class="string">"@layout/example_keyguard"</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">appwidget-provider</span>&gt;</span></span><br></pre></td></tr></table></figure>
<p>小部件信息的必要配置有4个，但<strong>小部件布局能够支持的布局和控件内是有限的，且要注意小部件的边距问题。</strong></p>
<p>到此为止 ，小部件就已经建立起来了，但 没有任何功能。</p>
<p>AppWidgetProvider 类实际就是普通广播，仅仅对5个广播相关的事件进行了转发处理</p>
<ul>
<li>ACTION_APPWIDGET_UPDATE： 小部件更新</li>
<li>ACTION_APPWIDGET_DELETED：删除每一个小部件</li>
<li>ACTION_APPWIDGET_ENABLED ：发生在添加第一个小部件时</li>
<li>ACTION_APPWIDGET_DISABLED：发生在移除最后一个小部件时</li>
<li>ACTION_APPWIDGET_OPTIONS_CHANGED 小部件配置改变</li>
</ul>
<p><strong>更新小部件需要利用 AppWidgetManager 类，更具体的内容是操作 RemoteViews</strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onUpdate</span><span class="params">(Context context, AppWidgetManager appWidgetManager, <span class="keyword">int</span>[] appWidgetIds)</span> </span>&#123;</span><br><span class="line">    RemoteViews remoteViews = <span class="keyword">new</span> RemoteViews(context.getPackageName(), R.layout.update_main);    </span><br><span class="line">    remoteViews.setImageViewResource(R.id.image, srcs[index]);</span><br><span class="line">    remoteViews.setOnClickPendingIntent(R.id.image, PendingIntent.getBroadcast(context, <span class="number">1</span>, <span class="keyword">new</span> Intent(<span class="string">"com.mowang.click"</span>), PendingIntent.FLAG_UPDATE_CURRENT));</span><br><span class="line">    ComponentName componentName = <span class="keyword">new</span> ComponentName(context, <span class="keyword">this</span>.getClass());</span><br><span class="line">    appWidgetManager.updateAppWidget(componentName , remoteViews);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

        
      
    </div>

    
    
    
      <footer class="post-footer">
          <div class="post-eof"></div>
        
      </footer>
  </div>
  
  
  
  </article>

    
        <article itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block home">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2017/05/24/android/系统/Window/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="xiang">
      <meta itemprop="description" content="谨守而勿失，是谓反其真">
      <meta itemprop="image" content="/images/1.jpg">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="lxt">
    </span>
      <header class="post-header">
        <h1 class="post-title" itemprop="name headline">
            
            <a href="/2017/05/24/android/系统/Window/" class="post-title-link" itemprop="url">Window</a>
          
        </h1>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              
                
              

              <time title="创建时间：2017-05-24 11:56:26" itemprop="dateCreated datePublished" datetime="2017-05-24T11:56:26+08:00">2017-05-24</time>
            </span>
          
            

            
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="fa fa-calendar-check-o"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2019-09-18 12:35:54" itemprop="dateModified" datetime="2019-09-18T12:35:54+08:00">2019-09-18</time>
              </span>
            
          
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing"><a href="/categories/android/" itemprop="url" rel="index"><span itemprop="name">android</span></a></span>

                
                
                  ，
                
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing"><a href="/categories/android/系统/" itemprop="url" rel="index"><span itemprop="name">系统</span></a></span>

                
                
              
            </span>
          

          
          <br>
            <span class="post-meta-item" title="本文字数">
              <span class="post-meta-item-icon">
                <i class="fa fa-file-word-o"></i>
              </span>
              
                <span class="post-meta-item-text">本文字数：</span>
              
              <span>15k</span>
            </span>
          
            <span class="post-meta-item" title="阅读时长">
              <span class="post-meta-item-icon">
                <i class="fa fa-clock-o"></i>
              </span>
              
                <span class="post-meta-item-text">阅读时长 &asymp;</span>
              
              <span>14 分钟</span>
            </span>
          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h2 id="基本原理"><a href="#基本原理" class="headerlink" title="基本原理"></a>基本原理</h2><p>Window 的实现类是 PhoneWindow，它是视图系统的核心，也是一切事件的起源。</p>
<p>Window 系统是通过 IPC 机制实现的，使用 WindowManager 来添加和移除控件，其实现类是 WindowManagerGlobal，其内部维持着以下四个集合</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">ArrayList&lt;View&gt; mViews = <span class="keyword">new</span> ArrayList&lt;View&gt;(); <span class="comment">// Window上存在的View集合</span></span><br><span class="line">ArrayList&lt;ViewRootImpl&gt; mRoots = <span class="keyword">new</span> ArrayList&lt;ViewRootImpl&gt;();</span><br><span class="line">ArrayList&lt;WindowManager.LayoutParams&gt; mParams;</span><br><span class="line">ArraySet&lt;View&gt; mDyingViews = <span class="keyword">new</span> ArraySet&lt;View&gt;();</span><br></pre></td></tr></table></figure>
<p><strong>在 Window 上添加 View 的逻辑就是更新这几个集合</strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">addView</span><span class="params">(View view, ViewGroup.LayoutParams params,  Display display, Window parentWindow)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">final</span> WindowManager.LayoutParams wparams = (WindowManager.LayoutParams) params;</span><br><span class="line">    ViewRootImpl root;</span><br><span class="line">    View panelParentView = <span class="keyword">null</span>;</span><br><span class="line">    <span class="keyword">synchronized</span> (mLock) &#123;</span><br><span class="line">        root = <span class="keyword">new</span> ViewRootImpl(view.getContext(), display);</span><br><span class="line">        view.setLayoutParams(wparams);</span><br><span class="line">        mViews.add(view);</span><br><span class="line">        mRoots.add(root);</span><br><span class="line">        mParams.add(wparams);</span><br><span class="line">    &#125;</span><br><span class="line">    root.setView(view, wparams, panelParentView);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>实际的工作交给了 ViewRootImpl。</p>
<h3 id="与-Activity-的关系"><a href="#与-Activity-的关系" class="headerlink" title="与 Activity 的关系"></a>与 Activity 的关系</h3><p>Window 与 Activity 实际是两个独立的系统，只不过二者有交集，<strong>Window 需要在 Activity 启动时展示其设置的布局而已</strong>。</p>
<p>在启动活动前，要进行 WindowManager 的初始化</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">WindowManagerGlobal.initialize();</span><br><span class="line">Activity a = performLaunchActivity(r, customIntent);</span><br></pre></td></tr></table></figure>
<p><strong>使用反射创建 Activity 对象后，将执行 attach 方法，此时将创建 PhoneWindow 并配置 WindowManager</strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">final</span> <span class="keyword">void</span> <span class="title">attach</span><span class="params">(Context context, ActivityThread aThread ，...)</span> </span>&#123;</span><br><span class="line">    attachBaseContext(context); <span class="comment">//attach 回调方法</span></span><br><span class="line">    mFragments.attachHost(<span class="keyword">null</span>);</span><br><span class="line">    mWindow = <span class="keyword">new</span> PhoneWindow(<span class="keyword">this</span>); <span class="comment">//创建 PhoneWindow 并配置 WindowManager</span></span><br><span class="line">    mWindow.setWindowManager(</span><br><span class="line">            (WindowManager)context.getSystemService(Context.WINDOW_SERVICE),</span><br><span class="line">            mToken, mComponent.flattenToString(),</span><br><span class="line">            (info.flags &amp; ActivityInfo.FLAG_HARDWARE_ACCELERATED) != <span class="number">0</span>);</span><br><span class="line">    mWindowManager = mWindow.getWindowManager();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><strong>Activity 的onCreate方法也在这一步进行，到此 Window 中的 decorView 将被设置好，只是没有添加到 Window 上去。</strong></p>
<p>而后是显示Activity 的 handleResumeActivity 方法，这里才利用 WindowManager 将 DecorView 添加到Window上去，参数全部由WindowManager.LayoutParams 决定。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">View decor = r.window.getDecorView();</span><br><span class="line">decor.setVisibility(View.INVISIBLE);</span><br><span class="line">ViewManager wm = a.getWindowManager();</span><br><span class="line">WindowManager.LayoutParams l = r.window.getAttributes();</span><br><span class="line">wm.addView(decor, l);</span><br></pre></td></tr></table></figure>
<h3 id="DecorView-和-ContentParent"><a href="#DecorView-和-ContentParent" class="headerlink" title="DecorView 和 ContentParent"></a>DecorView 和 ContentParent</h3><p>PhoneWindow 中会创建 DecorView 和 ContentParent 两个控件</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">installDecor</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (mDecor == <span class="keyword">null</span>) &#123;</span><br><span class="line">        mDecor = <span class="keyword">new</span> DecorView(getContext(), -<span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (mContentParent == <span class="keyword">null</span>) &#123;</span><br><span class="line">        mContentParent = generateLayout(mDecor);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><strong>mContentParent 的创建较为复杂，它会根据theme配置有所不同。</strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">protected</span> ViewGroup <span class="title">generateLayout</span><span class="params">(DecorView decor)</span> </span>&#123;</span><br><span class="line">    TypedArray a = getWindowStyle();</span><br><span class="line">    <span class="comment">//1.windowIsFloating决定是否采用floating，如果是则布局以WRAP_CONTENT计算，并清除其它flag</span></span><br><span class="line">    mIsFloating = a.getBoolean(R.styleable.Window_windowIsFloating, <span class="keyword">false</span>);</span><br><span class="line">    <span class="keyword">int</span> flagsToUpdate = (FLAG_LAYOUT_IN_SCREEN|FLAG_LAYOUT_INSET_DECOR)</span><br><span class="line">            &amp; (~getForcedWindowFlags());</span><br><span class="line">    <span class="keyword">if</span> (mIsFloating) &#123;</span><br><span class="line">        setLayout(WRAP_CONTENT, WRAP_CONTENT);</span><br><span class="line">        setFlags(<span class="number">0</span>, flagsToUpdate);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        setFlags(FLAG_LAYOUT_IN_SCREEN|FLAG_LAYOUT_INSET_DECOR, flagsToUpdate);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//2. Feature 参数决定了加载哪种系统布局，windowNoTitle和windowActionBar是互斥的</span></span><br><span class="line">    <span class="keyword">if</span> (a.getBoolean(R.styleable.Window_windowNoTitle, <span class="keyword">false</span>)) &#123;</span><br><span class="line">        requestFeature(FEATURE_NO_TITLE);</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (a.getBoolean(R.styleable.Window_windowActionBar, <span class="keyword">false</span>)) &#123;</span><br><span class="line">        requestFeature(FEATURE_ACTION_BAR);</span><br><span class="line">    &#125; </span><br><span class="line">    <span class="comment">// 比较特殊的 Feature 参数是FEATURE_CONTENT_TRANSITIONS和FEATURE_ACTIVITY_TRANSITIONS，它采用 Transition 动画</span></span><br><span class="line">    </span><br><span class="line">    <span class="comment">//3. Flag 参数决定了窗口类型，如全屏类型和TRANSLUCENT_STATUS</span></span><br><span class="line">    <span class="keyword">if</span> (a.getBoolean(R.styleable.Window_windowFullscreen, <span class="keyword">false</span>)) &#123;</span><br><span class="line">        setFlags(FLAG_FULLSCREEN, FLAG_FULLSCREEN &amp; (~getForcedWindowFlags()));</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (a.getBoolean(R.styleable.Window_windowTranslucentStatus,</span><br><span class="line">            <span class="keyword">false</span>)) &#123;</span><br><span class="line">        setFlags(FLAG_TRANSLUCENT_STATUS, ...);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//特殊的 flag 包括 windowDrawsSystemBarBackgrounds，必须配合statusBarColor才能生效</span></span><br><span class="line">    <span class="comment">// backgroundDimEnabled 背景是否模糊，设置FLAG_DIM_BEHIND，配合backgroundDimAmount生效</span></span><br><span class="line">    WindowManager.LayoutParams params = getAttributes();</span><br><span class="line">    <span class="comment">//根据不同的 feature 获得不同的布局资源，并加载到 window decor.</span></span><br><span class="line">    <span class="keyword">int</span> layoutResource = R.layout.screen_simple;</span><br><span class="line">    View in = mLayoutInflater.inflate(layoutResource, <span class="keyword">null</span>);</span><br><span class="line">    decor.addView(in, <span class="keyword">new</span> ViewGroup.LayoutParams(MATCH_PARENT, MATCH_PARENT));</span><br><span class="line">    mContentRoot = (ViewGroup) in;</span><br><span class="line">    <span class="comment">//返回ID为 ID_ANDROID_CONTENT 的内容控件</span></span><br><span class="line">    ViewGroup contentParent = (ViewGroup)findViewById(ID_ANDROID_CONTENT);</span><br><span class="line">    <span class="keyword">if</span> (contentParent == <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> RuntimeException(<span class="string">"Window couldn't find content container view"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> contentParent;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>到此为止内容控件只是一个占位控件，如在 R.layout.screen_simple 中</p>
<figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">LinearLayout</span> <span class="attr">xmlns:android</span>=<span class="string">"http://schemas.android.com/apk/res/android"</span></span></span><br><span class="line"><span class="tag">    <span class="attr">android:layout_width</span>=<span class="string">"match_parent"</span></span></span><br><span class="line"><span class="tag">    <span class="attr">android:layout_height</span>=<span class="string">"match_parent"</span></span></span><br><span class="line"><span class="tag">    <span class="attr">android:fitsSystemWindows</span>=<span class="string">"true"</span></span></span><br><span class="line"><span class="tag">    <span class="attr">android:orientation</span>=<span class="string">"vertical"</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">ViewStub</span> <span class="attr">android:id</span>=<span class="string">"@+id/action_mode_bar_stub"</span></span></span><br><span class="line"><span class="tag">              <span class="attr">android:inflatedId</span>=<span class="string">"@+id/action_mode_bar"</span></span></span><br><span class="line"><span class="tag">              <span class="attr">android:layout</span>=<span class="string">"@layout/action_mode_bar"</span></span></span><br><span class="line"><span class="tag">              <span class="attr">android:layout_width</span>=<span class="string">"match_parent"</span></span></span><br><span class="line"><span class="tag">              <span class="attr">android:layout_height</span>=<span class="string">"wrap_content"</span></span></span><br><span class="line"><span class="tag">              <span class="attr">android:theme</span>=<span class="string">"?attr/actionBarTheme"</span> /&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">FrameLayout</span></span></span><br><span class="line"><span class="tag">         <span class="attr">android:id</span>=<span class="string">"@android:id/content"</span></span></span><br><span class="line"><span class="tag">         <span class="attr">android:layout_width</span>=<span class="string">"match_parent"</span></span></span><br><span class="line"><span class="tag">         <span class="attr">android:layout_height</span>=<span class="string">"match_parent"</span></span></span><br><span class="line"><span class="tag">         <span class="attr">android:foregroundInsidePadding</span>=<span class="string">"false"</span></span></span><br><span class="line"><span class="tag">         <span class="attr">android:foregroundGravity</span>=<span class="string">"fill_horizontal|top"</span></span></span><br><span class="line"><span class="tag">         <span class="attr">android:foreground</span>=<span class="string">"?android:attr/windowContentOverlay"</span> /&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">LinearLayout</span>&gt;</span></span><br></pre></td></tr></table></figure>
<p>当活动启动时最终调用 setContentView 方法时将替换这个内容布局，这里将提供的布局加载到 @android:id/content 中去，并处理了设置 FEATURE_CONTENT_TRANSITIONS 的情况。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setContentView</span><span class="params">(<span class="keyword">int</span> layoutResID)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (mContentParent == <span class="keyword">null</span>) &#123;</span><br><span class="line">        installDecor();</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (!hasFeature(FEATURE_CONTENT_TRANSITIONS)) &#123;</span><br><span class="line">        mContentParent.removeAllViews();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (hasFeature(FEATURE_CONTENT_TRANSITIONS)) &#123;</span><br><span class="line">        <span class="keyword">final</span> Scene newScene = Scene.getSceneForLayout(mContentParent, layoutResID,</span><br><span class="line">                getContext());</span><br><span class="line">        transitionTo(newScene);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        mLayoutInflater.inflate(layoutResID, mContentParent);</span><br><span class="line">    &#125;</span><br><span class="line">    mContentParent.requestApplyInsets(); <span class="comment">//应用 Inset</span></span><br><span class="line">    <span class="keyword">final</span> Callback cb = getCallback();</span><br><span class="line">    <span class="keyword">if</span> (cb != <span class="keyword">null</span> &amp;&amp; !isDestroyed()) &#123;</span><br><span class="line">        cb.onContentChanged();           <span class="comment">//内容回调</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="WindowManager-LayoutParams"><a href="#WindowManager-LayoutParams" class="headerlink" title="WindowManager.LayoutParams"></a>WindowManager.LayoutParams</h3><p>对Window窗口的改变都是通过 WindowManager.LayoutParams 参数来实现的，最突出了莫过于 WindowInset 了。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> WindowInsets <span class="title">onApplyWindowInsets</span><span class="params">(WindowInsets insets)</span> </span>&#123;</span><br><span class="line">    mFrameOffsets.set(insets.getSystemWindowInsets());</span><br><span class="line">    insets = updateColorViews(insets, <span class="keyword">true</span> <span class="comment">/* animate */</span>);</span><br><span class="line">    insets = updateStatusGuard(insets);</span><br><span class="line">    updateNavigationGuard(insets);</span><br><span class="line">    <span class="keyword">return</span> insets;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>updateColorViews 方法的作用主要是处理横竖屏情况下的 WindowInsets ，并通过更新 statusBar 和 navigationBar 的布局参数来处理 WindowInsets事件。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> WindowInsets <span class="title">updateColorViews</span><span class="params">(WindowInsets insets, <span class="keyword">boolean</span> animate)</span> </span>&#123;</span><br><span class="line">    WindowManager.LayoutParams attrs = getAttributes();</span><br><span class="line">    <span class="keyword">int</span> sysUiVisibility = attrs.systemUiVisibility | getWindowSystemUiVisibility();</span><br><span class="line">    <span class="keyword">boolean</span> disallowAnimate = (mLastWindowFlags ^ attrs.flags)</span><br><span class="line">                    &amp; FLAG_DRAWS_SYSTEM_BAR_BACKGROUNDS != <span class="number">0</span>;</span><br><span class="line">    mLastWindowFlags = attrs.flags;</span><br><span class="line">    mLastTopInset = Math.min(insets.getStableInsetTop(),</span><br><span class="line">                        insets.getSystemWindowInsetTop());</span><br><span class="line">    mLastBottomInset = Math.min(insets.getStableInsetBottom(),</span><br><span class="line">                        insets.getSystemWindowInsetBottom());</span><br><span class="line">    mLastRightInset = Math.min(insets.getStableInsetRight(),</span><br><span class="line">                        insets.getSystemWindowInsetRight());</span><br><span class="line">    <span class="keyword">boolean</span> navBarToRightEdge = mLastBottomInset == <span class="number">0</span> &amp;&amp; mLastRightInset &gt; <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">int</span> navBarSize = navBarToRightEdge ? mLastRightInset : mLastBottomInset;</span><br><span class="line">    updateColorViewInt(mNavigationColorViewState, sysUiVisibility, mNavigationBarColor, navBarSize, navBarToRightEdge, <span class="number">0</span>, animate &amp;&amp; !disallowAnimate);</span><br><span class="line">      </span><br><span class="line">    <span class="keyword">boolean</span> statusBarNeedsRightInset = navBarToRightEdge</span><br><span class="line">                    &amp;&amp; mNavigationColorViewState.present;</span><br><span class="line">    <span class="keyword">int</span> statusBarRightInset = statusBarNeedsRightInset ? mLastRightInset : <span class="number">0</span>;</span><br><span class="line">    updateColorViewInt(mStatusColorViewState, sysUiVisibility, mStatusBarColor,</span><br><span class="line">                    mLastTopInset, <span class="keyword">false</span>, statusBarRightInset,</span><br><span class="line">                    animate &amp;&amp; !disallowAnimate);</span><br><span class="line">    <span class="keyword">return</span> insets;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>默认情况下 ColorViewState 配置了一个参数 systemUiHideFlag， 取值为 SYSTEM_UI_FLAG_FULLSCREEN，如果设置为改制，更新方法 updateColorViewInt 无效。</p>
<h2 id="与-Dialog-的关系"><a href="#与-Dialog-的关系" class="headerlink" title="与 Dialog 的关系"></a>与 Dialog 的关系</h2><p>Dialog 的构造方法如下</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">Dialog(<span class="meta">@NonNull</span> Context context, <span class="meta">@StyleRes</span> <span class="keyword">int</span> themeResId) &#123; </span><br><span class="line">    <span class="comment">//1.从配置文件中虚招主题，并构建 ContextThemeWrapper</span></span><br><span class="line">    TypedValue outValue = <span class="keyword">new</span> TypedValue();</span><br><span class="line">    context.getTheme().resolveAttribute(R.attr.dialogTheme, outValue, <span class="keyword">true</span>);</span><br><span class="line">    themeResId = outValue.resourceId;</span><br><span class="line">    mContext = <span class="keyword">new</span> ContextThemeWrapper(context, themeResId);</span><br><span class="line">    mWindowManager = (WindowManager) context.getSystemService(Context.WINDOW_SERVICE);</span><br><span class="line">    <span class="comment">//2.创建 PhoneWindow 对象并居中</span></span><br><span class="line">    <span class="keyword">final</span> Window w = <span class="keyword">new</span> PhoneWindow(mContext);</span><br><span class="line">    w.setGravity(Gravity.CENTER);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这里明白的显示了一个 Dialog 就是一个 Window，显示什么内容也遵循 Window 的规律，使用 setContentView 来添加自定义布局。</p>
<p><strong>至于显示则是利用 WindowManager 将准备好的 DecorView 添加到 Window 上去。</strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">show</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    mDecor = mWindow.getDecorView();</span><br><span class="line">    mWindowManager.addView(mDecor, l);</span><br><span class="line">    mShowing = <span class="keyword">true</span>;</span><br><span class="line">    sendShowMessage();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><strong>同理 hide() 方法实际就是隐藏 DecorView，dismiss 方法就是使用 WindowManager 移除 DecorView。</strong></p>
<p>Dialog 的若干子类不过是配置它的布局而已，此外 Dilog 没有生命周期。</p>
<h2 id="状态栏染色"><a href="#状态栏染色" class="headerlink" title="状态栏染色"></a>状态栏染色</h2><p>我们已经知道状态栏的染色是通过添加View来完成的，其必须满足条件</p>
<figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">item</span> <span class="attr">name</span>=<span class="string">"android:windowDrawsSystemBarBackgrounds"</span>&gt;</span>true<span class="tag">&lt;/<span class="name">item</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">item</span> <span class="attr">name</span>=<span class="string">"android:windowTranslucentStatus"</span>&gt;</span>false<span class="tag">&lt;/<span class="name">item</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">item</span> <span class="attr">name</span>=<span class="string">"android:statusBarColor"</span>&gt;</span>#FF786312<span class="tag">&lt;/<span class="name">item</span>&gt;</span> //非必须</span><br></pre></td></tr></table></figure>
<p>动态染色可以采用如下办法</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">getWindow().setStatusBarColor(Color.MAGENTA);</span><br></pre></td></tr></table></figure>
<p>实际上这个 View 是这样定义的</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">final</span> ColorViewState mStatusColorViewState = <span class="keyword">new</span> ColorViewState(</span><br><span class="line">            SYSTEM_UI_FLAG_FULLSCREEN, FLAG_TRANSLUCENT_STATUS,</span><br><span class="line">            Gravity.TOP,</span><br><span class="line">            Gravity.LEFT,</span><br><span class="line">            STATUS_BAR_BACKGROUND_TRANSITION_NAME,</span><br><span class="line">            com.android.internal.R.id.statusBarBackground, <span class="comment">//id</span></span><br><span class="line">            FLAG_FULLSCREEN);</span><br></pre></td></tr></table></figure>
<p>我们也完全可以这样做</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">View view = findViewById(android.R.id.statusBarBackground);<span class="comment">//获取 StatusColorView</span></span><br><span class="line">view.setBackgroundColor(Color.YELLOW);</span><br></pre></td></tr></table></figure>
<p>如果播放一个动画，就能完全看清楚这个 View</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">v.animate().setDuration(<span class="number">2000</span>).setInterpolator(<span class="keyword">new</span> CycleInterpolator(<span class="number">0.5f</span>)).translationY(<span class="number">200</span>).start();</span><br></pre></td></tr></table></figure>
<p>这一过程的实现如下</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">* Update a color view</span></span><br><span class="line"><span class="comment">*</span></span><br><span class="line"><span class="comment">* <span class="doctag">@param</span> state the color view to update.</span></span><br><span class="line"><span class="comment">* <span class="doctag">@param</span> sysUiVis the current systemUiVisibility to apply.</span></span><br><span class="line"><span class="comment">* <span class="doctag">@param</span> color the current color to apply.</span></span><br><span class="line"><span class="comment">* <span class="doctag">@param</span> size the current size in the non-parent-matching dimension.</span></span><br><span class="line"><span class="comment">* <span class="doctag">@param</span> verticalBar if true view is attached to a vertical edge, otherwise to a</span></span><br><span class="line"><span class="comment">*                    horizontal edge,</span></span><br><span class="line"><span class="comment">* <span class="doctag">@param</span> rightMargin rightMargin for the color view.</span></span><br><span class="line"><span class="comment">* <span class="doctag">@param</span> animate if true, the change will be animated.</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">updateColorViewInt</span><span class="params">(<span class="keyword">final</span> ColorViewState state, <span class="keyword">int</span> sysUiVis, <span class="keyword">int</span> color,</span></span></span><br><span class="line"><span class="function"><span class="params">            <span class="keyword">int</span> size, <span class="keyword">boolean</span> verticalBar, <span class="keyword">int</span> rightMargin, <span class="keyword">boolean</span> animate)</span> </span>&#123;</span><br><span class="line">    <span class="comment">//1.判断是否存在更新的条件，包括 inset 的尺寸要有，flag 不能有 hideWindowFlag，必须有 FLAG_DRAWS_SYSTEM_BAR_BACKGROUNDS</span></span><br><span class="line">    state.present = size &gt; <span class="number">0</span> &amp;&amp; (sysUiVis &amp; state.systemUiHideFlag) == <span class="number">0</span></span><br><span class="line">                &amp;&amp; (getAttributes().flags &amp; state.hideWindowFlag) == <span class="number">0</span></span><br><span class="line">                &amp;&amp; (getAttributes().flags &amp; FLAG_DRAWS_SYSTEM_BAR_BACKGROUNDS) != <span class="number">0</span>;</span><br><span class="line">    <span class="comment">//2.判断是否要显示，包括颜色不能是黑色，flag 不能配置成 translucent</span></span><br><span class="line">    <span class="keyword">boolean</span> show = state.present</span><br><span class="line">                &amp;&amp; (color &amp; Color.BLACK) != <span class="number">0</span></span><br><span class="line">                &amp;&amp; (getAttributes().flags &amp; state.translucentFlag) == <span class="number">0</span>;</span><br><span class="line">    View view = state.view;</span><br><span class="line">    <span class="keyword">int</span> resolvedHeight = verticalBar ? LayoutParams.MATCH_PARENT : size;</span><br><span class="line">    <span class="keyword">int</span> resolvedWidth = verticalBar ? size : LayoutParams.MATCH_PARENT;</span><br><span class="line">    <span class="keyword">int</span> resolvedGravity = verticalBar ? state.horizontalGravity : state.verticalGravity;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//通过添加一个带颜色的 View ，并更新其 LayoutParams 参数实现效果。</span></span><br><span class="line">    <span class="keyword">if</span> (view == <span class="keyword">null</span>) &#123;</span><br><span class="line">            state.view = view = <span class="keyword">new</span> View(mContext);</span><br><span class="line">            view.setBackgroundColor(color);</span><br><span class="line">            view.setVisibility(INVISIBLE);</span><br><span class="line">            LayoutParams lp = <span class="keyword">new</span> LayoutParams(resolvedWidth, resolvedHeight,</span><br><span class="line">                        resolvedGravity);</span><br><span class="line">            lp.rightMargin = rightMargin;</span><br><span class="line">            addView(view, lp);</span><br><span class="line">            updateColorViewTranslations(); <span class="comment">//使用动画效果</span></span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            LayoutParams lp = (LayoutParams) view.getLayoutParams();</span><br><span class="line">            lp.height = resolvedHeight;</span><br><span class="line">            lp.width = resolvedWidth;</span><br><span class="line">            lp.gravity = resolvedGravity;</span><br><span class="line">            lp.rightMargin = rightMargin;</span><br><span class="line">            view.setLayoutParams(lp);</span><br><span class="line">            view.setBackgroundColor(color);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (animate) &#123;</span><br><span class="line">         view.animate().alpha(<span class="number">1.0f</span>).setInterpolator(mShowInterpolator).</span><br><span class="line">                            setDuration(mBarEnterExitDuration);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>
<p><strong>这里 windowDrawsSystemBarBackgrounds 和 windowTranslucentStatus 是互相排斥的，想要改变状态栏颜色，必须使用前者，禁止后者。后者一旦生效，上述方法将无效，View 不会被创建。</strong></p>
<h4 id="WindowSystemUiVisibility"><a href="#WindowSystemUiVisibility" class="headerlink" title="WindowSystemUiVisibility"></a>WindowSystemUiVisibility</h4><p>SystemUiVisibility 能够完成的动作完全可以通过设置 Window 来完成，但好处在于随时可以清除效果。</p>
<p>SystemUiVisibility 的设置必染色要复杂，涉及状态栏和布局的变化，不过在回调中也会执行更新方法</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onWindowSystemUiVisibilityChanged</span><span class="params">(<span class="keyword">int</span> visible)</span> </span>&#123;</span><br><span class="line">    updateColorViews(<span class="keyword">null</span>, <span class="keyword">true</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li>View.SYSTEM_UI_FLAG_FULLSCREEN 这种情况下，状态栏将彻底消失，内容布局扩展到全屏模式<ul>
<li>SYSTEM_UI_FLAG_IMMERSIVE 默认情况下，触摸下拉会出现通知栏，必须手动清除才能取消 SYSTEM_UI_FLAG_FULLSCREEN 的效果；配合该标记能够下拉出状态栏，且立即清除效果</li>
<li>SYSTEM_UI_FLAG_IMMERSIVE_STICKY 下拉出原生未染色的的状态栏，且不清除效果</li>
</ul>
</li>
<li>View.SYSTEM_UI_FLAG_LAYOUT_FULLSCREEN 内容布局到全屏，且给ActionBar设置一个padding显示状态栏，一旦清除，布局回收，该Padding还在</li>
<li>View.SYSTEM_UI_FLAG_LAYOUT_STABLE 配合上述设置，使得更改永久生效，清除之后布局不回收</li>
</ul>
<h3 id="Toolbar"><a href="#Toolbar" class="headerlink" title="Toolbar"></a>Toolbar</h3><p>最后在说下 ActionBar 和 Toolbar 的关系</p>
<p>设置 Toolbar 的方法如下，首先要判断是否已经存在 ActionBar，通常如果使用 FEATURE_ACTION_BAR 则会初始化 ActionBar， 实现类是 WindowDecorActionBar</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Nullable</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> ActionBar <span class="title">getActionBar</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    Window window = getWindow();</span><br><span class="line">    <span class="keyword">if</span> (!window.hasFeature(Window.FEATURE_ACTION_BAR) || mActionBar != <span class="keyword">null</span>) <span class="keyword">return</span>;</span><br><span class="line">    mActionBar = <span class="keyword">new</span> WindowDecorActionBar(<span class="keyword">this</span>);</span><br><span class="line">    <span class="keyword">return</span> mActionBar;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>如果没有，可以正常进行，新建的实现类是 ToolbarActionBar。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setActionBar</span><span class="params">(@Nullable Toolbar toolbar)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (getActionBar() <span class="keyword">instanceof</span> WindowDecorActionBar) &#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> IllegalStateException(<span class="string">"This Activity already has an action bar supplied "</span> + <span class="string">"by the window decor. Do not request Window.FEATURE_ACTION_BAR and set "</span> +</span><br><span class="line"><span class="string">"android:windowActionBar to false in your theme to use a Toolbar instead."</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    ToolbarActionBar tbab = <span class="keyword">new</span> ToolbarActionBar(toolbar, getTitle(), <span class="keyword">this</span>);</span><br><span class="line">    mActionBar = tbab;</span><br><span class="line">    mActionBar.invalidateOptionsMenu();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>可见 ActionBar 和 Toolbar 是表里的关系。你可以处理菜单相关的事项</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">Menu <span class="title">getMenu</span><span class="params">()</span></span>;</span><br><span class="line">inflateMenu(R.menu.menu_main);</span><br><span class="line"><span class="function"><span class="keyword">boolean</span> <span class="title">showOverflowMenu</span><span class="params">()</span></span>; <span class="comment">//通过反射修改显示 OverflowMenu</span></span><br><span class="line"><span class="function"><span class="keyword">boolean</span> <span class="title">hideOverflowMenu</span><span class="params">()</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">setOnMenuItemClickListener</span><span class="params">(OnMenuItemClickListener listener)</span></span>;</span><br></pre></td></tr></table></figure>
<p>也可以使用动画</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ViewPropertyAnimator toolbarAnimator = toolbar.animate();</span><br></pre></td></tr></table></figure>

        
      
    </div>

    
    
    
      <footer class="post-footer">
          <div class="post-eof"></div>
        
      </footer>
  </div>
  
  
  
  </article>

    
        <article itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block home">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2017/05/18/android/系统/Activity/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="xiang">
      <meta itemprop="description" content="谨守而勿失，是谓反其真">
      <meta itemprop="image" content="/images/1.jpg">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="lxt">
    </span>
      <header class="post-header">
        <h1 class="post-title" itemprop="name headline">
            
            <a href="/2017/05/18/android/系统/Activity/" class="post-title-link" itemprop="url">Activity</a>
          
        </h1>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              
                
              

              <time title="创建时间：2017-05-18 11:26:26" itemprop="dateCreated datePublished" datetime="2017-05-18T11:26:26+08:00">2017-05-18</time>
            </span>
          
            

            
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="fa fa-calendar-check-o"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2019-09-17 23:11:27" itemprop="dateModified" datetime="2019-09-17T23:11:27+08:00">2019-09-17</time>
              </span>
            
          
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing"><a href="/categories/android/" itemprop="url" rel="index"><span itemprop="name">android</span></a></span>

                
                
                  ，
                
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing"><a href="/categories/android/系统/" itemprop="url" rel="index"><span itemprop="name">系统</span></a></span>

                
                
              
            </span>
          

          
          <br>
            <span class="post-meta-item" title="本文字数">
              <span class="post-meta-item-icon">
                <i class="fa fa-file-word-o"></i>
              </span>
              
                <span class="post-meta-item-text">本文字数：</span>
              
              <span>13k</span>
            </span>
          
            <span class="post-meta-item" title="阅读时长">
              <span class="post-meta-item-icon">
                <i class="fa fa-clock-o"></i>
              </span>
              
                <span class="post-meta-item-text">阅读时长 &asymp;</span>
              
              <span>12 分钟</span>
            </span>
          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h2 id="启动流程"><a href="#启动流程" class="headerlink" title="启动流程"></a>启动流程</h2><p>使用 Context 启动活动的方法如下</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">startActivity</span><span class="params">(Intent intent)</span></span>;</span><br></pre></td></tr></table></figure>
<p><strong>其实际流程如图俄罗斯瓷娃娃一样，分别经过ContextImpl，Instrumentation和AMS的处理。</strong></p>
<p>1。首先是 ContextImpl 类，它委托给了Instrumentation 类，自己仅仅检查线程和 flag 参数。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">startActivity</span><span class="params">(Intent intent, Bundle options)</span> </span>&#123;</span><br><span class="line">    warnIfCallingFromSystemProcess();</span><br><span class="line">    <span class="keyword">if</span> ((intent.getFlags()&amp;Intent.FLAG_ACTIVITY_NEW_TASK) == <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> AndroidRuntimeException(</span><br><span class="line">                <span class="string">"Calling startActivity() from outside of an Activity "</span></span><br><span class="line">                + <span class="string">" context requires the FLAG_ACTIVITY_NEW_TASK flag."</span></span><br><span class="line">                + <span class="string">" Is this really what you want?"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    mMainThread.getInstrumentation().execStartActivity(</span><br><span class="line">            getOuterContext(), mMainThread.getApplicationThread(), <span class="keyword">null</span>,</span><br><span class="line">            (Activity) <span class="keyword">null</span>, intent, -<span class="number">1</span>, options);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><strong>这里应该注意如果不是从 Activity 中启动活动，则需要添加 FLAG_ACTIVITY_NEW_TASK 标记，否则将抛出异常。</strong></p>
<p>活动启动的结果用 Instrumentation.ActivityResult 类表示，其定义如下</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">final</span> <span class="keyword">int</span> mResultCode;</span><br><span class="line"><span class="keyword">private</span> <span class="keyword">final</span> Intent mResultData;</span><br></pre></td></tr></table></figure>
<p>而后将对该结果进行检测处理，采用主线程 Handler 机制进行，发生消息为 H.SEND_RESULT ，响应方法为</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">handleSendResult</span><span class="params">(ResultData res)</span></span></span><br></pre></td></tr></table></figure>
<p>该方法中将分发处理结果( dispatchActivityResult )，并调用 onActivityResult(requestCode, resultCode, data) 方法。</p>
<p>2。其次是 Instrumentation 类，它委托给AMS来完成，自己只检查下结果，验证活动是否能够正确启动。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">ActivityResult <span class="title">execStartActivity</span><span class="params">(...)</span></span>&#123;</span><br><span class="line">    IApplicationThread whoThread = (IApplicationThread) contextThread;     </span><br><span class="line">    <span class="keyword">int</span> result = ActivityManagerNative.getDefault().startActivity(...);    </span><br><span class="line">    checkStartActivityResult(result, intent);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>如结果是 ActivityManager.START_CLASS_NOT_FOUND 会爆出常见异常</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Unable to find explicit activity <span class="class"><span class="keyword">class</span> </span>; have you declared <span class="keyword">this</span> activity in your AndroidManifest.xml?<span class="string">"</span></span><br></pre></td></tr></table></figure>
<p>3。最后是AMS ，启动活动会经过一系列复杂的流转，涉及到活动栈的处理等，但最终会回到 ActivityThread 类中来。</p>
<p>在 ActivityThread的 main 方法中，启动了主线程的 Looper 循环。启动活动将发送一个 LAUNCH_ACTIVITY 消息，而后使用内部类 H 来处理该消息。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">ActivityClientRecord r = (ActivityClientRecord) msg.obj;</span><br><span class="line">handleLaunchActivity(r, <span class="keyword">null</span>);</span><br></pre></td></tr></table></figure>
<p>handleLaunchActivity 方法将完成 WindowManager 初始化，并利用反射创建活动对象</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">handleLaunchActivity</span><span class="params">(ActivityClientRecord r, Intent customIntent)</span> </span>&#123;	</span><br><span class="line">    <span class="comment">//1. WindowManager初始化    </span></span><br><span class="line">    WindowManagerGlobal.initialize();    </span><br><span class="line">    Activity a = performLaunchActivity(r, customIntent);    </span><br><span class="line">    <span class="keyword">if</span> (a != <span class="keyword">null</span>) &#123;        </span><br><span class="line">        handleResumeActivity(r.token, <span class="keyword">false</span>, r.isForward);    </span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;        </span><br><span class="line">        ActivityManagerNative.getDefault().finishActivity(r.tokene);    </span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>performLaunchActivity 方法创建活动，</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> Activity <span class="title">performLaunchActivity</span><span class="params">(ActivityClientRecord r, Intent customIntent)</span></span>&#123;	</span><br><span class="line">    Activity activity = mInstrumentation.newActivity(...);        </span><br><span class="line">    Application app = r.packageInfo.makeApplication(<span class="keyword">false</span>, mInstrumentation);	</span><br><span class="line">    Context appContext = createBaseContextForActivity(r, activity);	</span><br><span class="line">    Configuration config = <span class="keyword">new</span> Configuration(mCompatConfiguration);        </span><br><span class="line">    activity.attach(...);                    </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>其中 attach 方法创建了 Window 的实例。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">attach</span><span class="params">(Context context)</span></span>&#123;</span><br><span class="line">    mWindow = <span class="keyword">new</span> PhoneWindow(<span class="keyword">this</span>);    </span><br><span class="line">    mWindow.setCallback(<span class="keyword">this</span>);	</span><br><span class="line">    mWindow.setUiOptions(info.uiOptions);	</span><br><span class="line">    mWindow.setWindowManager()</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>如果活动创建失败，则结束；如果成功，handleResumeActivity 方法会将 DecorView 对象渲染到窗口 PhoneWindow 上去，但注意<strong>此时该控件是不可见的</strong>。如果启动成功，在处理结果的时候后将可见性改为可见。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">handleResumeActivity</span><span class="params">(IBinder token, ...)</span></span>&#123;	</span><br><span class="line">    ActivityClientRecord r = performResumeActivity(token, clearHide);	</span><br><span class="line">    Activity a = r.activity;	</span><br><span class="line">    r.window = r.activity.getWindow();    </span><br><span class="line">    View decor = r.window.getDecorView();    </span><br><span class="line">    decor.setVisibility(View.INVISIBLE);    </span><br><span class="line">    ViewManager wm = a.getWindowManager();    </span><br><span class="line">    WindowManager.LayoutParams l = r.window.getAttributes();    </span><br><span class="line">    a.mDecor = decor;    </span><br><span class="line">    l.type = WindowManager.LayoutParams.TYPE_BASE_APPLICATION;    </span><br><span class="line">    <span class="keyword">if</span> (a.mVisibleFromClient) &#123;         </span><br><span class="line">        a.mWindowAdded = <span class="keyword">true</span>;         </span><br><span class="line">        wm.addView(decor, l);    </span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>因为 AMS 是单例实现，Hook 掉 AMS 非常容易，详情见<a href="http://weishu.me/2016/03/07/understand-plugin-framework-ams-pms-hook/" target="_blank" rel="noopener">weishu的文章</a></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">Class amsClass = Class.forName(<span class="string">"android.app.ActivityManagerNative"</span>);</span><br><span class="line">Method getDefaultMethod = amsClass.getDeclaredMethod(<span class="string">"getDefault"</span>);</span><br><span class="line">Object iActivityManager = getDefaultMethod.invoke(<span class="keyword">null</span>);</span><br><span class="line">Field gDefaultField = amsClass.getDeclaredField(<span class="string">"gDefault"</span>);</span><br><span class="line">gDefaultField.setAccessible(<span class="keyword">true</span>);</span><br><span class="line">Object gDefaultSingleton = gDefaultField.get(<span class="keyword">null</span>);</span><br><span class="line">Class&lt;?&gt; singletonClass = Class.forName(<span class="string">"android.util.Singleton"</span>);</span><br><span class="line">Field mInstanceField = singletonClass.getDeclaredField(<span class="string">"mInstance"</span>);</span><br><span class="line">mInstanceField.setAccessible(<span class="keyword">true</span>);</span><br><span class="line">Class&lt;?&gt; iActivityManagerInterface = Class.forName(<span class="string">"android.app.IActivityManager"</span>);</span><br><span class="line">Object mInstance = Proxy.newProxyInstance(gDefaultSingleton.getClass().getClassLoader(),        <span class="keyword">new</span> Class[]&#123;</span><br><span class="line">    iActivityManagerInterface&#125;,<span class="keyword">new</span> ActivityManagerHandler(iActivityManager));</span><br><span class="line">mInstanceField.set(gDefaultSingleton, mInstance);</span><br></pre></td></tr></table></figure>
<h2 id="生命周期"><a href="#生命周期" class="headerlink" title="生命周期"></a>生命周期</h2><p>在理解了启动流程后，更容易理解生命周期，正常的启动和退出流程是</p>
<p>启动(post 方法等为碎片而存在)：</p>
<blockquote>
<p>onCreate –&gt; onStart –&gt; onPostCreate –&gt; onResume –&gt; onPostResume –&gt; onAttachedToWindow</p>
</blockquote>
<p>退出：</p>
<blockquote>
<p>onPause –&gt; onStop –&gt; onDestroy –&gt; onDetachedFromWindow</p>
</blockquote>
<p>如果中途切换其它 App</p>
<blockquote>
<p>onPause –&gt; <strong>onSaveInstanceState</strong> –&gt; onStop</p>
</blockquote>
<p>恢复页面</p>
<blockquote>
<p><strong>onRestart</strong> –&gt; onStart –&gt; onResume –&gt; onPostResume</p>
</blockquote>
<p>使用adb命令回收Activity(adb shell am force-stop [包名])，与正常退出一致。</p>
<p>如果使用下列方法<strong>旋转屏幕(可以靠重力感应完成，会销毁和重建活动)</strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">setRequestedOrientation(ActivityInfo.SCREEN_ORIENTATION_PORTRAIT);</span><br></pre></td></tr></table></figure>
<p>则生命周期如下，这里调用保存和恢复方法，也可以在onCreate方法中恢复。</p>
<blockquote>
<p>onPause –&gt; <strong>onSaveInstanceState</strong> –&gt; onStop –&gt; onDestroy –&gt; onDetachedFromWindow–&gt;</p>
<p><strong>onCreate</strong> –&gt; onStart –&gt; <strong>onRestoreInstanceState</strong> –&gt; onResume –&gt; onAttachedToWindow</p>
</blockquote>
<p><strong>这和使用 recreate()方法效果一样。</strong></p>
<p>做如下配置可以避免重建，只执行 onConfig 方法</p>
<figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">android:configChanges="keyboard|screenSize|orientation"</span><br></pre></td></tr></table></figure>
<p><strong>此外启动栈内已存在的活动将会调用 onNewIntent 方法。</strong></p>
<h3 id="保存和恢复"><a href="#保存和恢复" class="headerlink" title="保存和恢复"></a><a href="https://github.com/frankiesardo/icepick" target="_blank" rel="noopener">保存和恢复</a></h3><p>活动的保存和恢复是向下分发的，碎片和View都受到影响。如 View会构建一个BaseSavedState对象</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">protected</span> Parcelable <span class="title">onSaveInstanceState</span><span class="params">()</span> </span>&#123;    </span><br><span class="line">    mPrivateFlags |= PFLAG_SAVE_STATE_CALLED;    </span><br><span class="line">    <span class="keyword">if</span> (mStartActivityRequestWho != <span class="keyword">null</span>) &#123;        </span><br><span class="line">        BaseSavedState state = <span class="keyword">new</span> BaseSavedState(AbsSavedState.EMPTY_STATE);        </span><br><span class="line">        state.mStartActivityRequestWhoSaved = mStartActivityRequestWho;        </span><br><span class="line">        <span class="keyword">return</span> state;    </span><br><span class="line">    &#125;    </span><br><span class="line">    <span class="keyword">return</span> BaseSavedState.EMPTY_STATE;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>使用时获取并扩展该对象，写入数据即可。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">SavedState</span> <span class="keyword">extends</span> <span class="title">BaseSavedState</span> </span>&#123;    </span><br><span class="line">    CharSequence text;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="任务栈"><a href="#任务栈" class="headerlink" title="任务栈"></a>任务栈</h2><p>Activity 的启动跳转关系与<strong>Task（任务）和 Back Stack（回退栈）</strong>紧密相连，<code>Task</code> 是一个<strong>Framework</strong>层概念，<strong>专指在程序运行时一组相互关联的activity的集合，负责控制界面的跳转和返回</strong>。<strong>Back Stack</strong>则是实现 Task 所用的数据结构，拥有栈的特点.</p>
<p>下面三个属性会影响<strong>Task</strong>和<strong>Back Stack</strong>的状态。</p>
<ul>
<li><strong>活动的启动模式</strong></li>
<li><strong>taskAffinity属性</strong></li>
<li><strong>intent的flag属性</strong></li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">android:launchMode=<span class="string">"standard"</span></span><br><span class="line">android:taskAffinity=<span class="string">"con.incredible"</span></span><br><span class="line">intent.setFlags(Intent.FLAG_ACTIVITY_NEW_TASK);</span><br></pre></td></tr></table></figure>
<p>简单说来</p>
<ul>
<li>启动模式为<strong>standard</strong>或<strong>singleTop</strong>时，Activity 一般在同一个栈中。</li>
<li>启动模式为<strong>singleTask</strong>或<strong>singleInstance</strong>时，一般会产生新的任务栈。</li>
</ul>
<h3 id="Task和Back-Stack"><a href="#Task和Back-Stack" class="headerlink" title="Task和Back Stack"></a><strong>Task和Back Stack</strong></h3><p>默认情况下，某个<strong>Application</strong>中所有<strong>activity</strong>都处在同一个<strong>Task</strong>中。但二者并没有严格的约束条件，这里有两种情况：</p>
<ul>
<li>两个<strong>Application</strong>中的<strong>activity</strong>可以处在同一个<strong>Task</strong>中。即 <strong>task 是可以跨应用的，这正是task存在的一个重要原因</strong>。</li>
<li>一个<strong>Application</strong>中的<strong>activity</strong>也可以处于多个<strong>Task</strong>中。</li>
</ul>
<p>例如在应用中的一个Activity A中使用系统邮件，会启动系统邮件程序的一个Activity B。这两个activity是存在于不同app中的，但是被系统放在一个task中,这样能保证程序回退到原有程序中。</p>
<p>设备Home界面是大多数tasks的起始点。<strong>当用户点击程序在Home上的启动图标时，这个程序的task就转入前台。如果程序没有打开，那么之前不存在task，一个新的task将被创建并且程序的”main” 活动将被打开并被推入栈中；如果程序已经打开，则已经存在Task，就恢复显示栈顶的活动。</strong></p>
<p><strong>当目前的activity启动另外一个activity时，新的activity被压入栈中作为栈顶并且获取到了focus。前面的那个activity则进入stopped状态，此时系统会保留它的UI状态以便恢复。当用户点击back按钮时，栈顶的activity从栈顶退出并被destroyed，之前处于stopped状态的activity则进入resume状态(其保存的UI状态得到恢复).</strong></p>
<p><img src="http://hukai.me/images/articles/diagram_backstack.png" alt="1"></p>
<p>如果用户持续点击back按钮，那么在栈中的每一个activity都会做退栈并显示之前activity的动作, 直到用户退回到Home界面(或者是用户开始task的地方)。<strong>当所有的activities都从栈中被移除之后，这个task也就消失了。</strong></p>
<p>一个task是一个紧密结合的单元，处于后台的task中的所有活动都处于stopped状态，只有task转移到前台，栈顶的活动显示。<strong>众多tasks都可以一并在后台被Hold住，然而系统为了恢复内存而有可能销毁这些栈中的activities。</strong></p>
<p><strong>此时activity的状态信息则会丢失. 但系统仍然为那个activity在back stack中保留了位置, 但是当这个activity成为栈顶activity时, 系统必须recreate它(而不是resume它)，这时需要使用者主动实现onSaveInstanceState()回调方法来保存恢复所需的信息。</strong></p>
<blockquote>
<p>在activity中调用 moveTaskToBack (boolean nonRoot)方法即可将activity 退到后台，注意不是finish()退出。</p>
</blockquote>
<h3 id="启动模式"><a href="#启动模式" class="headerlink" title="启动模式"></a><a href="http://ltlovezh.com/2016/08/28/Activity启动模式一/" target="_blank" rel="noopener">启动模式</a></h3><p><strong>每个活动的创建有两步：以下对四种启动模式的分析都从这两步进行</strong></p>
<p>1.判断是否创建新任务栈，即<strong>新Task</strong>。<br>2.判断是否创建新活动，即<strong>新 Activity</strong>。</p>
<p><strong>活动如何创建</strong>主要受两个因素影响：<strong>taskAffinity属性</strong>与<strong>启动模式</strong>。</p>
<p>a.taskAffinity 属性意味着 activity 更倾向归属于哪一个task，可以认为它指定了<strong>activity</strong>所在的<strong>task</strong>名称，这一属性是活动处在不同的<code>Task</code>中的<strong>必要不充分条件</strong>。使用<strong>taskAffinity</strong>属性的一些原则是：</p>
<p>1.如果不设置某活动的<strong>taskAffinity</strong>属性，则该属性值与启动它的活动相同。第一个活动的该属性为应用的包名。<br>2.<strong>taskAffinity</strong>属性并不能唯一决定活动所在的栈，还要受到<strong>启动模式</strong>影响。</p>
<p><strong>举例</strong>:假设某个APP内的活动启动顺序为：<strong>a-b-c-d</strong>。如果采用默认配置，则abcd四个活动都将处在名称为包名的 Task 中。</p>
<p><strong>b.启动模式</strong><br>设置活动和 Task 的关系。<strong>一共有四种启动模式：为</strong>standard<strong>，</strong>singleTop<strong>，</strong>singleTask<strong>，</strong>singleInstance。</p>
<h4 id="Standard-默认模式"><a href="#Standard-默认模式" class="headerlink" title="Standard(默认模式)"></a><strong>Standard(默认模式)</strong></h4><p>1.taskAffinity 属性无效。即使设置也并不会创建新 Task ，活动所处的 task 与启动它的活动永远保持一致。</p>
<p>2.活动的创建百无禁忌，不需要任何检查就创建新的活动实例，因为<strong>能够重复创建活动实例</strong>。</p>
<h4 id="SingleTop"><a href="#SingleTop" class="headerlink" title="SingleTop"></a><strong>SingleTop</strong></h4><ol>
<li>taskAffinity 属性同样无效。</li>
</ol>
<p>2.与标准模式的区别在于第二步， SingleTop 模式对活动的创建做了一个<strong>较弱的约束</strong>，即<strong>不允许创建与栈顶重复的活动实例</strong>。会检查<strong>活动返回栈的栈顶活动</strong>是否是待启动的活动类，如果是则不会创建活动实例。</p>
<p>如当前活动栈是<code>a-b-c-d</code>。如果再启动<code>d</code>，仍是<code>a-b-c-d</code>；启动<code>a</code>，将是<code>a-b-c-d-a</code>。</p>
<h4 id="SingleTask"><a href="#SingleTask" class="headerlink" title="SingleTask"></a><strong>SingleTask</strong></h4><p>前两种模式中， taskAffinity 属性都是无效的，不会对新活动所处的 task 产生影响。 singleTask 模式下， taskAffinity 属性终于获得用武的机会，将对<strong>task</strong>产生影响。</p>
<p>1.在新活动<strong>c</strong>创建时，先查看是否存在与其<strong>taskAffinity</strong>属性相同的<strong>task</strong>。</p>
<ul>
<li>如果存在，不会创建新<strong>task</strong>。</li>
<li>如果不存在，则创建以<strong>taskAffinity</strong>属性为名的新<strong>task</strong>。</li>
</ul>
<p>如果不设置<strong>taskAffinity</strong>属性，则该属性值与启动它的活动一致，此时不会产生新的<strong>task</strong>。</p>
<p>2.再在选中的<strong>task</strong>中查找有无活动<strong>c</strong>实例。</p>
<ul>
<li><strong>有则将该task中c实例之上的活动全部出栈，使得该实例处在栈顶;</strong></li>
<li>没有则在栈顶上新建活动<code>c</code>.</li>
</ul>
<h4 id="SingleInstance"><a href="#SingleInstance" class="headerlink" title="SingleInstance"></a><strong>SingleInstance</strong></h4><p>SingleInstance 模式中，<strong>taskAffinity 属性再次失效</strong>，活动总会在新 Task 中启动。</p>
<p>1.不管怎么设置<strong>taskAffinity</strong>属性，活动总是会在<strong>新的任务task</strong>中运行。</p>
<p>2.以 SingleInstance 模式启动的活动<strong>在整个系统中是单例的</strong>。如果单例 task 中存在了一个实例，那么会把已存在的任务调度到前台，<strong>且会调用该Activity的onNewIntent方法</strong>。</p>
<p>以 SingleInstance 模式启动的 Activity <strong>具有独占性</strong>，即它会<strong>独自占用一个task</strong>，<strong>被他开启的任何 Activity 都会运行在其他task中</strong>, 这一点与 singletask 模式有所区别。</p>
<h4 id="使用技巧-如何退出APP"><a href="#使用技巧-如何退出APP" class="headerlink" title="使用技巧:如何退出APP?"></a>使用技巧:如何退出APP?</h4><p>性能分析工具 dumpsys可以查看感兴任务栈信息</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">//1. 列出dumpsys所有支持命令</span><br><span class="line">adb shell dumpsys | grep <span class="string">"DUMP OF SERVICE"</span></span><br><span class="line">adb shell dumpsys activity  //检测Activity任务栈</span><br></pre></td></tr></table></figure>
<p>命令得到的信息很多，可以获取</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">ACTIVITY MANAGER RECENT TASKS (dumpsys activity recents)  </span><br><span class="line">Recent tasks:  </span><br><span class="line">* Recent #0: TaskRecord&#123;33618f06 #10871 A=com.lxt.toast U=0 sz=2&#125;  * </span><br><span class="line">Recent #1: TaskRecord&#123;38898108 #10872 A=com.qihoo360.mobilesafe U=0 sz=0&#125;ACTIVITY MANAGER ACTIVITIES (dumpsys activity activities)Display #0 (activities from top to bottom):  </span><br><span class="line">Stack #1:    Task id #10871      TaskRecord&#123;33618f06 #10871 A=com.lxt.toast U=0 sz=2&#125;      Intent &#123; act=android.intent.action.MAIN cat=[android.intent.category.LAUNCHER] flg=0x10000000 cmp=com.lxt.toast/.MainActivity &#125;        </span><br><span class="line">Hist #1: ActivityRecord&#123;30b1cfcf u0 com.lxt.toast/.Main2Activity t10871&#125;        </span><br><span class="line">Hist #0: ActivityRecord&#123;224a2c28 u0 com.lxt.toast/.MainActivity t10871&#125;    </span><br><span class="line">Task id #10868      TaskRecord&#123;32f0d2c6 #10868 A=com.android.settings U=0 sz=1&#125;  mFocusedActivity: ActivityRecord&#123;30b1cfcf u0 com.lxt.toast/.Main2Activity t10871&#125;  mFocusedStack=ActivityStack&#123;16b5b2d9 stackId=1, 51 tasks&#125; mLastFocusedStack=ActivityStack&#123;16b5b2d9 stackId=1, 51 tasks&#125;  mCurTaskId=10872</span><br></pre></td></tr></table></figure>
<p>singleTask 这个模式有一个重要应用，即所谓的“<strong>优雅的退出APP</strong>”。<strong>将第一个活动设置为singleTask 模式，则在其他活动中向首活动跳转将会将该栈内部的所有活动出栈。</strong></p>
<p>如果某APP中启动活动顺序是A–&gt;B—&gt;C—&gt;D，要从D中退出整个APP。原理是将活动A设置为singleTask 模式，并在该活动中跳转到启动活动A，则A之上的活动将全部出栈，最终结束A即可。</p>
<p>这么做的思路和原理是正确的，但是必须保证ABCD都处在同一个任务栈下才有效。<strong>A只能将和它相同的栈内的活动出栈，而不能将其他任务栈中的活动出栈</strong>。</p>
<blockquote>
<p>更简单的操作是直接使用finishAffinity()方法，<strong>注意该方法会销毁栈</strong>。</p>
</blockquote>
<h3 id="Intent"><a href="#Intent" class="headerlink" title="Intent"></a>Intent</h3><p>Intent 译作“意图”，表示一个对某类数据待执行的操作，可以用来启动安卓的三大组件活动，服务和广播。因为 Intent 将用在跨进程通信中，所以它是一个 Parcelable 类。</p>
<p>Intent 的基本信息包括 action 和 data。 Action 表示动作类型，Data 指定动作操作的数据 Uri。 例如 ACTION_VIEW 是默认动作，表示展示数据给用户，而展示何种数据由类型决定，展示的内容由 Uri 指定，下例表示展示文本数据。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Intent intent = <span class="keyword">new</span> Intent(ACTION_VIEW);</span><br><span class="line">intent.setType(<span class="string">"text/plain"</span>);</span><br><span class="line">startActivity(intent);</span><br></pre></td></tr></table></figure>
<p>发出此 Intent 后，设备内部能够匹配此意图的应用会出现在列表中，即数据展示方式由设备已有的程序决定。<strong>隐式 Intent 的解析机制依赖 IntentFilter ，安卓组件通过设置 IntentFilter 确定自己所能匹配的 Intent 。</strong></p>
<p>Intent 的补充信息包括Categories(对动作信息进行补充)，Type(指定数据的<strong>MIME</strong>类型)，Extras(提供<strong>额外信息</strong>)，</p>
<p>当发出 Intent 后会对 PackageManager 做查询，在 AndroidManifest.xml 配置文件上寻找能够完成匹配的安卓组件。组件中 IntentFilter 所定义的信息要全部一致才算匹配成功，如果定义了多个 category ，至少要匹配其中一个。</p>
<p>安卓组件也可以定义多个 intent-filter ，此时只要有一个匹配成功就能启动组件。</p>
<p>如果设备内没有能够响应 Intent 的程序，则会抛出异常，因此为安全起见可用如下方法预先判断下</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">List&lt;ResolveInfo&gt; resolveInfos = getPackageManager().queryIntentActivities(intent, PackageManager.MATCH_DEFAULT_ONLY);</span><br></pre></td></tr></table></figure>
<blockquote>
<p>PackageManager.MATCH_DEFAULT_ONLY表示只匹配设置了CATEGORY_DEFAULT的活动。</p>
</blockquote>
<p>标记位 Flags 控制动作的执行方式，它与具体的组件有关。最常见的标记位多是与活动组件由关的，以<code>FLAG_ACTIVITY</code>开头。</p>
<p><strong>1.FLAG_ACTIVITY_SINGLE_TOP</strong>表示<strong>SINGLE_TOP</strong>启动方式</p>
<p><strong>2.FLAG_ACTIVITY_NO_ANIMATION</strong>防止活动启动时使用转场动画。</p>
<p><strong>3.FLAG_ACTIVITY_TASK_ON_HOME</strong> 活动将在主屏幕所在栈上新栈，此时点击后退，将回退到主屏幕上。</p>
<p><strong>4.FLAG_ACTIVITY_CLEAR_TASK</strong> 此前的活动栈将销毁，所启动的活动将成为新栈的根，需要配合<code>FLAG_ACTIVITY_NEW_TASK</code>使用。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">intent.setFlags(Intent.FLAG_ACTIVITY_NEW_TASK);</span><br><span class="line">intent.addFlags(Intent.FLAG_ACTIVITY_CLEAR_TASK);</span><br></pre></td></tr></table></figure>
<h4 id="PendingIntent"><a href="#PendingIntent" class="headerlink" title="PendingIntent"></a>PendingIntent</h4><p><code>PendingIntent</code>表示一个<strong>延时意图</strong>，亦是<code>Parcelable</code>对象，<strong>因为是跨进程实现，即便启动进程销毁，IIntentSender对象依然存在在另一个进程中。这造成一个问题，使用该对象时如果进程已经有一个PendingIntent对象存在，应该如何处理？</strong></p>
<p><strong>1.不管怎样首先要判断两个PendingIntent是否相等？</strong></p>
<p>一个错误是创建多个仅仅”extra”不同的<code>PendingIntent</code>对象，这些实际上相同的。使用下列方法可以进行相等性判断</p>
<figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Intent#filterEquals(Intent)</span><br></pre></td></tr></table></figure>
<p><strong>2.发送时如果要创建不同的PendingIntent对象，可以更改getActivity方法中的请求码。</strong></p>
<p><strong>3.发送时如果要创建相同的PendingIntent对象，可以使用FLAG_UPDATE_CURRENT /FLAG_CANCEL_CURRENT标记位。</strong></p>
<ul>
<li><code>FLAG_ONE_SHOT</code> <code>PendingIntent</code>只使用一次</li>
<li><code>FLAG_NO_CREATE</code> <code>PendingIntent</code>如果不存在，不再创建</li>
<li><code>FLAG_CANCEL_CURRENT</code> 如果<code>PendingIntent</code>存在，取消创建新的 ，如果发送的intent仅仅在extra 数据不同，可以使用该标记位创建新的</li>
<li><code>FLAG_UPDATE_CURRENT</code> 如果<code>PendingIntent</code>存在，替代它的<code>extra data</code></li>
</ul>
<h2 id="几个常用的API"><a href="#几个常用的API" class="headerlink" title="几个常用的API"></a>几个常用的API</h2><p>关于栈</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">getTaskId</span><span class="params">()</span></span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">isTaskRoot</span><span class="params">()</span> </span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">moveTaskToBack</span><span class="params">(<span class="keyword">boolean</span> nonRoot)</span> <span class="comment">//隐藏栈，实际是是回到桌面</span></span></span><br></pre></td></tr></table></figure>
<p>创建和关闭</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">recreate</span><span class="params">()</span>；  </span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">finish</span><span class="params">()</span></span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">finishAffinity</span><span class="params">()</span><span class="comment">//关闭同一个栈内的活动public void finishAfterTransition() //等待动画完成</span></span></span><br></pre></td></tr></table></figure>
        
      
    </div>

    
    
    
      <footer class="post-footer">
          <div class="post-eof"></div>
        
      </footer>
  </div>
  
  
  
  </article>

    
        <article itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block home">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2017/05/06/android/View/文字效果(Spannable)/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="xiang">
      <meta itemprop="description" content="谨守而勿失，是谓反其真">
      <meta itemprop="image" content="/images/1.jpg">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="lxt">
    </span>
      <header class="post-header">
        <h1 class="post-title" itemprop="name headline">
            
            <a href="/2017/05/06/android/View/文字效果(Spannable)/" class="post-title-link" itemprop="url">文字效果(Spannable)</a>
          
        </h1>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              
                
              

              <time title="创建时间：2017-05-06 21:26:26" itemprop="dateCreated datePublished" datetime="2017-05-06T21:26:26+08:00">2017-05-06</time>
            </span>
          
            

            
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="fa fa-calendar-check-o"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2019-09-18 13:08:16" itemprop="dateModified" datetime="2019-09-18T13:08:16+08:00">2019-09-18</time>
              </span>
            
          
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing"><a href="/categories/android/" itemprop="url" rel="index"><span itemprop="name">android</span></a></span>

                
                
                  ，
                
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing"><a href="/categories/android/View/" itemprop="url" rel="index"><span itemprop="name">View</span></a></span>

                
                
              
            </span>
          

          
          <br>
            <span class="post-meta-item" title="本文字数">
              <span class="post-meta-item-icon">
                <i class="fa fa-file-word-o"></i>
              </span>
              
                <span class="post-meta-item-text">本文字数：</span>
              
              <span>6.7k</span>
            </span>
          
            <span class="post-meta-item" title="阅读时长">
              <span class="post-meta-item-icon">
                <i class="fa fa-clock-o"></i>
              </span>
              
                <span class="post-meta-item-text">阅读时长 &asymp;</span>
              
              <span>6 分钟</span>
            </span>
          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h2 id="基本原理"><a href="#基本原理" class="headerlink" title="基本原理"></a>基本原理</h2><p>首先来看<a href="https://github.com/quiqueqs/BabushkaText" target="_blank" rel="noopener">BabushkaText</a>库所达到的基本效果，使用方法如下</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">BabushkaText babushka = (BabushkaText)findViewById(R.id.babushka_text);</span><br><span class="line">babushka.addPiece(<span class="keyword">new</span> BabushkaText.Piece.Builder(<span class="string">"Central Park, NY\n"</span>)</span><br><span class="line">     .textColor(Color.parseColor(<span class="string">"#414141"</span>)) </span><br><span class="line">     .textSizeRelative(<span class="number">0.9f</span>)                  </span><br><span class="line">     .build());</span><br></pre></td></tr></table></figure>
<p>效果图示如下</p>
<img src="/2017/05/06/android/View/文字效果(Spannable)/example.png" title="BabushkaText">
<p>其核心在于使用 android.text 包内的 Spannable 接口，这里以它的父接口 Editable 来阐述。</p>
<p>Editable 接口继承 CharSequence(表示字符序列借口)，GetChars(获取字符)，Appendable(连接字符)，Spanned (装饰字符序列)以及 Spannable(添加和移除字符序列装饰)，可谓字符处理接口的集大成者。</p>
<p>当 TextView 接收 Spannable 字符时，将利用它提供的装饰效果， 改变文本格式，该方法如下</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//注意这里的参数是 Object，具体实现上使用 Object 提供改变文本绘制效果的信息。 </span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setSpan</span><span class="params">(Object what, <span class="keyword">int</span> start, <span class="keyword">int</span> end, <span class="keyword">int</span> flags)</span></span>;</span><br><span class="line"><span class="comment">// SPAN_EXCLUSIVE_INCLUSIVE 表示所选中的字符序列是开闭的， StrikethroughSpan 表示给字符序列添加中划线，</span></span><br><span class="line">Editable editable = Editable.Factory.getInstance().newEditable(<span class="string">"liuxiangtian"</span>);</span><br><span class="line">editable.setSpan(<span class="keyword">new</span> StrikethroughSpan(), <span class="number">0</span>, <span class="number">6</span>, Spannable.SPAN_EXCLUSIVE_INCLUSIVE);</span><br></pre></td></tr></table></figure>
<p>我们所熟悉的 Html 类实际上就是通过解析 html 文本中的标签，将其转换为带 Span 效果的 Spannable 对象。</p>
<p><strong>android.text 包下存在各种 Span 类，可以为字符序列添加各种效果，如BackgroundColorSpan 添加背景色，ForegroundColorSpan 改变字体颜色等等。</strong></p>
<p>回到 BabushkaText 库的实现上，它通过收集各个字符段落的绘制信息，并为各个段落设置 Span，最终合成为整体 Spannable 对象。</p>
<blockquote>
<p>BabushkaText 库实际上并不推荐使用，功能上单一，且不易扩展，继承 TextView 的做法也显得多余。</p>
</blockquote>
<h3 id="各种-Span-效果的实现原理"><a href="#各种-Span-效果的实现原理" class="headerlink" title="各种 Span 效果的实现原理"></a>各种 Span 效果的实现原理</h3><p>那么这些 Span 效果是如何实现的呢？</p>
<p>实现各种 Span 效果需要继承和实现如下接口，其本质是改变画笔 TextPaint 的属性</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="class"><span class="keyword">class</span> <span class="title">CharacterStyle</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="keyword">void</span> <span class="title">updateDrawState</span><span class="params">(TextPaint tp)</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>以绘制背景 BackgroundColorSpan 的实现为例</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//BackgroundColorSpan </span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">updateDrawState</span><span class="params">(TextPaint ds)</span> </span>&#123;</span><br><span class="line">    ds.bgColor = mColor;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这样绘制该段文本时的画笔类将切换背景颜色，其它大多数 Span 效果无不如此，如 ScaleXSpan类的实现如下</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ScaleXSpan ds.setTextScaleX(ds.getTextScaleX() * mProportion);</span><br></pre></td></tr></table></figure>
<p>值得注意的是 URLSpan 继承 ClickableSpan，表示可以点击的URL，其实现如下</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">updateDrawState</span><span class="params">(TextPaint ds)</span> </span>&#123;</span><br><span class="line">    ds.setColor(ds.linkColor);</span><br><span class="line">    ds.setUnderlineText(<span class="keyword">true</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onClick</span><span class="params">(View widget)</span> </span>&#123;</span><br><span class="line">    Uri uri = Uri.parse(getURL());</span><br><span class="line">    Intent intent = <span class="keyword">new</span> Intent(Intent.ACTION_VIEW, uri);</span><br><span class="line">    intent.putExtra(Browser.EXTRA_APPLICATION_ID, context.getPackageName());</span><br><span class="line">    context.startActivity(intent);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><strong>可见要实现点击跳转，需要继承 ClickableSpan，重写 onClick 方法。</strong></p>
<h3 id="ReplacementSpan-和-ImageSpan的利用"><a href="#ReplacementSpan-和-ImageSpan的利用" class="headerlink" title="ReplacementSpan 和 ImageSpan的利用"></a>ReplacementSpan 和 ImageSpan的利用</h3><p>子类 ReplacementSpan 及其下的扩展类 DynamicDrawableSpan 是一种特殊的 Span 效果，它不满足于仅仅修改画笔属性，使用圈定绘制区域，自定代理绘制效果。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="keyword">int</span> <span class="title">getSize</span><span class="params">(@NonNull Paint paint, CharSequence text,</span></span></span><br><span class="line"><span class="function"><span class="params">                    @IntRange(from = <span class="number">0</span>)</span> <span class="keyword">int</span> start, @<span class="title">IntRange</span><span class="params">(from = <span class="number">0</span>)</span> <span class="keyword">int</span> end,</span></span><br><span class="line"><span class="function">                    @Nullable Paint.FontMetricsInt fm)</span>;</span><br></pre></td></tr></table></figure>
<p>计算 Span 的宽度，</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> x Edge of the replacement closest to the leading margin.</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> top Top of the line.</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> y Baseline.</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> bottom Bottom of the line.</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> paint Paint instance.</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="keyword">void</span> <span class="title">draw</span><span class="params">(@NonNull Canvas canvas, CharSequence text,</span></span></span><br><span class="line"><span class="function"><span class="params">                          @IntRange(from = <span class="number">0</span>)</span> <span class="keyword">int</span> start, @<span class="title">IntRange</span><span class="params">(from = <span class="number">0</span>)</span> <span class="keyword">int</span> end, <span class="keyword">float</span> x,</span></span><br><span class="line"><span class="function">                          <span class="keyword">int</span> top, <span class="keyword">int</span> y, <span class="keyword">int</span> bottom, @NonNull Paint paint)</span>;</span><br></pre></td></tr></table></figure>
<p>绘制 Span 。</p>
<p>子类 DynamicDrawableSpan 将绘制的内容定义为 Drawable，由 Drawable 对象提供尺寸和绘制效果，只需要你实现以下方法来提供Drawable对象即可。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">abstract</span> Drawable <span class="title">getDrawable</span><span class="params">()</span></span>;</span><br></pre></td></tr></table></figure>
<p>使用时利用子类 ImageSpan 即可。</p>
<h4 id="ImageSpan-的实践"><a href="#ImageSpan-的实践" class="headerlink" title="ImageSpan 的实践"></a>ImageSpan 的实践</h4><p><a href="https://github.com/quiqueqs/BabushkaText" target="_blank" rel="noopener">BabushkaText</a>库的弱点实际上很多，在功能上它比较单一，不能实现如 <a href="https://github.com/JMPergar/AwesomeText" target="_blank" rel="noopener"><strong>AwesomeText</strong></a>库中圆角背景效果，</p>
<img src="/2017/05/06/android/View/文字效果(Spannable)/Screenshot.png" title="AwesomeText">
<p><a href="https://github.com/JMPergar/AwesomeText" target="_blank" rel="noopener"><strong>AwesomeText</strong></a>库正是利用 ImageSpan 来实现圆角背景效果的。</p>
<p>AwesomeText 的扩展性很好，你可以自定义效果</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MentionSpanRenderer</span> <span class="keyword">implements</span> <span class="title">AwesomeTextHandler</span>.<span class="title">ViewSpanRenderer</span>, <span class="title">AwesomeTextHandler</span>.<span class="title">ViewSpanClickListener</span> </span>&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> View <span class="title">getView</span><span class="params">(String text, Context context)</span> </span>&#123;</span><br><span class="line">        TextView view = <span class="keyword">new</span> TextView(context);</span><br><span class="line">        view.setText(text.substring(<span class="number">1</span>));</span><br><span class="line">        view.setBackgroundResource(R.drawable.round_cornor);</span><br><span class="line">        <span class="keyword">return</span> view;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onClick</span><span class="params">(String text, Context context)</span> </span>&#123;</span><br><span class="line">        Toast.makeText(context, <span class="string">"Hello "</span> + text, Toast.LENGTH_SHORT).show();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>在构建对应的 Spannable 对象时，从 getView 方法提供的View获得 Bitmap 对象，构建 ImageSpan ，</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">View view = renderer.getView(text, context);</span><br><span class="line">BitmapDrawable d = (BitmapDrawable) ViewUtils.convertViewToDrawable(view);</span><br><span class="line">bitmpaDrawable.setBounds(<span class="number">0</span>, <span class="number">0</span>, d.getIntrinsicWidth(), d.getIntrinsicHeight());</span><br><span class="line">spannableString.setSpan(<span class="keyword">new</span> ImageSpan(bitmpaDrawable), start, end, DEFAULT_RENDER_APPLY_MODE);</span><br></pre></td></tr></table></figure>
<p>这样原本的效果以 Bitmap 的方式被绘制出来。</p>
<blockquote>
<p><strong>AwesomeText 库的实现值得称道，它可以构建出任何效果，功能强大；且容易扩展，对 TextView 亦无侵入性。</strong></p>
</blockquote>
<h4 id="ReplacementSpan-的实践"><a href="#ReplacementSpan-的实践" class="headerlink" title="ReplacementSpan 的实践"></a>ReplacementSpan 的实践</h4><p>就达到圆角背景的效果而言，实际上继承 ReplacementSpan 并重写其 draw 方法 即可，亦能达到同样效果。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">CustomBackgroundSpan</span> <span class="keyword">extends</span> <span class="title">ReplacementSpan</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> color;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> corner;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">CustomBackgroundSpan</span><span class="params">(<span class="keyword">int</span> color, <span class="keyword">int</span> corner)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.color = color;</span><br><span class="line">        <span class="keyword">this</span>.corner = corner;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="meta">@Override</span> <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">getSize</span><span class="params">(Paint paint, CharSequence text, <span class="keyword">int</span> start, <span class="keyword">int</span> end, Paint.FontMetricsInt fm)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> Math.round(paint.getTextSize());</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="meta">@Override</span> <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">draw</span><span class="params">(Canvas canvas, CharSequence text, <span class="keyword">int</span> start, <span class="keyword">int</span> end, <span class="keyword">float</span> x, <span class="keyword">int</span> top, <span class="keyword">int</span> y, <span class="keyword">int</span> bottom, Paint paint)</span> </span>&#123;</span><br><span class="line">        paint.setColor(color);</span><br><span class="line">        RectF rect = <span class="keyword">new</span> RectF(x , top, x + paint.measureText(text, start, end) + corner, bottom);</span><br><span class="line">        canvas.drawRoundRect(rect, corner, corner, paint);</span><br><span class="line">        paint.setColor(Color.WHITE);</span><br><span class="line">        canvas.drawText(text, start, end, x + corner/<span class="number">2</span>, y, paint);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="Spannable的其它实践-：Phrase和ColorPhrase"><a href="#Spannable的其它实践-：Phrase和ColorPhrase" class="headerlink" title="Spannable的其它实践 ：Phrase和ColorPhrase"></a>Spannable的其它实践 ：<a href="https://github.com/square/phrase" target="_blank" rel="noopener">Phrase</a>和<a href="https://github.com/THEONE10211024/ColorPhrase" target="_blank" rel="noopener">ColorPhrase</a></h3><p>Spannable 的具体实现类是 SpannableString 和 SpannableStringBuilder，它们定义了文字的绘制方法，利用 它们做文章的库有很多。</p>
<p>Square 的 Sequence 库的主要目的是为了进行文本替换，使用方法如下</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">CharSequence formatted = Phrase.from(<span class="string">"Hi &#123;first_name&#125;, you are &#123;age&#125; years old."</span>)</span><br><span class="line">  .put(<span class="string">"first_name"</span>, firstName)</span><br><span class="line">  .put(<span class="string">"age"</span>, age)</span><br><span class="line">  .format();</span><br></pre></td></tr></table></figure>
<p>首先根据 <code>{}</code>收集替换文本，将它们变为 SpannableString ，而后使用替换的方式达成效果</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Override</span> <span class="function"><span class="keyword">void</span> <span class="title">expand</span><span class="params">(SpannableStringBuilder target, Map&lt;String, CharSequence&gt; data)</span> </span>&#123;</span><br><span class="line">  value = data.get(key);</span><br><span class="line">  <span class="keyword">int</span> replaceFrom = getFormattedStart();</span><br><span class="line">  <span class="keyword">int</span> replaceTo = replaceFrom + key.length() + <span class="number">2</span>;</span><br><span class="line">  <span class="comment">//将&#123;***&#125;内容替换成所定义的字符</span></span><br><span class="line">  target.replace(replaceFrom, replaceTo, value);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>ColorPhrase 的目的是更改文字颜色，其实现和Phrase类似。</p>
<img src="/2017/05/06/android/View/文字效果(Spannable)/Screenshot_2015-05-16-18-12-23.jpeg" title="ColorPhrase">
<blockquote>
<p>这两个库都是针对特定功能的实现，它们将搜索出的文本抽象成Token对象，并组成链表的方式。</p>
</blockquote>
<h2 id="其它效果"><a href="#其它效果" class="headerlink" title="其它效果"></a>其它效果</h2><h3 id="elegant-underline"><a href="#elegant-underline" class="headerlink" title="elegant-underline"></a><a href="https://github.com/romainguy/elegant-underline" target="_blank" rel="noopener">elegant-underline</a></h3><img src="/2017/05/06/android/View/文字效果(Spannable)/elegant-underline.png" title="elegant-underline">
<p>这个库的功能不是使用 Spannable 能够解决的，它要求下划线被文字截断。</p>
<p>它的实现其实也不复杂，求助于 Path 即可。</p>
<p>1.获得文字区域和路径</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">mPaint.getTextBounds(mText, <span class="number">0</span>, mText.length(), mBounds);mPaint.getTextPath(mText, <span class="number">0</span>, mText.length(), <span class="number">0.0f</span>, <span class="number">0.0f</span>, mOutline);</span><br></pre></td></tr></table></figure>
<p>2.确定下划线路径</p>
<p>下划线路径位于文字的 baseline 位置，故而下划线路径可以确定为</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">mUnderline.addRect(mBounds.left, <span class="number">3.0f</span> * density, mBounds.right, <span class="number">3.8f</span> * density, Direction.CW);</span><br></pre></td></tr></table></figure>
<p>3,.计算覆盖路径</p>
<p>此时唯一的问题在于计算两种路径的重叠：即文字覆盖下滑线的部分。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">mOutline.op(mUnderline, Path.Op.INTERSECT); <span class="comment">//此时取文字路径和下划线路径的交集</span></span><br></pre></td></tr></table></figure>
<p>因为此时是文字覆盖下划线，故而要在下划线路径上减去重叠路径。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">mUnderline.op(mOutline, Path.Op.DIFFERENCE); <span class="comment">//在下划线区域减去交集</span></span><br></pre></td></tr></table></figure>
<p><strong>此时截取的区域是致密的，如果要将边界扩大若干 dp，可以使用以下办法获得实际 Path</strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//使用具有 stroke 宽度的 Paint ，这样路径 src 会被扩展成路径 dstpublic boolean getFillPath(Path src, Path dst) ;</span></span><br></pre></td></tr></table></figure>
<blockquote>
<p>区域的剪切和拼接要仔细，此处容易出错。</p>
</blockquote>
<p>4最后分别绘制路径和下划线即可。</p>
<h3 id="Fancybuttons"><a href="#Fancybuttons" class="headerlink" title="Fancybuttons"></a><a href="https://github.com/medyo/Fancybuttons" target="_blank" rel="noopener">Fancybuttons</a></h3><img src="/2017/05/06/android/View/文字效果(Spannable)/cover.png" title="Fancybutton">
<p>这个效果是靠View组合来完成的，实际是一个 LinearLayout，这是传统的思路，不再多说。</p>

        
      
    </div>

    
    
    
      <footer class="post-footer">
          <div class="post-eof"></div>
        
      </footer>
  </div>
  
  
  
  </article>

    
        <article itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block home">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2017/05/06/android/View/Preference/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="xiang">
      <meta itemprop="description" content="谨守而勿失，是谓反其真">
      <meta itemprop="image" content="/images/1.jpg">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="lxt">
    </span>
      <header class="post-header">
        <h1 class="post-title" itemprop="name headline">
            
            <a href="/2017/05/06/android/View/Preference/" class="post-title-link" itemprop="url">Preference</a>
          
        </h1>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              
                
              

              <time title="创建时间：2017-05-06 21:26:26" itemprop="dateCreated datePublished" datetime="2017-05-06T21:26:26+08:00">2017-05-06</time>
            </span>
          
            

            
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="fa fa-calendar-check-o"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2019-09-17 22:21:50" itemprop="dateModified" datetime="2019-09-17T22:21:50+08:00">2019-09-17</time>
              </span>
            
          
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing"><a href="/categories/android/" itemprop="url" rel="index"><span itemprop="name">android</span></a></span>

                
                
                  ，
                
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing"><a href="/categories/android/View/" itemprop="url" rel="index"><span itemprop="name">View</span></a></span>

                
                
              
            </span>
          

          
          <br>
            <span class="post-meta-item" title="本文字数">
              <span class="post-meta-item-icon">
                <i class="fa fa-file-word-o"></i>
              </span>
              
                <span class="post-meta-item-text">本文字数：</span>
              
              <span>5.9k</span>
            </span>
          
            <span class="post-meta-item" title="阅读时长">
              <span class="post-meta-item-icon">
                <i class="fa fa-clock-o"></i>
              </span>
              
                <span class="post-meta-item-text">阅读时长 &asymp;</span>
              
              <span>5 分钟</span>
            </span>
          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h2 id="基本原理"><a href="#基本原理" class="headerlink" title="基本原理"></a>基本原理</h2><p>Preference 框架本质可以看出一个小APP，使用者通过在XML中配置 Preference ，配置内容主要涉及<strong>控件</strong>和<strong>数据</strong>。不同的 Preference 产生不同的控件，最终系统会生成列表 ListView 展示这些控件；所配置的数据也会被自动解析出，并渲染到 ListView 中去。而且数据还会使用 SharedPreference 进行持久化保存，且随着用户设置进行改变。</p>
<p>使用者只需要提供 <strong>XML 配置文件</strong>即可完成<strong>控件布局</strong>和<strong>配置数据读写</strong>。</p>
<h3 id="布局部分"><a href="#布局部分" class="headerlink" title="布局部分"></a>布局部分</h3><h4 id="PreferenceActivity"><a href="#PreferenceActivity" class="headerlink" title="PreferenceActivity"></a>PreferenceActivity</h4><p>PreferenceActivity 是 ListActivity 的子类，ListActivity 所加载的布局是 <code>com.android.internal.R.layout.list_content_simple</code>，该布局实际是一个<code>ListView</code>，并拥有 id 为 <code>@android:id/list</code>，只需要为其配置一个适配器就行了，你可以自定义布局，只要其中含有id 为 <code>@android:id/list</code>的 ListView 即可，否则会触发运行时异常。</p>
<p>当该活动内容发生变化时，如果设置了空视图(id必须为 @android:id/empty)，将展示空视图，空视图将设置给 ListView。</p>
<p>PreferenceActivity <strong>可以自己直接加载 ListView，但这已经不推荐了，故不再叙述。更多时候它在单屏时采用碎片，多屏时使用ListView 展示 Header 集合，而每个 Header 则用碎片展示。</strong></p>
<p>PreferenceActivity 类有一个内部类<code>Header</code>的集合，如果采用多屏显示应该覆盖下列方法，实例化这个集合。典型的实现如下</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">ArrayList&lt;Header&gt; mHeaders; </span><br><span class="line"></span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onBuildHeaders</span><span class="params">(List&lt;Header&gt; target)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">super</span>.onBuildHeaders(target); </span><br><span class="line">    <span class="comment">//使用loadHeadersFromResource方法将从配置文件中解析出 Header 集合对象。</span></span><br><span class="line">    loadHeadersFromResource(R.xml.setting_activity, target);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>典型的XML配置文件如下</p>
<figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">preference-headers</span> <span class="attr">xmlns:android</span>=<span class="string">"http://schemas.android.com/apk/res/android"</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">header</span> </span></span><br><span class="line"><span class="tag">        <span class="attr">android:id</span>=<span class="string">"@+id/header_application"</span> </span></span><br><span class="line"><span class="tag">        <span class="attr">android:title</span>=<span class="string">"外观"</span> </span></span><br><span class="line"><span class="tag">        <span class="attr">android:fragment</span>=<span class="string">"com.lxt.incredibly.SettingFragment"</span></span></span><br><span class="line"><span class="tag">        <span class="attr">android:icon</span>=<span class="string">"@android:drawable/ic_menu_share"</span> /&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">header</span> </span></span><br><span class="line"><span class="tag">        <span class="attr">android:id</span>=<span class="string">"@+id/header_support"</span> </span></span><br><span class="line"><span class="tag">        <span class="attr">android:title</span>=<span class="string">"支持"</span></span></span><br><span class="line"><span class="tag">        <span class="attr">android:icon</span>=<span class="string">"@android:drawable/ic_media_play"</span> /&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">preference-headers</span>&gt;</span></span><br></pre></td></tr></table></figure>
<p>而后就是为 Header 集合添加适配器 HeaderAdapter 。<strong>此时，点击单元将加载其定义的碎片。</strong></p>
<h4 id="PreferenceFragment"><a href="#PreferenceFragment" class="headerlink" title="PreferenceFragment"></a>PreferenceFragment</h4><p>PreferenceFragment 在创建视图时会加载系统布局<code>com.android.internal.R.styleable.PreferenceFragment_layout</code>，该布局内部有一个<code>ListView</code>控件。ListView 负责管理视图对象，而 PreferenceManager 则管理数据对象，二者的匹配都转移到了 PreferenceScreen 中完成。</p>
<p>使用时首先加载 XML 配置文件</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onCreate</span><span class="params">(Bundle savedInstanceState)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">super</span>.onCreate(savedInstanceState);</span><br><span class="line">    addPreferencesFromResource(R.xml.settings_fragment);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>PreferenceScreen 将使用XML解析出配置信息，并生成一个适配器给 ListView 完成适配这些配置信息。</p>
<p>注意此时还需要在活动中覆盖下列方法，判断碎片是否有效。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">boolean</span> <span class="title">isValidFragment</span><span class="params">(String fragmentName)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> (fragmentName.equals(SettingFragment.class.getName()));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>实际使用的适配器是 PreferenceGroupAdapter，适配的数据是 Preference，点击item实际执行的是 Preference 的点击事件</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onItemClick</span><span class="params">(AdapterView parent, View view, <span class="keyword">int</span> position, <span class="keyword">long</span> id)</span> </span>&#123;</span><br><span class="line">    Object item = getRootAdapter().getItem(position);</span><br><span class="line">    <span class="keyword">if</span> (!(item <span class="keyword">instanceof</span> Preference)) <span class="keyword">return</span>;</span><br><span class="line">    <span class="keyword">final</span> Preference preference = (Preference) item; </span><br><span class="line">    preference.performClick(<span class="keyword">this</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>Preference 的 performClick 方法实现如下</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">performClick</span><span class="params">(PreferenceScreen preferenceScreen)</span> </span>&#123;</span><br><span class="line">    </span><br><span class="line">    onClick(); <span class="comment">//白点1</span></span><br><span class="line">    </span><br><span class="line">    <span class="comment">//白点2</span></span><br><span class="line">    <span class="keyword">if</span> (mOnClickListener.onPreferenceClick(<span class="keyword">this</span>)) &#123;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//白点3</span></span><br><span class="line">    PreferenceManager.OnPreferenceTreeClickListener listener = preferenceManager</span><br><span class="line">                .getOnPreferenceTreeClickListener();</span><br><span class="line">    <span class="keyword">if</span> (listener.onPreferenceTreeClick(preferenceScreen, <span class="keyword">this</span>)) &#123;</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//白点4 处理Itent，只能在其它元素都不拦截的情况下才能发挥作用</span></span><br><span class="line">    <span class="keyword">if</span> (mIntent != <span class="keyword">null</span>) &#123;</span><br><span class="line">        Context context = getContext();</span><br><span class="line">        context.startActivity(mIntent);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="自定义-Prefrence"><a href="#自定义-Prefrence" class="headerlink" title="自定义 Prefrence"></a>自定义 Prefrence</h2><p>Prefrence 的默认布局是 mLayoutResId，改变这个参数能够自定义布局</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">int</span> mLayoutResId = com.android.internal.R.layout.preference;</span><br></pre></td></tr></table></figure>
<p>mLayoutResId 必须包括一些指定控件</p>
<figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">LinearLayout</span> <span class="attr">android:background</span>=<span class="string">"?android:attr/selectableItemBackground"</span> &gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">ImageView</span> <span class="attr">android:id</span>=<span class="string">"@+android:id/icon"</span>/&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">RelativeLayout</span> <span class="attr">android:layout_weight</span>=<span class="string">"1"</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">TextView</span> <span class="attr">android:id</span>=<span class="string">"@+android:id/title"</span> /&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">TextView</span> <span class="attr">android:id</span>=<span class="string">"@+android:id/summary"</span>/&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">RelativeLayout</span>&gt;</span></span><br><span class="line">    <span class="comment">&lt;!-- Preference should place its actual preference widget here. --&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">LinearLayout</span> <span class="attr">android:id</span>=<span class="string">"@+android:id/widget_frame"</span> /&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">LinearLayout</span>&gt;</span></span><br></pre></td></tr></table></figure>
<p>实际使用 mWidgetLayoutResId 参数更好。</p>
<p>例如CheckBoxPreference 这个子类</p>
<figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">style</span> <span class="attr">name</span>=<span class="string">"Preference.CheckBoxPreference"</span>&gt;</span></span><br><span class="line"><span class="xml">    <span class="tag">&lt;<span class="name">item</span> <span class="attr">name</span>=<span class="string">"widgetLayout"</span>&gt;</span>@layout/preference_widget_checkbox<span class="tag">&lt;/<span class="name">item</span>&gt;</span></span></span><br><span class="line"><span class="tag">&lt;/<span class="name">style</span>&gt;</span></span><br></pre></td></tr></table></figure>
<p>真实的布局如下，实际会用这个控件替换 widget_frame</p>
<figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">CheckBox</span> <span class="attr">xmlns:android</span>=<span class="string">"http://schemas.android.com/apk/res/android"</span></span></span><br><span class="line"><span class="tag">    <span class="attr">android:id</span>=<span class="string">"@+android:id/checkbox"</span> </span></span><br><span class="line"><span class="tag">    <span class="attr">android:layout_width</span>=<span class="string">"wrap_content"</span></span></span><br><span class="line"><span class="tag">    <span class="attr">android:layout_height</span>=<span class="string">"wrap_content"</span></span></span><br><span class="line"><span class="tag">    <span class="attr">android:focusable</span>=<span class="string">"false"</span></span></span><br><span class="line"><span class="tag">    <span class="attr">android:clickable</span>=<span class="string">"false"</span></span></span><br><span class="line"><span class="tag">    <span class="attr">android:background</span>=<span class="string">"@null"</span> /&gt;</span></span><br></pre></td></tr></table></figure>
<p>而后在方法 onBindView 中设置配置 CheckBox 控件</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">onBindView</span><span class="params">(View view)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">super</span>.onBindView(view);</span><br><span class="line">    View checkboxView = view.findViewById(com.android.internal.R.id.checkbox);</span><br><span class="line">    <span class="keyword">if</span> (checkboxView != <span class="keyword">null</span> &amp;&amp; checkboxView <span class="keyword">instanceof</span> Checkable) &#123;</span><br><span class="line">        ((Checkable) checkboxView).setChecked(mChecked);</span><br><span class="line">    &#125;</span><br><span class="line">    syncSummaryView(view);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="自定义-DialogPrefrence"><a href="#自定义-DialogPrefrence" class="headerlink" title="自定义 DialogPrefrence"></a>自定义 DialogPrefrence</h3><p>DialogPrefrence 自身的控件不是很重要，其关键在于点击它时将展示一个 Dialog，可以改变的是 Dialog 的布局。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">showDialog</span><span class="params">(Bundle state)</span> </span>&#123;</span><br><span class="line">    </span><br><span class="line">    mBuilder = <span class="keyword">new</span> AlertDialog.Builder(context)</span><br><span class="line">        .setTitle(mDialogTitle)</span><br><span class="line">        .setIcon(mDialogIcon)</span><br><span class="line">        .setPositiveButton(mPositiveButtonText, <span class="keyword">this</span>)  <span class="comment">//系统提供的@string/yes</span></span><br><span class="line">        .setNegativeButton(mNegativeButtonText, <span class="keyword">this</span>); <span class="comment">//系统提供的@string/no</span></span><br><span class="line">    View contentView = onCreateDialogView(); <span class="comment">//由参数 dialogLayout 提供</span></span><br><span class="line">    <span class="keyword">if</span> (contentView != <span class="keyword">null</span>) &#123;</span><br><span class="line">        onBindDialogView(contentView);</span><br><span class="line">        mBuilder.setView(contentView);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        mBuilder.setMessage(mDialogMessage);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    onPrepareDialogBuilder(mBuilder);</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">final</span> Dialog dialog = mDialog = mBuilder.create();</span><br><span class="line">    <span class="keyword">if</span> (state != <span class="keyword">null</span>) &#123;</span><br><span class="line">        dialog.onRestoreInstanceState(state);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (needInputMethod()) &#123;</span><br><span class="line">        requestInputMethod(dialog);</span><br><span class="line">    &#125;</span><br><span class="line">    dialog.setOnDismissListener(<span class="keyword">this</span>);</span><br><span class="line">    dialog.show();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><strong>这里参数 dialogLayout提供自定义布局，它和 message 是互斥的。</strong></p>
<p>因此自定义 DialogPrefrence 即可以继承该类，提供 View；也可以直接继承 Prefrence 自己提供 Dialog，这样能够发挥自定义 Dialog 的优势，如提供动画效果。</p>
<h3 id="自定义一个颜色选择器"><a href="#自定义一个颜色选择器" class="headerlink" title="自定义一个颜色选择器"></a>自定义一个颜色选择器</h3><p>自定义一个颜色选择器是一个综合应用，其实现可以看<a href="https://github.com/liuxiangtian/ColorPickPreference" target="_blank" rel="noopener">ColorPickPreference</a>。</p>

        
      
    </div>

    
    
    
      <footer class="post-footer">
          <div class="post-eof"></div>
        
      </footer>
  </div>
  
  
  
  </article>

    
  </div>

  
  <nav class="pagination">
    <a class="extend prev" rel="prev" href="/page/2/"><i class="fa fa-angle-left" aria-label="上一页"></i></a><a class="page-number" href="/">1</a><a class="page-number" href="/page/2/">2</a><span class="page-number current">3</span>
  </nav>


          </div>
          

        </div>
          
  
  <div class="sidebar-toggle">
    <div class="sidebar-toggle-line-wrap">
      <span class="sidebar-toggle-line sidebar-toggle-line-first"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-middle"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-last"></span>
    </div>
  </div>

  <aside class="sidebar">
    <div class="sidebar-inner">

      <ul class="sidebar-nav motion-element">
        <li class="sidebar-nav-toc">
          文章目录
        </li>
        <li class="sidebar-nav-overview">
          站点概览
        </li>
      </ul>

      <!--noindex-->
      <div class="post-toc-wrap sidebar-panel">
      </div>
      <!--/noindex-->

      <div class="site-overview-wrap sidebar-panel">
        <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
    <img class="site-author-image" itemprop="image"
      src="/images/1.jpg"
      alt="xiang">
  <p class="site-author-name" itemprop="name">xiang</p>
  <div class="site-description" itemprop="description">谨守而勿失，是谓反其真</div>
</div>
  <nav class="site-state motion-element">
      <div class="site-state-item site-state-posts">
        
          <a href="/archives/">
        
          <span class="site-state-item-count">30</span>
          <span class="site-state-item-name">日志</span>
        </a>
      </div>
    
      
      
      <div class="site-state-item site-state-categories">
        
          
            <a href="/categories/">
          
        
        <span class="site-state-item-count">11</span>
        <span class="site-state-item-name">分类</span>
        </a>
      </div>
    
  </nav>
  <div class="links-of-author motion-element">
      <span class="links-of-author-item">
      
      
        
      
      
        
      
        <a href="https://github.com/liuxiangtian" title="GitHub &rarr; https://github.com/liuxiangtian" rel="noopener" target="_blank"><i class="fa fa-fw fa-github"></i>GitHub</a>
      </span>
    
      <span class="links-of-author-item">
      
      
        
      
      
        
      
        <a href="http://www.zhihu.com/people/liu-xiang-tian-74" title="zhihu &rarr; http://www.zhihu.com/people/liu-xiang-tian-74" rel="noopener" target="_blank"><i class="fa fa-fw fa-globe"></i>zhihu</a>
      </span>
    
  </div>



      </div>

    </div>
  </aside>
  <div id="sidebar-dimmer"></div>


      </div>
    </main>

    <footer id="footer" class="footer">
      <div class="footer-inner">
        <div class="copyright">&copy; <span itemprop="copyrightYear">2019</span>
  <span class="with-love" id="animate">
    <i class="fa fa-user"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">刘祥</span>
    <span class="post-meta-divider">|</span>
    <span class="post-meta-item-icon">
      <i class="fa fa-area-chart"></i>
    </span>
    <span title="站点总字数">214k</span>
    <span class="post-meta-divider">|</span>
    <span class="post-meta-item-icon">
      <i class="fa fa-coffee"></i>
    </span>
    <span title="站点阅读时长">3:15</span>
</div>



        












        
      </div>
    </footer>
  </div>

  


  <script src="/lib/anime.min.js?v=3.1.0"></script>
  <script src="/lib/velocity/velocity.min.js?v=1.2.1"></script>
  <script src="/lib/velocity/velocity.ui.min.js?v=1.2.1"></script>
<script src="/js/utils.js?v=7.4.0"></script><script src="/js/motion.js?v=7.4.0"></script>
<script src="/js/schemes/pisces.js?v=7.4.0"></script>

<script src="/js/next-boot.js?v=7.4.0"></script><script src="/js/bookmark.js?v=7.4.0"></script><!-- hexo-inject:begin --><!-- hexo-inject:end -->



  





















  

  
    
      
    
      
    
      
    
      
    
      
    
      
    
      
    
      
    
      
    
      
    
  

  

  

</body>
</html>
